{
  "postList": [
    {
      "content": "<div class=\"markdown-text\"><p>RT.</p>\n<p>请大家遵守法律法规，勿发布不合规内容。</p></div>",
      "title": "请大家遵纪守法123123123",
      "author": {
        "loginname": "12312313123",
        "avatar_url": "https://avatars.githubusercontent.com/u/958063?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "id": "5fdb44d70f99cb37f45e3410",
      "num": 1,
      "country": "USA"
    },
    {
      "content": "<div class=\"markdown-text\"><p>BFF、SSR、Serverless…… 随着技术的浪潮不断翻涌， Node.js 正在为我们逐渐带来更多的生产力。为了更好的了解 Node.js 生态现状，帮助大家：</p>\n<ul>\n<li>了解大家都是如何使用 Node.js？</li>\n<li>梳理这个语言的技术栈</li>\n<li>聚焦大家都在关注些什么？</li>\n<li>帮助开发者找准这个语言的定位（用来干什么的）</li>\n<li>找到目前生态所缺乏的以及被期望的内容</li>\n<li>辅助企业招聘</li>\n</ul>\n<p>欢迎您来参加 Node.js 开发者调查问卷，希望您能抽出一点时间，将您的感受和建议告诉我们，我们非常重视每位开发者的宝贵意见。</p>\n<p>问卷结束后我们会给留邮箱的同学第一时间电邮分析报告，期待您的参与！</p>\n<p>这大约需要花费您 3~5 分钟，链接请戳：<a href=\"https://www.wjx.cn/vj/Q08EYUi.aspx\">https://www.wjx.cn/vj/Q08EYUi.aspx</a></p>\n<p>钉钉/微信等 app 扫码也可以进入问卷 <img src=\"//static.cnodejs.org/FvONO4yEIfK-iF1mDbZlskoiiYY2\" alt=\"qrcode_www.wjx.cn.png\" /></p>\n<p>本问卷目前由腾讯 &amp; 阿里前端发起，去年的问卷 <a href=\"https://nodersurvey.github.io/reporters/\">https://nodersurvey.github.io/reporters/</a></p></div>",
      "title": "2022 Node.js 开发者问卷调查",
      "author": {
        "loginname": "lellansin",
        "avatar_url": "https://avatars.githubusercontent.com/u/2081487?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "id": "6108bbc2a5d29d175c2d4208",
      "num": 2,
      "country": "China"
    },
    {
      "content": "<div class=\"markdown-text\"><p>五月是一个好月份，五月的武汉也很漂亮。2020 年，疫情肆虐，我们无奈停止了 Node 地下铁一段时间。今年 3 月份我们重启了 Node 地下铁；而今年五月，我们决定与大家一起去见证一下武汉焕新的活力，在武汉举办一场热干面专场（第 11 期）。</p>\n<p>Node 地下铁沙龙是阿里巴巴淘系前端发起的一个线下技术沙龙。非常感谢有赞联合举办本期活动。</p>\n<h2 id=\"\">活动信息</h2>\n<ul>\n<li><strong>本期主题</strong>：从社区到企业级实践</li>\n<li><strong>本期出品人</strong>：死月；</li>\n<li><strong>主持人</strong>：艺璇；</li>\n<li><strong>圆桌主持人</strong>：狼叔（i5ting）；</li>\n<li><strong>时间</strong>：2021 年 5 月 23 日 13:00 ~ 18:00；</li>\n<li><strong>地点</strong>：武汉保利国际中心 35 层 P1-2。</li>\n</ul>\n<p>本期我们邀请到了淘宝、蚂蚁集团、有赞、腾讯以及 Wiredcraft 的小伙伴，为大家献上新的一期 Node.js 话题盛宴，炒一炒武汉这个美丽城市的 Node.js 热度。活动最后，还有神秘嘉宾**狼叔（i5ting）**为大家主持圆桌讨论和抽奖。真的血赚！</p>\n<p>感兴趣的小伙伴们，无论你们是已经在职工作，还是尚在学校进修，都欢迎来报名呀。Node 地下铁报名免费，只要通过审核即可来参加。**名额有限，先到先得。**望大家互相传阅。</p>\n<blockquote>\n  <p>本期官网：<a href=\"https://subway.midwayjs.org/\">https://subway.midwayjs.org/</a></p>\n  <p>报名链接：<a href=\"https://www.huodongxing.com/event/7596833409300\">https://www.huodongxing.com/event/7596833409300</a></p>\n</blockquote>\n<h2 id=\"-1\">话题介绍</h2>\n<h3 id=\"nodejstars\">Node.js 在 TARS 微服务框架中的实践</h3>\n<p><img src=\"//static.cnodejs.org/FnSk20oDl0RaRhRupa-2jCqK-9Fo\" alt=\"image.png\" /></p>\n<blockquote>\n  <p>邹成卓 @腾讯 高级前端工程师</p>\n</blockquote>\n<p>TARS Node.js 是开源微服务框架 TARS 的 Node.js 语言部分，为 Node.js 服务端提供了一套完整的开发运维环境。包含了进程管理、日志输出、调用监控、特性监控、RPC 调用、快速扩缩容等功能，让 Node.js 开发者可以专注于业务代码，其它交给 TARS。</p>\n<h3 id=\"nodejsmidwayjs\">Node.js &amp; Midway.js 源码贡献指北</h3>\n<p><img src=\"//static.cnodejs.org/FnIqqd_BtjPowS1mxBioW6Eck9K5\" alt=\"image.png\" /></p>\n<blockquote>\n  <p>刘子健 @淘宝 / Node.js Core Collaborator</p>\n</blockquote>\n<p>开源生态是现代软件开发中极其重要的组成部分，以 Node.js 为例，自发布以来持续有社区的开发者为其贡献代码。本次分享也将从 Node.js 源码出发，讲解其源码构成与贡献方式。同时我们也会讲解阿里巴巴的开源 Node.js 框架 Midway 开发方式，帮助新手更快的投入的社区开源项目的建设中。</p>\n<h3 id=\"nodejs\">复杂系统的原理及其在 Node.js 系统开发中的应用</h3>\n<p><img src=\"//static.cnodejs.org/Frz8neRk38efUCCpIwRc5G_wB86b\" alt=\"image.png\" /></p>\n<blockquote>\n  <p>王韬 <a href=\"/user/Wiredcraft\">@Wiredcraft</a> 架构师</p>\n</blockquote>\n<p>在软件行业，大量系统架构设计和工作流程设计还是基于经验或直觉，特定环境中特定决策的后果难以预测，团队成员的决策能力难以高效提升，我们需要用更加工程化的方式，做出高质量的决策。本次分享介绍一些复杂系统领域的基本原理，以及在使用 Node.js 进行开发中的应用。</p>\n<h3 id=\"appenginenodejs\">App Engine——一个轻量级的 Node.js 服务托管和调度平台</h3>\n<p><img src=\"//static.cnodejs.org/Fly7yNP2ISvn4dw_XlGXZjco36Xk\" alt=\"image.png\" /></p>\n<blockquote>\n  <p>王干（KK） @有赞 技术专家</p>\n</blockquote>\n<p>有赞 App Engine（应用引擎）是一套面向前端开发及运维的一站式 Node.js 服务容器化平台，为前端开发者提供统一和规范化的 Node.js 服务研发模式。本次分享将为大家介绍有赞 App Engine 的设计理念、实践总结以及背后的技术原理。</p>\n<h3 id=\"javascript\">JavaScript 全栈高效研发在语雀中的实践</h3>\n<p><img src=\"//static.cnodejs.org/FtCsHoEri9rSIVXYYEMy8mUmRZoT\" alt=\"image.png\" /></p>\n<blockquote>\n  <p>赵珊珊（西临） @蚂蚁集团 前端专家</p>\n</blockquote>\n<p>语雀作为一个复杂的 Node.js 应用，如何以小规模的研发团队支撑业务的快速发展是我们不断探索的命题。这几年，我们在业务实践中总结出了一些能够有效保障研发效率的全栈开发经验，本次分享将为大家一一介绍。</p>\n<p><img src=\"https://img.alicdn.com/imgextra/i3/O1CN01ayQ7Wh1SOafw66J2N_!!6000000002237-0-tps-750-2273.jpg\" alt=\"\" /></p></div>",
      "title": "5 月 23 日Node 地下铁武汉热干面专场PPT",
      "author": {
        "loginname": "123123",
        "avatar_url": "https://avatars.githubusercontent.com/u/2842176?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "id": "607ea4374d20cbe2d168d737",
      "num": 3,
      "country": "USA"
    },
    {
      "id": "618a15021affc17b28492a43",
      "content": "<div class=\"markdown-text\"><p>Next.js是一个用于生产环境的React 应用框架（官方介绍：The React Framework for Production），使用它可以快速上手开发 React 应用（ enables you to build superfast and extremely user-friendly static websites,），而不需要花很多时间和精力去折腾各种开发工具。所谓的用于生产环境，是指功能和稳定性足够，有大量的实际应用案例。</p>\n<p>在整理编辑大人给的《狼书（卷3）：Node.js高级技术》修订版，给next.js一个明确观点：“整体来看，Next.js在Node.js Web开发领域是一个非常优秀的SSR框架，其众多优秀特性，外加Blitzjs这种周边生态，对于开箱即用的项目来说是极好的。从架构的角度，笔者以为Next.js是过度设计，从商业的角度，我认同Next.js的做法，易用性应该是开发领域最该重视的核心。”</p>\n<p>之所以给出这样一个观点，是基于下面5个方面总结出来的。</p>\n<ul>\n<li>next.js是什么？有哪些优点？为啥狼叔觉得它看起来像一个海王？</li>\n<li>对比cra，umi和next.js，它们之间的差异是什么？</li>\n<li>next.js生态除了vercel，还有rust和blitzjs，你都了解吗？</li>\n<li>实现一个框架有哪4方面的思考？</li>\n<li>在服务端渲染领域，对比next.js和ykfe/ssr，有何异同？</li>\n</ul>\n<p>内容有点多，大家需要有点耐心。</p>\n<p><a href=\"https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw\">https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw</a></p>\n</div>",
      "title": "我看Next.js：一个更现代的海王",
      "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars.githubusercontent.com/u/3118295?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 4,
      "country": "USA"
    },
    {
      "id": "613ea37afe0c515786ae9b51",
      "content": "<div class=\"markdown-text\"><h2>Beehive</h2>\n<h2>前言</h2>\n<p>Beehive 是一个项目管理系统。参考于Teambetion、PearProject，实现部分功能。</p>\n<p>这是一个Vue+Node.js的js全栈项目。基于RBAC模型做权限控制，动态配置菜单，前端实现页面元素级别的权限控制。通过WebSocket实现站内信功能，任务看板中，实现更新同步推送。一旦其他项目成员有对我们当前查看的项目任务做任何的操作，页面都将立即同步更新，并向此任务的所有参与者（除了操作者）发送消息通知。注册和找回密码需要通过邮箱验证码验证，可以通过github授权登陆（不是很稳定）。</p>\n<p>Node.js框架选用的是Egg.js，配合sequelize，自己写了一个小工具。可以通过填写表字段的配置，执行npm run generator-entity自动生成一整套文件，包括Swagger、数据校验validate、Sequelize需要的model、controller、service、router。并自动创建数据库表，包括每个字段的类型、长度、是否能为空、默认值、注释、索引、甚至是外键都能搞定。因为加了权限控制，所以还要到前端的资源管理中添加一下新增的资源，并在角色中点选分配一下，就完成了一张表的CRUD了，包括新增、修改、详情、批量删除、分页列表。当然这还是有很多可以优化的空间的，但也基本够用了。为了优化鉴权消耗，以及满足WebSocket的可靠性设计需要，系统引入Redis做缓存。</p>\n<p>密码是加盐存储的，且在传输过程中使用了RSA做了非对称加密。Jwt认证使用Access Token + Refresh Token，配合黑名单。</p>\n<h2>效果演示</h2>\n<p>预发布环境：超级管理员账号：test-super ，密码：test-super123 <a href=\"https://beehives.imfdj.top/\">预发布环境地址：beehives.imfdj.top</a></p>\n<p>预发布环境：普通用户账号：test-user ，密码：test-user123</p>\n<p>生产环境：普通用户账号：test-user ，密码：test-user123 <a href=\"https://beehive.imfdj.top/\">生产环境地址：beehive.imfdj.top</a></p>\n<h2>技术栈</h2>\n<p>前端：Vue2全家桶 + Element-ui + Axios + <a href=\"http://Vue-socket.io\">Vue-socket.io</a> + Sass <a href=\"https://github.com/Imfdj/vue-beehive\">前端项目github地址</a></p>\n<p>后端：Egg.js + Sequelize + Jwt + Mysql + Redis + Socket + Swagger <a href=\"https://github.com/Imfdj/egg-beehive\">后端项目github地址</a></p>\n<h2>说明</h2>\n<blockquote>\n<p>如果对您有帮助，您可以点右上角 “Star” 支持一下 谢谢！ ^_^</p>\n</blockquote>\n<blockquote>\n<p>或者您可以 “follow” 一下，我会不断开源更多的有趣的项目。如：Vue3 + NestJS + TypeScript ✨</p>\n</blockquote>\n<blockquote>\n<p>如有问题请直接在 Issues 中提，或者您发现问题并有非常好的解决方案，欢迎 PR 👍</p>\n</blockquote>\n<h2>目标功能</h2>\n<ul>\n<li>[x] 登录、注册 – 完成</li>\n<li>[x] github授权登录 – 完成</li>\n<li>[x] 找回密码 – 完成</li>\n<li>[x] 滑块验证 – 完成</li>\n<li>[x] 邮箱验证 – 完成</li>\n<li>[x] 动态首页 – 完成</li>\n<li>[x] 个人设置 – 完成</li>\n<li>[x] 用户管理 – 完成</li>\n<li>[x] 角色管理 – 完成</li>\n<li>[x] 菜单管理 – 完成</li>\n<li>[x] 资源管理 – 完成</li>\n<li>[x] 操作日志 – 完成</li>\n<li>[x] 动态菜单 – 完成</li>\n<li>[x] 部门管理 – 完成</li>\n<li>[x] 项目列表 – 完成</li>\n<li>[x] 任务看板 – 完成</li>\n<li>[x] 任务列表 – 完成</li>\n<li>[x] 项目文件 – 完成</li>\n<li>[x] 项目概览 – 完成</li>\n<li>[x] 项目成员 – 完成</li>\n<li>[x] 项目邀请 – 完成</li>\n<li>[x] 项目设置 – 完成</li>\n<li>[x] 项目回收站 – 完成</li>\n<li>[x] 任务筛选 – 完成</li>\n<li>[x] 任务详情 – 完成</li>\n<li>[x] 任务标签 – 完成</li>\n<li>[x] 任务参与者 – 完成</li>\n<li>[x] 任务动态 – 完成</li>\n<li>[x] 任务工时 – 完成</li>\n<li>[x] 任务关联文件 – 完成</li>\n<li>[x] 任务更新即时同步 – 完成</li>\n<li>[x] 公开项目的业务权限控制（非项目成员不可编辑项目） – 完成</li>\n<li>[x] 项目模板 – 完成</li>\n<li>[x] 消息提醒 – 完成</li>\n<li>[x] 工作台 – 完成</li>\n<li>[x] 站内信 – 完成</li>\n<li>[x] 页面元素权限控制 – 完成</li>\n<li>[ ] 项目版本 – 待开发</li>\n<li>[ ] 项目日程 – 待开发</li>\n</ul>\n<h2>部分截图</h2>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98bd6c8cc8934a468323a727a0418c14~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf106182c18b4f34b93d0b03a51c6f66~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/536aa525ed88463aae1ba10de25ec9fc~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca8fdca695024a4b8d7a2728b717adad~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a573d49b2646c6aa35cd74a7bbb680~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d5b6678731a4092ae53289ee367c008~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9a31bc814104964b5e63b4a0e6dd039~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c726195939f4823a27d9a56e7150fdc~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d49517621874f819df6991107c68252~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30038b8cbfed4cc2aa7e8dc8d03aaf81~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8ddd9c5eb4b4219a6008b9944cb59bc~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3caf807ee6a4c108d0bf533117ea9d6~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h2>后端egg项目部署</h2>\n<h4>运行环境：</h4>\n<p>Node.js &gt;= v10; Mysql &gt;= 5.7; Redis &gt;= 5.0;</p>\n<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;Imfdj&#x2F;egg-beehive.git\n\ncd egg-beehive\n\nnpm install 或 yarn(推荐)\n\n将database目录下的egg-beehive-dev.sql和egg-beehive-test.sql导入mysql（推荐navicat）。\n\n在config目录下的config.local.js和config.unittest.js中的exports.sequelize、exports.redis、exports.io.redis下填入Mysql和Redis的配置参数\n\nnpm run dev\n\nnpm run test-local (单元测试)\n</code></pre><h4>如何快速CRUD：</h4>\n<pre class=\"prettyprint\"><code>在generator文件夹中的config.js文件中定义各个字段的描述，完成后执行npm run generator-entity。\n里面还有很多config-*.js的配置文件可供参考。也可以在template文件夹中自定义各个文件的模板。\n\n&#x2F;&#x2F; 这是一个字段的描述模板\nfieldsItemExample: {\n    name: &#x27;xx_id&#x27;,\n    type: &#x27;INTEGER&#x27;,\n    length: 11,\n    min: 1,\n    max: 1,\n    required: true,\n    description: &#x27;这里是描述&#x27;, &#x2F;&#x2F; 供swagger使用\n    primaryKey: false, &#x2F;&#x2F; 是否为主键\n    unique: false, &#x2F;&#x2F; 是否唯一\n    allowNull: false, &#x2F;&#x2F; 是否允许为空\n    autoIncrement: false, &#x2F;&#x2F; 是否自增\n    defaultValue: &#x27;&#x27;, &#x2F;&#x2F; 数据库表中字段的默认值\n    comment: &#x27;外键&#x27;, &#x2F;&#x2F; 数据库表中字段的描述\n    references: {\n      &#x2F;&#x2F; 外键设置\n      model: &#x27;xxxs&#x27;, &#x2F;&#x2F; 外键关联表\n      key: &#x27;id&#x27;, &#x2F;&#x2F; 外键字段名\n    },\n    onUpdate: &#x27;NO ACTION&#x27;, &#x2F;&#x2F; 外键更新约束 CASCADE RESTRICT SET NULL SET DEFAULT NO ACTION\n    onDelete: &#x27;NO ACTION&#x27;, &#x2F;&#x2F; 外键删除约束 CASCADE RESTRICT SET NULL SET DEFAULT NO ACTION\n}\n</code></pre><h2>前端vue项目部署</h2>\n<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;Imfdj&#x2F;vue-beehive.git\n\ncd vue-beehive\n\nnpm install 或 yarn(推荐)\n\nnpm run serve\n</code></pre><h2>功能设计</h2>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a57ff9d3eb8482691bc50aa5e029bf9~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h2>后端设计</h2>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae66afbb7bc24cb5af6b07249f99c88a~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h2>数据库设计</h2>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bd0481b00f4475fa77a970db1df5011~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>License</h3>\n<p><a href=\"https://github.com/Imfdj/vue-beehive/blob/master/LICENSE\">MIT</a></p>\n<p>Copyright © 2021 Imfdj</p>\n</div>",
      "title": "🚀Vue + Egg.js + Mysql 的 JS全栈实践。动态菜单，RBAC权限模型，WebSocket实现站内信。。",
      "author": {
        "loginname": "Imfdj",
        "avatar_url": "https://avatars.githubusercontent.com/u/25856248?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 5,
      "country": "USA"
    },
    {
      "id": "61405b76fe0c5109a7aea0ed",
      "content": "<div class=\"markdown-text\"><p>本机已安装 nrm，执行 nrm list 效果如下：</p>\n<ul>\n<li>npm -------- <a href=\"https://registry.npmjs.org/\">https://registry.npmjs.org/</a></li>\n<li>yarn ------- <a href=\"https://registry.yarnpkg.com/\">https://registry.yarnpkg.com/</a></li>\n<li>cnpm ------- <a href=\"http://r.cnpmjs.org/\">http://r.cnpmjs.org/</a></li>\n<li>taobao ----- <a href=\"https://registry.npm.taobao.org/\">https://registry.npm.taobao.org/</a></li>\n<li>nj --------- <a href=\"https://registry.nodejitsu.com/\">https://registry.nodejitsu.com/</a></li>\n<li>npmMirror – <a href=\"https://skimdb.npmjs.com/registry/\">https://skimdb.npmjs.com/registry/</a></li>\n<li>edunpm ----- <a href=\"http://registry.enpmjs.org/\">http://registry.enpmjs.org/</a></li>\n</ul>\n<p>疑问：在项目中 package-lock.json 发现有的包的地址是：<a href=\"https://registry.nlark.com\">https://registry.nlark.com</a>，这是什么源？</p>\n</div>",
      "title": "npm 源问题",
      "author": {
        "loginname": "andyComeOn",
        "avatar_url": "https://avatars.githubusercontent.com/u/19949116?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 6,
      "country": "Eurozone"
    },
    {
      "id": "618b782ae6c91a7c59916868",
      "content": "<div class=\"markdown-text\"><p>记得 Google 刚推出 Picasa Web 相⽚服务时我开⼼坏了，⽤电脑上的 Picasa 程序整理了很多喜欢的图⽚同步了上去。时⾄今⽇已经10多年过去了，可再回头浏览时还经常会被当时的⼀些图⽚所触动。当时所有图⽚我都是从电脑硬盘传上去的，毕竟，只要家⾥没有 NAS，单个硬盘就不那么可靠，相⽚⽇积⽉累，⼏个硬盘相互备份累得慌。话虽如此，当苹果刚推出 iCloud 相⽚服务时，我⼼⾥开始嘀咕：我⼿机⾥的相⽚放你服务器⾥⼲嘛？有那个必要么？只要做好iTunes备份就基本不⽤担⼼可靠性问题好吗？毕竟，放服务器也太容易带来隐私问题了！</p>\n<p>然⽽，我显然没看清这个服务的价值。虽然备份相⽚不算⿇烦，可时间⻓了也挺烦的。另外，隐私问题基本可以依赖技术和法律做到⼀旦出问题，违法者需要承担相当⾼的消除或解释证据链成本，⽽ iCloud 照⽚服务也并不是仅作存储，还有好些其他贴⼼服务，⽐如，能通过描述来搜图，⽐如，能⾃动整理相⽚并在某个时刻勾起那时的美好回忆。我当然没在为 iCloud 打⼴告，但这的确佐证了⼀件事：云端服务将越来越多地进⼊我们的⽣活。或许有⼀天，就像⽔和电那样让我们⼏乎忘记了它们的存在。</p>\n<p>作为⼀名软件开发⼈员，我不时会想：未来我会以怎样⼀种⽅式进⾏软件开发。性能优良的硬件？必须的，M1 Pro/Max, M2, M3… 此外，顺⼿的 IDE，⾼带宽，低延时…假如想得极端⼀点，这些软硬件都达到了极致，这时我就拥有了理想的软件开发⽅式了吗？还缺啥？下⼀代软件开发模式（可能）是啥样的？除⾮只开发单⼈就能全权掌管的项⽬，否则我将来的软件开发⼀定还是和许多⼈⼀起进⾏。要么别⼈在我开发的代码上修正错误增强功能，要么我也这样帮助他⼈，所以，将来的开发⼀定离不开“协作”。客观地说，现在的云端协作开发服务不少，只是在我眼⾥，还不太⾏。我认为最缺的是“环境”，包括开发和运⾏环境。虽然我们可以使⽤云端协作功能实时看到代码的变动，对⽅也能轻易地拿到我机器上运⾏的代码，然⽽，要让他⼈调试/运⾏我开发的功能，或对⽅在我的机器⾥复现他遇到的问题，成本还是相当⾼，甚⾄不可能。</p>\n<p>我也了解到目前有些协同开发的平台，<a href=\"https://www.teamcode.com/\"></a>TeamCode就是其中之一。除了基本的协作开发Cloud-IDE，还有同步云端开发环境的产品<a href=\"https://docs.teamcode.com/en-US/dcs/what-is-dcs\"></a>DCS，你开发的项⽬，不仅能在他⼈机器上⼀键运⾏，还能在对⽅修改后，在你的机器上立刻运行起来。不仅能通过极⼤地降低乃⾄消除环境差异来降低时间成本，还能在整个软件开发的⽣命周期，包括测试，打包，部署上也做到时间和资⾦上的低成本。毕竟，谁不想既能省钱，还能省事⼉呢？未来理想的软件开发⽅式会不会是这样的呢？我不知道。会不会和 DCS 很像呢？我认为很有可能。这的确是我希望的开发⽅式，从⽽消除环境配置上的繁琐，依赖管理上的愁烦，CI/CD上的门槛，甚⾄还能极⼤减少沟通上的误解和争吵。 我猜，到时⾄少有⼀句话将会绝迹：IT WORKS ON MY MACHINE!</p>\n</div>",
      "title": "下⼀代软件开发模式（可能）是啥样的？",
      "author": {
        "loginname": "DravenGO962",
        "avatar_url": "https://avatars.githubusercontent.com/u/92977438?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 7,
      "country": "China"
    },
    {
      "id": "618c7688e6c91a1ac79169f1",
      "content": "<div class=\"markdown-text\"><p>传送门：<a href=\"https://curl.qcloud.com/AfDope6j\">https://curl.qcloud.com/AfDope6j</a>\n老用户，重新注册qq就可以白嫖了\n<img src=\"//static.cnodejs.org/FiAYLLSiKheMn8rVtHTjP07vJjus\" alt=\"1636595278(1).jpg\"></p>\n</div>",
      "title": "良心云，ECS 服务器 4核8g5m，1900元/3年",
      "author": {
        "loginname": "aliyun11",
        "avatar_url": "https://avatars.githubusercontent.com/u/93562479?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 8,
      "country": "Japan"
    },
    {
      "id": "618bc332e6c91a719291693e",
      "content": "<div class=\"markdown-text\"><p><img src=\"https://kalacloud.com/static/958ff4b31519eee028bfe8afb7cd0421/ef245/head.jpg\" alt=\"如何在 MySQL / MariaDB 中导入导出数据，导入导出数据库文件、Excel、CSV\"></p>\n<p>在日常的数据库维护工作中，经常需要对数据库进行导入导出操作，备份、分析、迁移数据都需要用到导入导出功能，在本教程中将详细讲解所有常见的 MySQL 和 MariaDB 中导入导出数据的方法（注意：MySQL 和 MariaDB 两个数据库操作命令一样，可以互换。）</p>\n<h2>本教程将详细讲解</h2>\n<h3>1. MySQL / MariaDB 数据库数据「导出」</h3>\n<p>（1）使用 <code>mysqldump</code>直接导出数据至 SQL 文件</p>\n<p>（2）阿里云 / 腾讯云远程服务器中的数据库直接导出到本地计算机</p>\n<p>（3）使用 <code>into outfile</code>命令导出数据至 CSV / Excel</p>\n<p>提示：如果你正在寻找数据迁移方案，请查看我写的的另一篇专门针对 <a href=\"https://kalacloud.com/blog/how-to-migrate-a-mysql-database-between-two-servers-aliyun-tencentyun/\">MySQL 数据迁移的教程</a>，教程中包含腾讯云、阿里云迁移实战。</p>\n<h3>2. MySQL / MariaDB 数据库数据「导入」</h3>\n<p>（1）将 SQL 文件导入至 MySQL / MariaDB 数据库中</p>\n<p>（2）使用 <code>source</code> 导入数据库 SQL 文件</p>\n<p>（3）将 CSV / Excel 文件 导入至 MySQL / MariaDB 数据库中</p>\n<h3>3. 使用「卡拉云」一键导入导出 MySQL / MariaDB 数据</h3>\n<p>如何使用卡拉云，5分钟搭建一套适应自己工作流的一键导入导出数据库系统。卡拉云无需部署，即插即用，可根据需求灵活调配，适用于后端工程师快速搭建企业内部系统、数据产品经理查看分析数据，数据分析师根据需求快速搭建数据共享平台分享给组内同学协同查看等应用场景。点这里看详情。</p>\n<h3>4. 先决条件</h3>\n<p>跟随本教程学习如何导入导出 MySQL 或 MariaDB 数据库，首先要有</p>\n<ul>\n<li>一台 Linux 服务器，本文以 Ubuntu 为例</li>\n<li>已安装 MySQL 或 MariaDB server （还未安装，安装教程请看这篇《<a href=\"https://kalacloud.com/blog/how-to-install-linux-apache-mysql-php-lamp-stack/\">MySQL 安装教程</a>》）</li>\n<li>MySQL 或 MariaDB Server 中有数据库（用于导出）</li>\n<li>教程使用 MacOS 演示本地计算机操作，此操作同时适用于 Windows 及 Linux</li>\n</ul>\n<h2><a href=\"https://kalacloud.com/blog/how-to-import-and-export-databases-excel-csv-in-mysql-or-mariadb-from-terminal/#%E4%B8%80-%E5%AF%BC%E5%87%BA-mysql-%E6%88%96-mariadb-%E6%95%B0%E6%8D%AE%E5%BA%93\"></a>一. 导出 MySQL 或 MariaDB 数据库</h2>\n<h3>1.如何使用 <code>mysqldump</code> 导出数据</h3>\n<p><code>mysqldump</code> 命令是数据库导出中使用最频繁对一个工具，它可将数据库中的数据备份成已 *.sql 结尾的文本文件，表结构和数据都会存储在其中。</p>\n<p><code>mysqldump</code> 命令的原理也很简单，它先把需要备份的表结构查询出来，然后生成一个 <code>CREATE TABLE 'table'</code> 语句，最后将表中所有记录转化成一条<code>INSERT</code>语句。</p>\n<p>可以把它理解为一个批量导出导入脚本。数据导入时，按照规范语句导入数据，大幅减少奇怪的未知错误出现。</p>\n<p><code>mysqldump</code> 的基本命令：</p>\n<pre class=\"prettyprint\"><code>$ mysqldump -u username -p database_name &gt; data-dump.sql\n</code></pre><ul>\n<li><code>username</code> 是数据库的登录名</li>\n<li><code>database_name</code> 是需要导出的数据库名称</li>\n<li><code>data-dump.sql</code> 是文件输出目录的文件</li>\n</ul>\n<p><strong>导出实战 - 从阿里云服务器中的 MySQL 数据库导出数据</strong></p>\n<pre class=\"prettyprint\"><code>$ mysqldump -u kalacloud -p kalacloud_database &gt; &#x2F;tmp&#x2F;kalacloud-data-export.sql\n</code></pre><p><img src=\"https://kalacloud.com/static/ccb5a47b7e118995b20cada7bc2149cf/11864/01-mysqldump.png\" alt=\"使用 mysqldump 导出数据\"></p>\n<ul>\n<li><code>kalacloud</code> ：数据库账号</li>\n<li><code>kalacloud_database</code> ：数据库名</li>\n<li><code>/tmp/kalacloud-data-export.sql</code> ：数据库导出的文件及存放目录</li>\n</ul>\n<p>输入数据库 <code>kalacloud</code> 账号的密码执行命令，如果执行过程中，没有任何错误，那么命令行不会有任何输出。</p>\n<p>我们可以 cd 到 tmp 目录查看结果。上图可以看到，tmp 目录下已经生成 <code>kalacloud-data-export.sql</code> 的导出文件。</p>\n<p>我们在用<code>head -n 5 kalacloud-data-export.sql</code>命令检查一下。你会看到类似下图的内容。</p>\n<p><img src=\"https://kalacloud.com/static/468a4459e57371bdb42e9976527bc95b/62da8/02-kalacloud-data-export.png\" alt=\"检查 mysqldump 导出文件是否有错误\"></p>\n<p>至此，我们已经将指定数据库导出到 *.sql 文件中了，后文我们讲解如何将这些数据导入到数据库。</p>\n<p><strong>进阶提示</strong>：我们可以使用 <code>scp</code> 命令，将导出文件下载至本地计算机。</p>\n<p>在本地计算机的命令行终端里，输入：</p>\n<pre class=\"prettyprint\"><code>scp root@192.168.180.134:&#x2F;tmp&#x2F;kalacloud-data-export.sql &#x2F;Users&#x2F;kalacloud&#x2F;Downloads\n</code></pre><p><code>root</code> 远程计算机的登录账号</p>\n<p><code>192.168.180.134</code> 为远程计算机的 IP 地址</p>\n<p><code>/tmp/kalacloud-data-export.sql</code> 为需要下载到本地的数据库文件在远程计算机上的存储位置</p>\n<p><code>/Users/kalacloud/Downloads</code> 为本地计算机的存储位置，远程文件将下载到这个目录中</p>\n<p><img src=\"https://kalacloud.com/static/6f0c7e812cb270b989d8ea684681745c/eb1d2/12-scp.png\" alt=\"使用 scp 下载文件到本地\"></p>\n<p>使用 <code>scp</code> 将导出的 SQL 文件下载到本地再进行后续处理。当然我们也可以一步导出至本地计算机，下面我们继续讲解进阶导出方法。</p>\n<p>扩展阅读：《<a href=\"https://kalacloud.com/blog/how-to-allow-remote-access-to-mysql/\">如何远程连接 MySQL 数据库，阿里云腾讯云外网连接教程</a>》</p>\n<h3>2.进阶：将阿里云 / 腾讯云远程服务器中的数据库导出到本地计算机</h3>\n<p>前文我们讲了如何在远程服务器上操作导出数据库，导出后保存在远程服务器中。有时我们需要把数据导出给产品或运营进行数据分析，又或者我们使用的云服务是独立 MySQL 数据库，这时，你需要直接把数据导出到本地计算机中。</p>\n<pre class=\"prettyprint\"><code>$ mysqldump -h remote_IP_address  -u username -p -P3306 --default-character-set=utf8 --set-gtid-purged=OFF database_name &gt;&#x2F;Users&#x2F;kalacloud&#x2F;Desktop&#x2F;data-dump.sql\n</code></pre><ul>\n<li><code>remote_IP_address</code> :远程服务器的 IP</li>\n<li><code>username</code> ：拥有远程登录权限的 MySQL 账号</li>\n<li><code>3306</code>：远程登录的数据库端口，默认是 3306 ，如果不是可根据情况替换</li>\n<li><code>default-character-set=utf8</code> ：导出时指定字符集</li>\n<li><code>set-gtid-purged=OFF</code> ：全局事务 ID (GTID) 来强化数据库的主备一致性，故障恢复，以及容错能力。开启这个功能导入导出时，可能会出错，故关闭。</li>\n<li><code>database_name</code> ：需要导出的数据库名称</li>\n<li><code>/Users/kalacloud/Desktop/data-dump.sql</code> ：本地计算机保存路径及保存文件名</li>\n</ul>\n<p><strong>提示：</strong><code>mysqldump</code>常见报错：mysqldump: Couldn’t execute 'SELECT COLUMN_NAME, JSON_EXTRACT(HISTOGRAM, ‘$.“number-of-buckets-specified”’)</p>\n<p>可在命令中添加 <code>column-statistics=0</code> 参数。因 MySQL 数据库早期版本 <code>information_schema</code> 数据库中没有名为 <code>COLUMN_STATISTICS</code> 的数据表，新版 <code>mysqldump</code> 默认启用，我们可以通过此命令禁用它。</p>\n<p><strong>导出实战 - 将阿里云服务器中的数据库直接导出到本地计算机</strong></p>\n<pre class=\"prettyprint\"><code>$ mysqldump -h123.57.56.228  -ukalacloud-remote -p -P3306 --default-character-set=utf8 --set-gtid-purged=OFF --column-statistics=0 kalacloud_database &gt;&#x2F;Users&#x2F;kalacloud&#x2F;Desktop&#x2F;kalacloud-data-export.sql\n</code></pre><ul>\n<li><code>123.57.56.228</code>： 远程数据库 ip 地址</li>\n<li><code>kalacloud-remote</code>：拥有远程访问权限的数据库账号。</li>\n<li><code>-P 3306</code>：数据库访问端口，可根据自己情况修改。</li>\n<li><code>/Users/kalacloud/Desktop/kalacloud-data-export.sql</code> ：本地计算机保存路径及保存文件名</li>\n</ul>\n<p><img src=\"https://kalacloud.com/static/aa178c898cfbd38cd0177ca1a9800710/a878e/03-aliyun-kalacloud-data-export.png\" alt=\"导出数据至本地计算机\"></p>\n<p>执行命令后，命令行并没有任何信息输出，但我们已经可以在桌面上看到导出后生成的文件了。</p>\n<p><img src=\"https://kalacloud.com/static/dc743a333efd67df0f44f531ec237a06/2b013/04-desktop.jpg\" alt=\"在本地计算机查看服务器导出的文件\"></p>\n<p>已经导出到本地桌面的远程端数据库</p>\n<p>当然，<code>mysqldump</code> 也可以分表备份，比较常见的场景有</p>\n<pre class=\"prettyprint\"><code># 备份单个库\nmysqldump -uroot -p -R -E --single-transactio --databases [database_one] &gt; database_one.sql\n\n# 备份部分表\nmysqldump -uroot -p --single-transaction [database_one] [table_one] [table_two] &gt; database_table12.sql\n\n# 排除某些表\nmysqldump -uroot -p [database_one] --ignore-table=[database_one.table_one] --ignore-table=[database_one.table_two] &gt; database_one.sql\n\n# 只备份结构\nmysqldump -uroot -p [database_one] --no-data &gt; [database_one.defs].sql\n\n# 只备份数据\nmysqldump -uroot -p [database_one] --no-create-info &gt; [database_one.data].sql\n</code></pre><p>扩展阅读：有关数据库在两台服务器之间迁移的问题可看我写的《<a href=\"https://kalacloud.com/blog/how-to-migrate-a-mysql-database-between-two-servers-aliyun-tencentyun/\">如何迁移 MySQL 数据库，阿里云、腾讯云迁移案例</a>》</p>\n<h3>3.使用 <code>into outfile</code> 命令导出 MySQL / MariaDB 数据至 CSV / Excel</h3>\n<p>有时我们需要将数据导出给运营或产品进行数据分析，这时导出 CSV 文件会更加方便使用。</p>\n<pre class=\"prettyprint\"><code>mysql&gt; select * from users into outfile &#x27;&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;users.csv&#x27; FIELDS TERMINATED BY &#x27;,&#x27;;\n</code></pre><p><code>FIELDS TERMINATED BY ','</code> 数据以 , 进行分隔。</p>\n<p>首先我们登录 MySQL shell，选择需要导出的数据库<code>use kalacloud_database;</code> 然后执行导出命令。</p>\n<p><img src=\"https://kalacloud.com/static/2cbee0a902e4c829cb7f1d98aa750542/b8471/05-use-kalacloud-database.png\" alt=\"使用 into outfile 导出数据\"></p>\n<p>导出后会显示成功提示，<code>CD</code> 到导出目录可看到 CSV 文件已导出。</p>\n<p>提示：<code>into outfile</code> 常见报错</p>\n<pre class=\"prettyprint\"><code>ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement\n</code></pre><p>这是因为你的 MySQL 配置了<code>--secure-file-priv</code> 限制了导出文件的存放位置。</p>\n<p>你可以使用以下命令来查看具体配置信息</p>\n<pre class=\"prettyprint\"><code>show global variables like &#x27;%secure_file_priv%&#x27;;\n</code></pre><p><img src=\"https://kalacloud.com/static/b122081289d2af49c9adaa964479b553/511f0/06-secure-file-priv.png\" alt=\"show global variables like '%secure_file_priv%'\"></p>\n<p><code>secure_file_priv</code> 为 NULL 时，表示不允许导入或导出。 <code>secure_file_priv</code> 为路径时（/var/lib/mysql-files/ ）时，表示只允许在路径目录中执行。 <code>secure_file_priv</code> 没有值时，表示可在任意目录的导入导出。</p>\n<p>你可以打开 my.cnf 或 my.ini，添加以下语句，重启 MySQL server 即可</p>\n<pre class=\"prettyprint\"><code>secure_file_priv=&#x27;&#x27;\n</code></pre><p>扩展阅读：有关把 MySQL 查询出来的结果保存到文件可看我写的这篇《<a href=\"https://kalacloud.com/blog/how-to-save-mysql-mariadb-query-output-to-a-file/\">如何在 MySQL 中保存查询结果到文件</a>》教程。</p>\n<h2>二. MySQL 或 MariaDB 数据库导入数据</h2>\n<p>接着我们讲解如何将 *.sql 导入到数据库中。我们先建一个新数据库用作演示。</p>\n<p>我们以 root 或有足够权限的账号登录 MySQL：</p>\n<pre class=\"prettyprint\"><code>$ mysql -u root -p\n</code></pre><p>输入登录密码后，进入 MySQL shell 状态。接着我们创建一个新数据库，在这个例子中，我们用 <code>kalacloud_new_database</code> 作为新数据库名称。</p>\n<pre class=\"prettyprint\"><code>mysql&gt; CREATE DATABASE kalacloud_new_database；\n</code></pre><p>执行命令后返回内容</p>\n<pre class=\"prettyprint\"><code>Query OK, 1 row affected (0.00 sec)\n</code></pre><p>用于演示的新数据库创建完成，我们使用 <code>CTRL+D</code> 退出 MySQL shell</p>\n<h3>1.直接使用 <code>mysql</code> 导入 SQL 文件</h3>\n<p>在命令行中我们导入上文导出的 <code>/tmp/kalacloud-data-export.sql</code> 文件（注意：以下命令在<strong>命令行中执行</strong>，不是在 mysql&gt; 状态下执行）</p>\n<pre class=\"prettyprint\"><code>mysql -u root -p kalacloud_new_database &lt; &#x2F;tmp&#x2F;kalacloud-data-export.sql\n</code></pre><ul>\n<li><code>root</code> ：你可以登录数据库的用户名。</li>\n<li><code>kalacloud_new_database</code> ：刚刚新建的空数据库，这条命令会把数据导入到这其中。</li>\n<li><code>/tmp/kalacloud-data-export.sql</code> ：是上文我们从数据库导出的 sql 文件，这里我们把它再导入到新数据库中。</li>\n</ul>\n<p>如果运行成功，命令行不会有任何提示。如果运行失败，命令行会提示失败原因。要检测是否导入成功，我们可以登录到 MySQL 查看并检查数据库中的数据。</p>\n<p><img src=\"https://kalacloud.com/static/e25b61e1a7bd0c11d252beb51772dad5/79166/07-select.png\" alt=\"打开数据库中的表检查导入结果\"></p>\n<p>登录 MySQL server ，使用 <code>USE kalacloud_new_database;</code> 选择刚刚我们导入数据的新建数据库，然后使用<code>SHOW TABLES;</code> 查看数据库中包含的表，最后用<code>SELECT * FROM users;</code>打开表查看内容。</p>\n<p>扩展阅读：《<a href=\"https://kalacloud.com/blog/how-to-edit-mysql-configuration-file-my-cnf-ini/\">MySQL 配置文件逐行解析</a>》教程</p>\n<h3>2.使用 <code>source</code> 导入 MySQL / MariaDB 数据库 SQL 文件</h3>\n<p>进入 MySQL shell 状态，我们还是导入本教程前文导出的 <code>/tmp/kalacloud-data-export.sql</code> 文件，到新数据库中。</p>\n<pre class=\"prettyprint\"><code>mysql&gt; USE kalacloud_new_database;\n</code></pre><p>首先选择需要导入的数据库<code>kalacloud_new_database</code>，返回结果。</p>\n<pre class=\"prettyprint\"><code>Database changed\n</code></pre><p>然后使用 source</p>\n<pre class=\"prettyprint\"><code>mysql&gt; source &#x2F;tmp&#x2F;kalacloud_new_database.sql;\n</code></pre><p><img src=\"https://kalacloud.com/static/47c27f60effa0d35d40c369e5ac30c67/d7ceb/10-source.png\" alt=\"使用 source 导入数据\"></p>\n<p>执行 <code>source</code> 命令后，MySQL 开始执行导入，接着我们使用 <code>SHOW TABLES</code> 和 <code>select</code> 来查看 SQL 文件是否导入正常。</p>\n<p><img src=\"https://kalacloud.com/static/fbdb9f9d4addc37d41e236771b206364/79166/11-source-show-table.png\" alt=\"检查 source 命令是否导入成功\"></p>\n<p>上图可以看到，数据已经导入成功。</p>\n<p>特别提示：<code>source</code> 和 <code>mysql &lt;</code> 两种导入方式的区别</p>\n<ul>\n<li><strong>命令执行环境不同：</strong><code>source</code> 在 MySQL sell 里执行，<code>mysql &lt;</code> 在终端命令行中执行</li>\n<li><strong>返回结果的不同：</strong><code>source</code> 会连续返回每一行导入结果，如果量大可能会影响速度，<code>mysql &lt;</code> 全部完成后返回结果。</li>\n<li><strong>报错是否停止执行：</strong><code>source</code> 遇到报错不会终止执行，<code>mysql &lt;</code> 遇到报错会终止执行。</li>\n</ul>\n<p>扩展阅读：《<a href=\"https://kalacloud.com/blog/how-to-manage-and-use-mysql-database-triggers/\">MySQL 触发器六种情况一次讲透，应用实战案例</a>》</p>\n<h3>3.MySQL / MariaDB 数据库中导入 CSV 文件</h3>\n<p>除了直接导入 sql 类文件外，有时候我们还会碰到需要导入 CSV 文件。导入 CSV 文件的步骤与直接导入 sql 有很大的不同，接着我们来讲解如何导入 CSV 文件。</p>\n<p>我们先进入 MySQL Shell：</p>\n<pre class=\"prettyprint\"><code>$ mysql -uroot -p\n</code></pre><p>然后新建一个空数据库：</p>\n<pre class=\"prettyprint\"><code>mysql&gt; CREATE DATABASE kalacloud_new_database;\n</code></pre><p>与导入 *.sql 不同，导入 CSV 文件需要先创建「表」，我们需要根据 CSV 文件中包含的列，使用<code>CREATE TABLE</code> 创建表。</p>\n<pre class=\"prettyprint\"><code>CREATE TABLE &#96;users&#96; (\n  &#96;id&#96; VARCHAR(255) NULL,\n  &#96;name&#96; VARCHAR(255) NULL,\n  &#96;phone&#96; VARCHAR(255) NULL,\n  &#96;states&#96; VARCHAR(255) NULL,\n  &#96;file_size&#96; VARCHAR(255) NULL,\n  &#96;sale&#96; VARCHAR(255) NULL,\n  &#96;copyright&#96; VARCHAR(255) NULL,\n  &#96;homepage&#96; VARCHAR(255),\n  &#96;complaint&#96; VARCHAR(255) NULL,\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n</code></pre><p>建议所有字段都设为接纳 <code>NULL</code> 值，也暂时不要设置主键。因为我们并不知道即将导入的 CSV 文件中的数据是否完整和规范。</p>\n<p>建议即便是数字，也先使用<code>VARCHAR</code>字段，以防止文件中的数据格式不正确导致的奇怪错误。</p>\n<p>我们可以在数据导入后，在对数据库进行验证、清理和修正。</p>\n<p><img src=\"https://kalacloud.com/static/d3246777ab4a78e4be20e807f751a6cd/b5a09/08-create-excel.png\" alt=\"使用 excel 导入数据.png\"></p>\n<p>上文中我们从 <code>kalacloud_database</code> 中导出了表 <code>users</code> 存放到了<code>/var/lib/mysql-files/users.csv</code> 里，下面我们使用 <code>LOAD DATA INFILE SQL</code> 语句把这个 CSV 文件导入新建的表中。</p>\n<pre class=\"prettyprint\"><code>load data infile &#x27;&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;users.csv&#x27;\ninto table users\nFIELDS TERMINATED BY &#x27;,&#x27;\nENCLOSED BY &#x27;&quot;&#x27;;\n</code></pre><p>字段使用逗号分隔，字符串用双引号括起来。如果你的 CSV 第一行是标题而非数据，那么还可以添加 <code>IGNORE 1 ROWS;</code> 导入时，忽略第一行。</p>\n<p><img src=\"https://kalacloud.com/static/530d230f067b4dff0257f8d853616a75/a8979/09-users-csv.png\" alt=\"使用 csv 导入数据\"></p>\n<p>导入成功后，使用 <code>select * from users;</code> 初步检查表中数据是否正确。</p>\n<p>扩展阅读：我们也可以使用 Workbench 这种免费的 MySQL 图形管理工具来操作，了解更多可看我写的这篇《<a href=\"https://kalacloud.com/blog/mysql-workbench-tutorial/\">MySQL Workbench 中文指南</a>》教程。</p>\n<h2>三. 使用「卡拉云」一键导入导出数据</h2>\n<p>除了 MySQL / MariaDB 数据迁移这类适合使用终端命令操作外，大多数对 MySQL / MariaDB 数据导入导出操作还是为了数据展示、分析、协同共享等产品和运营层面的应用场景。</p>\n<p>比如后端工程师接到产品需求，协助导出某类数据等场景，如果这类需求频繁出现，推荐使用卡拉云，卡拉云是新一代低代码开发工具，免安装部署，可一键接入包括 MySQL 在内的常见数据库及 API。</p>\n<p>不仅可以像命令行一样灵活，还可根据自己的工作流，定制开发。无需繁琐的前端开发，只需要简单拖拽，即可快速搭建企业内部工具。<strong>数月的开发工作量，使用卡拉云后可缩减至数天，欢迎试用我们开发的<a href=\"https://kalacloud.com/?utm_medium=register\">卡拉云</a>。</strong></p>\n<p><img src=\"https://kalacloud.com/static/f98d898ab39be0bac391c36484bd77c8/71c1d/15-sql-all.png\" alt=\"卡拉云可快速接入常见的数据库及API\"></p>\n<p>卡拉云可快速接入的常见数据库及 API</p>\n<p>卡拉云可根据公司工作流需求，轻松搭建数据看板，并且可分享给组内的小伙伴共享数据</p>\n<p><img src=\"https://kalacloud.com/5400a60956e16d655e0297c5d6e5a8d2/14-kalacloud-gif.gif\" alt=\"卡拉云仅需拖拽即可快速生成前端组件\"></p>\n<p>仅需拖拽一键生成前端代码，简单一行代码即可映射数据到指定组件中。</p>\n<p><img src=\"https://kalacloud.com/static/f5669b9993d738a2c3b4d4a72419ae85/d3e24/13-kalacloud-list.jpg\" alt=\"卡拉云可轻松导出各类数据格式\"></p>\n<p>卡拉云可直接添加导出按钮，导出适用于各类分析软件的数据格式，方便快捷。<a href=\"https://kalacloud.com/?utm_medium=register\">立即开通卡拉云</a>，导入导出你的数据</p>\n<h2>四.总结</h2>\n<p>在本教程中，我们讲解了如何导入导出数据库至 SQL 文件和 CSV 文件。mysqldump 还有很多使用变化，你可以参考 mysqldump <a href=\"https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html\">官方文档</a>了解更多。更多数据库相关教程可访问 <a href=\"https://kalacloud.com/\">卡拉云</a> 查看。</p>\n</div>",
      "title": "如何在 MySQL / MariaDB 中导入导出数据，导入导出数据库文件、Excel、CSV",
      "author": {
        "loginname": "JiangTianZheng",
        "avatar_url": "https://avatars.githubusercontent.com/u/17161752?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 9,
      "country": "China"
    },
    {
      "id": "618ba9eee6c91a07919168f5",
      "content": "<div class=\"markdown-text\"><p>???</p>\n</div>",
      "title": "2132132132w14",
      "author": {
        "loginname": "wangyang009i8u87u",
        "avatar_url": "https://avatars.githubusercontent.com/u/87956618?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 10,
      "country": "USA"
    },
    {
      "id": "618b658e1affc1a8b5492d90",
      "content": "<div class=\"markdown-text\"><p>目前我正在负责一个前端项目，项目组需与产品团队一同协作交付项目，但整个验收环节让我非常苦恼。\n现有流程是：</p>\n<ol>\n<li>我在本地开发完毕；2. 推送代码到Github仓库；3. 要求团队审阅代码并合并到测试分支；4. 走CI与CD流程、部署代码至测试服务；5. 交付产品部门验收。\n若遇到需要修改的地方则需要再次重复这一流程，整个流程约需要耗费15分钟。这样的工作模式在不忙的时候没有问题，但在准备上线期间暴露出了明显的问题：</li>\n<li>若遇上产品团队反复要求修改会浪费许多时间，拖累团队上线进度；</li>\n<li>代码审阅容易形式化，审阅者往往直接同意合并代码。\n面对此问题，我曾要求产品团队将修改意见汇总成一个版本提交给研发团队降低发布次数，但这一方案只能降低发布次数，但无法降低发布流程耗时这一问题。这时候我就在思考有没有一款可供团队协作的在线开发环境，可以在开发完毕后在线预览效果，免去繁琐的部署步骤，提升跨部门的合作效率。</li>\n</ol>\n<p>有了想法之后我开始了搜索与调研，发现了<a href=\"https://www.teamcode.com/\"></a>TeamCode的<a href=\"https://docs.teamcode.com/dcs/what-is-dcs\"></a>DCS这款产品，它可以通过一个Git仓库地址在云上创建一个可以运行项目的环境，用户可以通过IDE访问云端环境开发项目。\n<img src=\"//static.cnodejs.org/FlUfmUOpQocUYSBP-wVgjkh9Dw0f\" alt=\"产品2稿-1.png\">\n我发现这完美契合我的需求，修改完毕后能够及时在线上预览效果供产品团队验收。\n<img src=\"//static.cnodejs.org/FoZ7ZINnprCzNvqJvTpb9bCyXhQy\" alt=\"产品2稿-2.png\">\n我可以在环境中编写代码，\n<img src=\"//static.cnodejs.org/Fp73MvUqy4ckgcTB_K0Ig8tpZHDY\" alt=\"产品2稿-3.png\">\n编写完毕后立即运行项目。\n<img src=\"//static.cnodejs.org/Fr4xDXFtx_pH0kpCVeb1J0wJA7mJ\" alt=\"产品2稿-4.png\">\n我将项目的地址分享给产品团队之后，产品团队即可访问此地址查看效果：\n<img src=\"//static.cnodejs.org/Fsvvgj5Q4lYKvBOKKa2UJ5-pKeT3\" alt=\"产品2稿-5.png\">\n<img src=\"//static.cnodejs.org/FgeI1mIcN1k_dv2csS2EDnakmrT1\" alt=\"产品2稿-6.png\">\n体验完产品我认为它能满足团队协作的需求便在公司内部开始了试用，但在实际开发过程中也遇到了产品的不足之处，如不支持连接内网Git仓库，导致我必须把代码暂时推送到我的私有GitHub仓库再基于此仓库创建项目。因此我建议产品可以支持此功能，为团队开发提供便利。综上，一旦解决了产品限制导致的问题，使用这个产品能显著提升团队协作效率，可以将整个交付流程从15分钟降低到3分钟内。</p>\n</div>",
      "title": "工程师进阶历程：如何快速提升项目交付和验收效率",
      "author": {
        "loginname": "TrystanCocolatte",
        "avatar_url": "https://avatars.githubusercontent.com/u/92838042?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 11,
      "country": "USA"
    },
    {
      "id": "618b62f71affc16eb7492d7d",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://www.bestsiteblog.com/businessdirectory\">top business directory</a>\non the thought of his buddy zhuge qing, zhang chulan and feng baobao came to resolve the case with the help of “anywhere” business enterprise. how does zhang chulan display his competencies to assist the king trap the black hand backstage? what wonderful overall performance will zhuge qing, wang ye and others have? who’re the people who covet the “8 wonders”? “under one guy-becoming a member of the world” may be introducedsoon!</p>\n</div>",
      "title": "The kinger-bestsiteblog",
      "author": {
        "loginname": "redirectto1",
        "avatar_url": "https://avatars.githubusercontent.com/u/94027376?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 12,
      "country": "Japan"
    },
    {
      "id": "618a33391affc167ba492b4c",
      "content": "<div class=\"markdown-text\"><p>‘use strict’;</p>\n<p>var mqtt = require(‘mqtt’),\nlevelStore = require(‘mqtt-level-store’);\nmanager = levelStore(‘path/to/db’);</p>\n<p>var client = mqtt.connect({\nport: 8883,\nincomingStore: manager.incoming,\noutgoingStore: manager.outgoing\n});\n我想问一下这段代码中的 manager.incoming, manager.incoming,是不是mqtt-level-store包的属性，如果 是的话，能不能发个mqtt-level-store包的属性连接我， 我想学习一下，我的电脑科学上网不行，用不了谷歌。</p>\n</div>",
      "title": "关于mqtt-level-store包属性的问题",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 13,
      "country": "Japan"
    },
    {
      "id": "617f605e0af06307ecc863f1",
      "content": "<div class=\"markdown-text\"><p>我想问一下下面这两个属性（incoming和outgoing）是那个包里的属性？\n<img src=\"//static.cnodejs.org/FiIr3l2zph2jNg6zzaUZRW4zEjwz\" alt=\"图片.png\"></p>\n</div>",
      "title": "我想问一下下面这两个属性是那个包里的属性？",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 14,
      "country": "Japan"
    },
    {
      "id": "615f5705fe0c518ffeaeced3",
      "content": "<div class=\"markdown-text\"><p>我用 <a href=\"http://acme.sh\">acme.sh</a> 生成了 Let’s Encrypt 证书，<a href=\"http://acme.sh\">acme.sh</a> 提供了四个文件：</p>\n<ul>\n<li>example.com.key</li>\n<li>example.com.cer</li>\n<li>fullchain.cer</li>\n<li>ca.cer</li>\n</ul>\n<p>一开始我的代码是这么写的：</p>\n<pre class=\"prettyprint language-js\"><code>https.createServer({\n  key: readFileSync(&#x27;example.com.key&#x27;),\n  cert: readFileSync(&#x27;example.com.cer&#x27;),\n})\n</code></pre><p>最近总有人反馈说浏览器提示证书不正确，但是我这边一切正常。于是我找了个在线的 SSL 检测工具，检测结果说证书链不完整，可能会导致第一次访问网站时被浏览器提示证书不正确。经过了一段时间的搜索，我把上面代码中的 <code>cert: example.com.cer</code> 改成了 <code>cert: fullchain.cer</code>，再检测时结果直接提示证书不可信，但我在 <a href=\"http://ssllabs.com\">ssllabs.com</a> 里检测结果是 A。</p>\n<p>经过反复测试，无论使用哪个，在我这里都是正常的（测试前都有清除操作系统的 SSL 缓存）。所以我有一些疑问：</p>\n<ul>\n<li>cert 应该用 example.com.cer 还是 fullchain.cer，为什么？我目前知道 fullchain.cer = example.com.cer + ca.cer，也就是说用了 fullchain.cer，证书链就完整了吗？</li>\n<li>ca 需要指定吗？我尝试加过 <code>ca: ca.cer</code>，在我这里测试也是正常的，那是加上比较好还是不加比较好？如果加上的话是要指定为 ca.cer 文件吗？</li>\n<li>我发现虽然在浏览器里测试正常，但是在 Ubuntu 16.04 里用 curl 访问的时候会报 curl: (60) server certificate verification failed. 的错误，用 <a href=\"http://cnodejs.org\">cnodejs.org</a> 测试了也有这个错误，那么这个错误可以安全的忽略吗？</li>\n</ul>\n<p>疑问太多了，归根结底还是对 SSL 证书不太了解，网上查了一些资料虽然有 fullchain、cert 等关键字，但同时大部分资料介绍的似乎都是 pem 格式，所以我不确定跟 <a href=\"http://acme.sh\">acme.sh</a> 里的这四个文件是否对应的上。希望能有大神答疑解惑</p>\n</div>",
      "title": "怎样正确的将 acme.sh 生成的 Let's Encrypt 证书部署到 Node.js 服务里？",
      "author": {
        "loginname": "lmk123",
        "avatar_url": "https://avatars.githubusercontent.com/u/5035625?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 15,
      "country": "Eurozone"
    },
    {
      "id": "6183e6a71affc179d6491132",
      "content": "<div class=\"markdown-text\"><p>之前读取request的data数据，再引入querystring分割。现在不让分割了，怎样提取呢？</p>\n</div>",
      "title": "16上说querystring是旧版了，获取post的请求体的data后怎样提取呢，用split吗？",
      "author": {
        "loginname": "xiaozheng11",
        "avatar_url": "https://avatars.githubusercontent.com/u/93719550?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 16,
      "country": "Japan"
    },
    {
      "id": "61892ea01affc14a89492747",
      "content": "<div class=\"markdown-text\"><p>一直用vs code编代码，node-snippets感觉不行啊，require都不提示，在每个包中安装<a href=\"/user/types\">@types</a>/node，倒可以提示，但太麻烦了。用什么插件好呢？</p>\n</div>",
      "title": "vscode用什么提示插件？node-snippets都不提示require()这样的函数，",
      "author": {
        "loginname": "xiaozheng11",
        "avatar_url": "https://avatars.githubusercontent.com/u/93719550?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 17,
      "country": "Eurozone"
    },
    {
      "id": "6188dcc31affc157774925df",
      "content": "<div class=\"markdown-text\"><p>最近我团队在开发一个新项目，该项目需要用到网关。项目时间紧迫，我需要快速决定网关的技术选型，并尽快和团队分享Demo。为了提升效率，我找了技术大牛朋友推荐靠谱的开源网关项目，他推荐了一个，并且发来链接。我立即打开网站，在查阅了产品介绍和网友的评分后，初步判断该项目靠谱，随即开始尝试安装项目验证功能。</p>\n<p>根据产品文档，只需几个步骤就能启动一个案例，但没想到因为我平时喜欢探索各种新技术，导致我本地环境污染严重，在安装的第一步就遇到了无法启动etcd数据库的问题。我一边处理工作消息、一边清理环境，尝试解决安装问题。待我能够启动etcd数据库的时候，已经耗时1个多小时了！</p>\n<p>看着工作任务栏还有堆积的待完成文档，我非常希望有一个工具或者平台，能够替我解决安装难题，快速完成部署，尽快开始测试。这时我想到了工程师解决问题的思路：“你遇到的问题，可能前面已经有许多人遇到过了”。因此我开始了搜索，并求助了技术大牛朋友，在经过一系列尝试之后，发现了<a href=\"https://www.teamcode.com/\">分享一个能快速使用开源项目的工具</a>TeamCode的平台，它有一个名叫Tin的产品主打快速POC测试，让开源项目即开即用。\n虽然之前没听说过这个工具，但是看起来挺靠谱且能解决我的问题？秉持着工程师的探索精神，注册了账号后我开始了尝试。</p>\n<p>从应用界面来看，它目前支持三种创建方式：Git Repo, Docker Repo, Dockerfile.接着根据产品手册，创建应用，填写端口、变量、entry point等。整个过程只花了几分钟，网关应用就被创建完毕。</p>\n<p>我关掉日志界面看到下面有一个Endpoint模块，提供公开访问的URL。复制URL之后，出现了网关的管理界面。之后我又尝试build了其它几个开源项目，只有部分成功。但总体来说，这是一款不错的提升研发效能的工具，它免去了开源项目繁琐的安装流程，节约时间，让我们关注手上更重要的事情。对于以后来说，TIN开发者可以从提升用户体验出发，增加产品对更多开源项目的支持，我们在技术选型的时候可以更便捷地去体验项目，高效地做出决定。</p>\n</div>",
      "title": "一个能快速使用开源项目的小工具",
      "author": {
        "loginname": "TrystanCocolatte",
        "avatar_url": "https://avatars.githubusercontent.com/u/92838042?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 18,
      "country": "China"
    },
    {
      "id": "6188d1981affc14eb7492541",
      "content": "<div class=\"markdown-text\"><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98e9b6f8d8bd47cca055f29569bdee16~tplv-k3u1fbpfcp-watermark.image?\" alt=\"图怪兽_ebbb7b2d8c2fb3d5e32ca5afa32e9489_48854.jpg\"></p>\n<blockquote>\n<p>前沿：哈喽，我是树酱。今天分享的水文是关于前端与后端之间battle的那些事，自从前后端分离之后，这场分家带来了不少沟通问题，甚至产生battle。我们先回顾下前后端battle的前世今生</p>\n</blockquote>\n<h3>1.远古时代 (web1.0 - MVC架构)</h3>\n<p>依稀记得刚大学毕业那会，电脑上安装的第一个IDE，不是Webstorm也不是VScode，而是IntelliJ IDEA。因为开发前端项目，需要跑完整的一个JAVA程序，各种maven配置，然后在后端编写的JSP文件基础上再进行前端开发，换句话说就是“二次开发”，现在想想当时编译慢的场景，历历在目。换句话说就是前端开发重度依赖环境</p>\n<blockquote>\n<p>阿乐同学：我记得我当时就只提供HTML代码，然后用Sublime做编辑器就好了，然后最后再整合到JSP中去</p>\n</blockquote>\n<p>这就是另外一种模式，前端负责输出demo Html，然后交给后端去套模版</p>\n<p>只是说完全交由后端去整合，出错率较高，遇到 Bug 解决起来也很麻烦，需要双方协同处理。换来的更多的沟通成本。因为前后端的职责很容易纠缠不清，耦合性太强，最后还可能导致battle。</p>\n<p>总结产生battle的点👇：</p>\n<ul>\n<li>1.前端开发重度依赖环境，导致每次修改文件编译时间过长，考验前端开发者的耐心</li>\n<li>2.当应用需要升级时，无法单独对前端、后端独立升级。而是对整个单体应用整体升级</li>\n<li>3.后端将前端预先开发好的html页面，嵌入到JSP文件后，实际样式效果偏差过大</li>\n</ul>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9329119a8ae643249a770c68274c1af1~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<h3>2.铁器时代 （web2.0 -MVVM架构）</h3>\n<blockquote>\n<p>前端MVVM架构的出现促进了前端开发与后端业务逻辑的分离，真正实现“分家”：分工协助、各司其职、拒绝捆绑。\n这时候就需要一个“沟通桥梁”：API ，再通过ajax调用实现前后端之间的协作沟通。两者也解耦了</p>\n</blockquote>\n<p>API消费者（前端）：通过接口文档了解接口信息，聚焦点：接受数据、处理数据、处理渲染逻辑</p>\n<p>API生产者（后端）：提供接口以及接口文档  聚焦点：提供数据、提供API文档</p>\n<p>开发流程也开始转变👇：</p>\n<ul>\n<li>后端编写和维护接口文档，在 API 变化时更新接口文档</li>\n<li>后端根据接口文档进行接口开发</li>\n<li>前端根据接口文档进行开发 + Mock平台</li>\n<li>开发完成后联调和提交测试</li>\n</ul>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3f80f60d5e242d3ae9254ba1a766765~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<blockquote>\n<p>啊乐同学：那前后端分离后，是后端同学先开发还是前端同学先开发？</p>\n</blockquote>\n<p>从上面的开发流程我们可以看出，分家之后，接口文档是最关键的沟通桥梁。根据重要先行原则，文档就成为了首要因素，建议接口文档先行，也就是 API-First，没有接口文档前端几乎无法开工。</p>\n<blockquote>\n<p>啊呆同学：对于前端同学接口联调用postman调试，mock用Yapi或者RAP2来生产假数据，有没有更好用的工具一步到位？</p>\n</blockquote>\n<p>以前我也是左手一个postman，右手一个yapi，中间码着code</p>\n<p>你可以试试 <a href=\"https://www.apifox.cn/\">Apifox</a></p>\n<p>官方介绍：<a href=\"https://www.apifox.cn/\">Apifox</a> 是 API 文档、API 调试、API Mock、API 自动化测试一体化协作平台，定位 <code>Postman + Swagger + Mock + JMeter</code></p>\n<p>前端同学可以用Apifox来解决<code>接口调试+数据Mock</code>的需求</p>\n<p>下面分享一个实战页面截图</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03891631dbf84a7a8311c05b8f4e3b20~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>但新的开发流程也暴露出新的battle点</p>\n<p>总结产生的battle点：</p>\n<ul>\n<li>\n<p>1.一个页面需要请求的接口太多，前端希望后端做接口聚合，减少请求次数，后端则认为接口是根据微服务划分职责的，无需耦合</p>\n</li>\n<li>\n<p>2.后端提供的接口发生变更，但接口文档却没有同步，或者后端提供接口缺失，前端无法正常mock等</p>\n</li>\n<li>\n<p>3.字段不统一：举个例子，手机号码的字段，有的返回 mobilePhone，有的返回 PhoneNumber，字段不统一导致沟通成本提升</p>\n</li>\n</ul>\n<h3>3.白银时代 （BFF时代）</h3>\n<blockquote>\n<p>随着微服务的盛行，后端数据接口被拆分独，假设现在前端需要一些数据，可能都依赖几个微服务，需要作数据聚合。而与此同时，作为离用户最近的前端，面对各种移动设备，每个客户端的数据类型要求不同，诸如移动端所需数据并不多，需要做数据拆解。</p>\n</blockquote>\n<p>会产生类似下面的battle场景👇：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbb5c53fe62b4d8cb866e6b84c02066f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>前端同学和后端同学都各有各的道理，有没有一种解决方案可以化解这种尴尬的场景，于是就有了BFF，BFF全称是Backends For Frontends(服务于前端的后端)</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9135727d434455b94d746be0a780e80~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>在BFF层下面是各种后端微服务，在BFF上层则是各种前端应用（多端应用），向下调用后端为服务，向上给客户端提供接口服务，后端为BFF层的前端提供的的 RPC 接口， BFF 层则直接调用服务端 RPC 接口拿到数据，按需加工数据，来完成整个BFF的闭环（以Node+GraphQL技术栈为主）</p>\n<p>BFF的出现确实解决了蛮多前端后的沟通成本，彼此也友善了很多，对话就演变成这样</p>\n<ul>\n<li>\n<p>后端：这些微服务都在这里了，你看着组合，有问题找我</p>\n</li>\n<li>\n<p>前端：行，我看着组合</p>\n</li>\n</ul>\n<p>对于BFF感兴趣的童鞋可以阅读树酱之前的 <a href=\"https://juejin.cn/post/6844904185427673095\">你学BFF和Serverless了吗?</a></p>\n</div>",
      "title": "前后端，相煎何太急...",
      "author": {
        "loginname": "littleTreeme",
        "avatar_url": "https://avatars.githubusercontent.com/u/62824719?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 19,
      "country": "Japan"
    },
    {
      "id": "6184f5571affc1d2f849174c",
      "content": "<div class=\"markdown-text\"><p>最近在做的项目中需要使用日历组件，大佬们给推荐一个基于Vue成熟的日历组件！！</p>\n</div>",
      "title": "求推荐基于Vue的日历组件",
      "author": {
        "loginname": "CodeofGame",
        "avatar_url": "https://avatars2.githubusercontent.com/u/21193477?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 20,
      "country": "Eurozone"
    },
    {
      "id": "610c83b8a5d29d98c92d4b45",
      "content": "<div class=\"markdown-text\"><h3>欢迎大家下载使用，并提出宝贵意见！</h3>\n<h3>下载地址： <a href=\"http://pdfcvt.com/\">pdfcvt.com</a></h3>\n<p><img src=\"//static.cnodejs.org/FnxhLVeaJs8bb6FcqjAVCZ0nzxx2\" alt=\"image.png\"></p>\n</div>",
      "title": "C#撸了个批量转换Word、Excel、PPT为PDF的软件 pdfcvt.com",
      "author": {
        "loginname": "pangguoming",
        "avatar_url": "https://avatars.githubusercontent.com/u/7269202?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 21,
      "country": "China"
    },
    {
      "id": "6186378d1affc10215491b3d",
      "content": "<div class=\"markdown-text\"><p>看文档，只是对str/buffer压缩</p>\n</div>",
      "title": "zlib能实现将很多html压缩一个zip文件吗?",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 22,
      "country": "China"
    },
    {
      "id": "604d97374655eadec221b5a1",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>本文主讲 Typescript 一些实用，但不太常见的技巧。每个技巧都有一个需求对应，不会太枯燥，按简单到复杂的顺序讲解，方便读者理解吸收。看完例子，你就知道为什么要使用这些骚操作，代码会提升一个境界。</p>\n</blockquote>\n<p><a href=\"https://markdowner.net/article/80348744310312960\">Typescript 高级语法进阶</a></p>\n</div>",
      "title": "Typescript 高级语法进阶",
      "author": {
        "loginname": "Q-Qplus1s",
        "avatar_url": "https://avatars.githubusercontent.com/u/50064165?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 23,
      "country": "USA"
    },
    {
      "id": "60b7991c248d04d0d74a9f86",
      "content": "<div class=\"markdown-text\"><p>原文 <a href=\"https://zhuanlan.zhihu.com/p/377282174\">https://zhuanlan.zhihu.com/p/377282174</a>\n本文章的目的纯为技术研究所分享，带你了解目前前端JS加密的原理</p>\n<p>一般做的好，有一定安全意识的网站都会对数据进行加密，得物APP也一样，对接口请求进行了加密处理。\n但是这种加密也就只能防得住君子，防不住高手，比如我，毕竟这种前端加密算法需要暴露到浏览器运行，就给了爆破的机会。\n我们看到下图，请求有一个 ​sign​ 参数，这个参数是动态生成的，这里已经就吓跑了很多想破解的程序员~~。其实还是很简单的。\n<img src=\"//static.cnodejs.org/Fm8hwAupibFQJVXr1aLuTR7ilJxe\" alt=\"image.png\">\n​sign​ 参数就是突破口，我们全局搜索这个参数（如下图）\n<img src=\"//static.cnodejs.org/FgW4BchhcOoOnLrFw70lGFP-FQsn\" alt=\"image.png\">\n一堆代码别头疼，这时候需要耐心的查找，很快我们就发现了蛛丝马迹（如下图），在 ​index.2c3016d3.js​这个文件中\n<img src=\"//static.cnodejs.org/Fntu0cAajto2BzFJ4RXar07nOM22\" alt=\"image.png\">\n很明显，这个地方就是给 ​sign​ 赋值的，双击进入到代码（如下图），没错,大概率是这的， ​params​ 是请求参数，对参数进行加密签名生成 ​sign​ 。\n<img src=\"//static.cnodejs.org/FvxE9oNmaygNPNDgFsiQEruy3wn4\" alt=\"image.png\">\n我们在这里打一个断点，然后开始调试,找到了如下函数，这里就是加密算法的核心入口啦！，尤其注意 ​19e7​ 这个函数。\n<img src=\"//static.cnodejs.org/FiEE0lbDfYktNJ0YX--5F1AsKoHl\" alt=\"image.png\">\n最后到这里，我们就找到了加密算法，剩下的就简单了，只要执行即可。\n<img src=\"//static.cnodejs.org/FmPDVFV4rIgoolVKTqG-5xYQ_e3f\" alt=\"image.png\">\n最后我们把代码还原回来，运行一下，和接口中的sign一致，就这样我们完成了加密算法的识别了。\n<img src=\"//static.cnodejs.org/FqA82ks5iqttanoGYsES6_L1eWGN\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FtOB4rtL2qL2WZb_Pll8WGgWwAgq\" alt=\"image.png\">\n还原的加密算法源码，我就不在这里公开啦，大家可以关注我~ <a href=\"https://zhuanlan.zhihu.com/p/377282174\">https://zhuanlan.zhihu.com/p/377282174</a></p>\n</div>",
      "title": "得物APP接口加密分析",
      "author": {
        "loginname": "lvgithub",
        "avatar_url": "https://avatars.githubusercontent.com/u/16065346?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 24,
      "country": "Eurozone"
    },
    {
      "id": "60e87897ba7460b597863693",
      "content": "<div class=\"markdown-text\"><p><strong>前言：越来越多同学在使用Node.js，大家也不同程度地理解Node.js是什么。比如Node.js是由V8、Libuv、JS组成的，Node.js底层是C\\C++，Node.js不是语言是运行时。本文通过实现一个类Node.js的JS运行时No.js，去理解Node.js的本质。No.js是我之前写的一个JS运行时，概念上是这么说，但是它算不上真正的运行时，它只是个demo，但是它让你看到如果你有兴趣，你也可以写个Node.js。</strong></p>\n<p>首先我们看看V8的基本用法。</p>\n<pre class=\"prettyprint language-cpp\"><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &quot;include&#x2F;libplatform&#x2F;libplatform.h&quot;\n#include &quot;include&#x2F;v8.h&quot;\n\nint main(int argc, char* argv[]) {\n  &#x2F;&#x2F; Initialize V8.\n  v8::V8::InitializeICUDefaultLocation(argv[0]);\n  v8::V8::InitializeExternalStartupData(argv[0]);\n  std::unique_ptr&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform();\n  v8::V8::InitializePlatform(platform.get());\n  v8::V8::Initialize();\n\n  v8::Isolate::CreateParams create_params;\n  create_params.array_buffer_allocator =\n      v8::ArrayBuffer::Allocator::NewDefaultAllocator();\n  &#x2F;&#x2F; 创建一个Isolate，表示一个隔离的实例\n  v8::Isolate* isolate = v8::Isolate::New(create_params);\n  {\n    v8::Isolate::Scope isolate_scope(isolate);\n    &#x2F;&#x2F; 定义一个HandleScope 管理下面的handle内存的分配和释放\n    v8::HandleScope handle_scope(isolate);\n    &#x2F;&#x2F; 创建一个上下文，js里访问的东西来自context\n    v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate);\n    v8::Context::Scope context_scope(context);\n\t&#x2F;&#x2F; 定义我们要执行的代码\n    v8::Local&lt;v8::String&gt; source = v8::String::NewFromUtf8(isolate, &quot;&#x27;Hello&#x27; + &#x27;, World!&#x27;&quot;,v8::NewStringType::kNormal).ToLocalChecked();\n\t&#x2F;&#x2F; 编译脚本\n    v8::Local&lt;v8::Script&gt; script = v8::Script::Compile(context, source).ToLocalChecked();\n\t&#x2F;&#x2F; 执行脚本\n    v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked();\n    &#x2F;&#x2F; 输出结果\n    v8::String::Utf8Value utf8(isolate, result);\n    printf(&quot;%s\\n&quot;, *utf8);\n  }\n\n  &#x2F;&#x2F; Dispose the isolate and tear down V8.\n  isolate-&gt;Dispose();\n  v8::V8::Dispose();\n  v8::V8::ShutdownPlatform();\n  delete create_params.array_buffer_allocator;\n  return 0;\n}\n\n</code></pre><p>我们看代码很多，但是大部分的根据V8文档就行，最核心的是context和脚本的定义，我们看到这里的context是V8提供的内容，然后执行的JS脚本也平平无奇。下面我们要做的事情就是拓展这个context，给他注入一下新功能，相应地，在JS里也就能访问V8内置变量之外的变量，我们看看怎么搞。</p>\n<pre class=\"prettyprint language-cpp\"><code>\t  &#x2F;&#x2F; 拿到一个全局变量，这个就是我们在js里对应的全局变量\n      Local&lt;Object&gt; global =  context-&gt;Global();\n      &#x2F;&#x2F; 定义一个字符串对象\n      Local&lt;Value&gt; key = String::NewFromUtf8(isolate, &quot;TCP&quot;,\n                          NewStringType::kNormal,\n                          strlen(&quot;TCP&quot;)).ToLocalChecked();\n      Local&lt;Value&gt; cbdata = String::NewFromUtf8(isolate, &quot;dummy&quot;,\n                          NewStringType::kNormal,\n                          strlen(&quot;dummy&quot;)).ToLocalChecked();\n      &#x2F;&#x2F; 定义一个函数                   \n      Local&lt;Function&gt; func = Function::New(context,\n                        &#x2F;&#x2F; 执行func时会调用Invoke，cbdata是入参\n                        Invoke,\n                        cbdata).ToLocalChecked();   \n      &#x2F;&#x2F; 把函数注册到全局变量，这样我们在js里就可以使用key该函数了                                    \n      Maybe&lt;bool&gt; ignore = global-&gt;Set(context, key, func);\n      &#x2F;&#x2F; 打开文件\n      int fd = open(argv[1], O_RDONLY);\n      struct stat info;\n      &#x2F;&#x2F; 取得文件信息\n      fstat(fd, &amp;info);\n      &#x2F;&#x2F; 分配内存保存文件内容\n      char *ptr = (char *)malloc(info.st_size + 1);\n      &#x2F;&#x2F; 读取文件搭配ptr，Mac os的read函数定义第二个参数是void *\n      read(fd, (void *)ptr, info.st_size);\n      &#x2F;&#x2F; 要执行的js代码\n      Local&lt;String&gt; source = String::NewFromUtf8(isolate, ptr,\n                          NewStringType::kNormal,\n                          info.st_size).ToLocalChecked();\n</code></pre><p>上面代码主要分为几个部分。\n1 从context中获取全局变量。\n2 定义一个新功能，并注入到全局变量，这样我们就可以在JS里访问了。\n3 打开一个文件并且读取进来，交给V8编译执行。\n下面我们看重点，即我们自定义的功能。从注释里我们看到我们给注入了一个TCP的全局变量。他的值是一个函数。当我们在JS里执行TCP这个函数的时候，就会执行我们自定义的C++函数，并传入实参。我们定义的函数是Invoke，我们看看实现。</p>\n<pre class=\"prettyprint language-cpp\"><code>static void Invoke(const FunctionCallbackInfo&lt;Value&gt;&amp; info) {\n  Isolate * isolate = info.GetIsolate();\n  &#x2F;&#x2F; 新建一个函数模版，模版函数是TCPServer::NewTCPServer\n  Local&lt;FunctionTemplate&gt; Server = FunctionTemplate::New(isolate, TCPServer::NewTCPServer);\n  Local&lt;String&gt; tcpServerString = String::NewFromUtf8(isolate, &quot;TCPServer&quot;, NewStringType::kNormal, strlen(&quot;TCPServer&quot;)).ToLocalChecked();\n  &#x2F;&#x2F; 函数名\n  Server -&gt;SetClassName(tcpServerString);\n  &#x2F;&#x2F; 预留一个指针空间，保存一些自定义的上下文\n  Server-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\n  \n  &#x2F;&#x2F; 设置TCPServer的原型方法\n  SetProtoMethod(isolate, Server, &quot;socket&quot;, TCPServer::TCPServerSocket);\n  SetProtoMethod(isolate, Server, &quot;bind&quot;, TCPServer::TCPServerBind);\n  SetProtoMethod(isolate, Server, &quot;listen&quot;, TCPServer::TCPServerListen);\n  SetProtoMethod(isolate, Server, &quot;accept&quot;, TCPServer::TCPServerAccept);\n  &#x2F;&#x2F;SetProtoMethod(isolate, Server, &quot;setsockopt&quot;, TCPServer::TCPServerSetsockopt);\n  info.GetReturnValue().Set(Server-&gt;GetFunction(isolate-&gt;GetCurrentContext()).ToLocalChecked());\n}\n</code></pre><p>上面代码看起来很复杂，主要是对V8 API的使用。在V8里，我们自定义的函数格式如下</p>\n<pre class=\"prettyprint language-cpp\"><code>static void func(const FunctionCallbackInfo&lt;Value&gt;&amp; info) {\n\tinfo.GetReturnValue().Set(返回值);\n}\n</code></pre><p>入参是 FunctionCallbackInfo&lt;Value&gt;，函数的返回值通过info.GetReturnValue().Set函数设置。即我们在JS层拿到的内容。上面代码翻译成JS如下。</p>\n<pre class=\"prettyprint language-cpp\"><code>function Invoke() {\n\treturn Server;\n}\n\nfunction Server() {\n    TCPServer.NewTCPServer(this);\n}\nServer.prototype.socket = function socket() {\n\treturn this[0].socket();\n}\n\n\nclass TCPServer(){\n\tconstructor(target) {\n\t\ttarget[0] = this;\n\t\tthis.persistent_handle_ = target;\n\t}\n\tstatic NewTCPServer(target) {\n\t\tnew TCPServer(target);\n\t}\n\t\n\tsocket() {}\n\tbind() {}\n\t...\n}\n</code></pre><p>可以看到，执行Invoke后拿到一个函数TCPServer。然后我们执行new TCPServer，JS代码如下（server.js）</p>\n<pre class=\"prettyprint language-cpp\"><code>const Server = TCP();\nconst server = new Server(&#x27;127.0.0.1&#x27;, 8989);\nserver.socket();\nserver.bind();\nserver.listen();\nwhile(1) {\n    server.accept();\n}\n</code></pre><p>当我们执行new Server的时候。V8首先会创建一个对象obj，然后执行TCPServer.NewTCPServer。并传入obj对象。</p>\n<pre class=\"prettyprint language-cpp\"><code>static void NewTCPServer(const FunctionCallbackInfo&lt;Value&gt;&amp; info) {\n   \tString::Utf8Value ip_address(info.GetIsolate(), info[0]);\n    int port = info[1].As&lt;Uint32&gt;()-&gt;Value();\n    &#x2F;&#x2F; info.This()就是obj\n    new TCPServer(info.GetIsolate(),info.This(), *ip_address, port);\n}\n&#x2F;&#x2F; 在this中保存object，析构C++对象的时候需要重置object[0] \nTCPServer(Isolate* isolate, Local&lt;Object&gt; object, char * ip, int port): _isolate(isolate),persistent_handle_(isolate, object), _ip(ip), _port(port) {\n  &#x2F;&#x2F; obj[0]=this\n  object-&gt;SetAlignedPointerInInternalField(0, static_cast&lt;void*&gt;(this));\n}\n</code></pre><p>NewTCPServer同样创建一个对象this，然后通过obj[0]=this关联起来，这是核心逻辑，一会我们会看到有什么用。接下来我们执行一系列网络编程的函数，不过原理是一样的，我们就分析server.socket()。因为server是一个Server实例。所以server.socket() 对应的函数是Server.prototype.socket。这个函数会从this中取出真正对象（TCPServer实例）的socket函数。然后执行它。</p>\n<pre class=\"prettyprint language-cpp\"><code>&#x2F;&#x2F; 执行真正对象的socket函数\nstatic void TCPServerSocket(const FunctionCallbackInfo&lt;Value&gt;&amp; info) {\n  GetTCPServer(info.Holder())-&gt;Socket();\n}\n&#x2F;&#x2F; 取出真正的对象，即obj[0]\nstatic TCPServer * GetTCPServer(Local&lt;Object&gt; object) {\n    return reinterpret_cast&lt;TCPServer *&gt;((*reinterpret_cast&lt;v8::Local&lt;Object&gt;*&gt;(&amp;object))-&gt;GetAlignedPointerFromInternalField(0));\n }\n</code></pre><p>从中我们可以看到Server函数是一个透传的作用。他主要用于适配V8的协议。真正的逻辑是在它关联的对象中实现的。其余的实现如下。</p>\n<pre class=\"prettyprint language-cpp\"><code>int Socket() {\n    listerFd = socket(AF_INET, SOCK_STREAM, 0);\n    return listerFd;\n}\n\nint Bind() {    \n    struct sockaddr_in serv_addr;\n    memset(&amp;serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(_ip);\n    serv_addr.sin_port = htons(_port);\n    return bind(listerFd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));\n}\n\nint Listen() {\n    return listen(listerFd, 512);\n}\n\nint Accept() {\n    int clientFd = accept(listerFd, nullptr, nullptr);\n    &#x2F;&#x2F; 返回ok，然后关闭TCP连接\n    const char * rsp = &quot;connect ok&quot;;\n    write(clientFd, rsp, sizeof(rsp));\n    close(clientFd);\n    return 0;\n}\n\nint Setsockopt(int level, int optionName, const void *optionValue, socklen_t option_len) {\n    return setsockopt(listerFd, level, optionName, optionValue, option_len);\n}\n\nint Close() {\n    return close(listerFd);\n}\n</code></pre><p>都是对socket网络编程的封装。最后我们通过No server.js启动服务器，全部代码执行完后，最后阻塞在accept。</p>\n<pre class=\"prettyprint language-cpp\"><code>while(1) {\n    server.accept();\n}\n</code></pre><p>这时候我们启动客户端。</p>\n<pre class=\"prettyprint language-cpp\"><code>const net = require(&#x27;net&#x27;);\n\nfunction handle() {\n    setTimeout(() =&gt; {\n        const socket = net.connect({host: &#x27;127.0.0.1&#x27;, port: 8989 });\n        socket.on(&#x27;connect&#x27;, () =&gt; {\n            console.log(&#x27;ok&#x27;);\n            socket.destroy();\n            handle();\n        });\n    }, 1000);\n}\n\nhandle();\n</code></pre><p>我们会看到不断输出ok，因为一直在断连重连。至此我们通过拓展V8完成了一个服务器的开发。</p>\n<p><strong>后记：本文通过拓展V8实现一个简单的朴素版TCP服务器来了如何拓展V8，而Node.js正是用了这种方式。再封装一下操作系统的文件、网络、进程、线程、IPC等等，我们也可以实现一个Node.js。当然，这是理论上。No.js仓库https://github.com/theanarkh/No.js，大家可自行编译</strong></p>\n</div>",
      "title": "从No.js看Node.js原理",
      "author": {
        "loginname": "theanarkh",
        "avatar_url": "https://avatars.githubusercontent.com/u/21155906?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 25,
      "country": "China"
    },
    {
      "id": "60f58c8ae3e67138bc58eacc",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>hi, all 🙋‍♂️  本篇主要是在上一篇 <a href=\"https://cnodejs.org/topic/60c909ba248d047d8f4ad419\">NodeJs 源码学习笔记</a> 的基础上<s>换了一个帅气的排版与清晰的目录结构</s> <strong>增加了一倍的文章</strong> 🐶 接下来会保持周更的节奏，继续深入学习与讲解 NodeJs 核心模块的实现，感兴趣的大佬们可以 star 🌟 <a href=\"https://github.com/xiaoxiaojx/blog\">github</a> 🌟支持, 谢谢阅读 。</p>\n</blockquote>\n<p><img src=\"https://nodejs.org/static/images/logo-light.svg\" alt></p>\n<p>记录一些 Node.js 相关的学习笔记 📝 , To be continued 🚀</p>\n<h3>Node.js 目录</h3>\n<blockquote>\n<p>Node.js 相关介绍及基础可先阅读 <a href=\"http://nodejs.cn/learn\">官网 Node.js 入门教程</a>, 核心模块的使用及文档可先阅读 <a href=\"http://nodejs.cn/api/\">API 文档 | Node.js 中文网</a></p>\n</blockquote>\n<ol>\n<li>\n<p>第 0 章 (c, c++ 基础知识笔记)</p>\n<ol>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/blob/master/learn_c_from_node.md\">learn_c_from_node.md</a></li>\n</ol>\n</li>\n<li>\n<p>运行流程 ( c++, js 源码实现部分 )</p>\n<ol>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/17\">node 启动运行</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/13\">lib 模块运行</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/14\">c++ 插件运行</a></li>\n</ol>\n</li>\n<li>\n<p>lib 模块 ( c++, js 源码实现部分 )</p>\n<ol>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/8\">buffer 缓存区</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/7\">cluster 集群</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/10\">stream 可读流</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/11\">stream 可写流</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/12\">stream 双工流、转换流、透传流等</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/16\">worker_threads 工作线程</a></li>\n</ol>\n</li>\n<li>\n<p>核心模块 ( c, c++, js 源码实现部分 )</p>\n<ol>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/4\">微任务</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/9\">llhttp 报文解析</a></li>\n</ol>\n</li>\n<li>\n<p>libuv ( c 源码实现部分 )</p>\n<ol>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/1\">事件循环</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/2\">线程池与i/o</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/3\">子进程与ipc</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/5\">信号</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/6\">网络与流</a></li>\n</ol>\n</li>\n</ol>\n<h3>随笔目录</h3>\n<blockquote>\n<p>记录一些 debug / 有趣的新技术 / 随意聊聊 等类型的文章</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/15\">127.0.0.1 与 0.0.0.0</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/18\">nextjs 项目热更新失败排查</a></li>\n</ul>\n</div>",
      "title": "深入学习 NodeJs 系列",
      "author": {
        "loginname": "xiaoxiaojx",
        "avatar_url": "https://avatars.githubusercontent.com/u/23253540?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 26,
      "country": "USA"
    },
    {
      "id": "6062ca6a2357dd4ad9f9ddbe",
      "content": "<div class=\"markdown-text\"><h3>背景</h3>\n<p>使用 vue + element UI 进行组件（Tabs）操作，重写了部分的 tabs 组件的样式</p>\n<h3>复现地址</h3>\n<p><a href=\"https://codepen.io/meetthebest/pen/jOyMQLV\">https://codepen.io/meetthebest/pen/jOyMQLV</a></p>\n<h3>复现操作</h3>\n<p>点击页面的 add tab 按钮，预计点击6次左右，页面将卡死</p>\n<p><strong>有大佬知道是什么问题导致的吗 ？</strong>\n个人排查过程中，发现如下图中的 width 属性注释或者删除了，就不会卡死🤔</p>\n<p><img src=\"//static.cnodejs.org/FoSrOAR_FqxbW0lJDn1LLLy3Cz18\" alt=\"image.png\"></p>\n<p>目前还没找到问题，希望知道的大佬指导一下，感谢！！！</p>\n</div>",
      "title": "什么？css 把浏览器搞崩了~",
      "author": {
        "loginname": "MeetTheBest",
        "avatar_url": "https://avatars.githubusercontent.com/u/21294768?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 27,
      "country": "Japan"
    },
    {
      "id": "60aeed641de2d9fb90d5a373",
      "content": "<div class=\"markdown-text\"><p>怎么解决前端浏览器兼容问题，求大神解答</p>\n</div>",
      "title": "怎么解决前端浏览器兼容问题，求大神解答",
      "author": {
        "loginname": "zhangyawei971102",
        "avatar_url": "https://avatars.githubusercontent.com/u/84005968?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 28,
      "country": "China"
    },
    {
      "id": "608ea2884d20cb6d9268fdd3",
      "content": "<div class=\"markdown-text\"><h2>快速切换同一网站的多个已登录账号，支持知乎、豆瓣、微博、Twitter、Facebook 等等</h2>\n<p>项目地址： <a href=\"https://github.com/lvgithub/switch-account\">https://github.com/lvgithub/switch-account</a></p>\n<h2>介绍</h2>\n<p>对于一个网站有多个账户，每次切换马甲，都需要来回退出、登入账户是一个非常麻烦的事情。</p>\n<p>本插件的作用就是，让你登入一次，即可多个账户之间快速的切换，非常高效、方便。</p>\n<h2>原理</h2>\n<p>通过插件切换不同账户的时候，自动设置各自的Cookies。</p>\n<p><img src=\"//static.cnodejs.org/Fq92fk5NRKXUH5UQW1PHyyOCUS_-\" alt=\"image.png\"></p>\n</div>",
      "title": "快速切换同一网站的多个已登录账号，支持知乎、豆瓣、微博、Twitter、Facebook 等等",
      "author": {
        "loginname": "lvgithub",
        "avatar_url": "https://avatars.githubusercontent.com/u/16065346?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 29,
      "country": "USA"
    },
    {
      "id": "607799714d20cbc44d68c484",
      "content": "<div class=\"markdown-text\"><h3>一、Serverless相关的概念</h3>\n<p>Serverless又名无服务器,所谓无服务器并非是说不需要依赖和依靠服务器等资源,而是开发者再也不用过多考虑服务器的问题,可以更专注在产品代码上。</p>\n<p><strong>Serverless相关视频教程</strong>：<a href=\"https://www.bilibili.com/video/BV12h411Q7wz?p=2\">https://www.bilibili.com/video/BV12h411Q7wz?p=2</a></p>\n<p>Serverless是一种软件系统架构的思想和方法，它不是软件框架、类库或者工具。它与传统架构的不同之处在于，完全由第三方管理，由事件触发，存在于无状态（Stateless）、暂存（可能只存在于一次调用的过程中）计算容器内。构建无服务器应用程序意味着开发者可以专注在产品代码上，而无须管理和操作云端或本地的服务器或运行时（运行时通俗的讲就是运行环境，比如nodejs环境，java环境，php环境）。Serverless真正做到了部署应用无需涉及基础设施的建设，自动构建、部署和启动服务。</p>\n<p><strong>通俗的讲：</strong>  Serverless 是构建和运行软件时不需要关心服务器的一种架构思想。老程序员都用过虚拟主机，刚开始学Serverless 你可以把它理解为虚拟主机的升级版本。\n<img src=\"//static.cnodejs.org/FrQYaZ4ed16DDtoKnmfMeyAR6cay\" alt=\"图片1.png\"></p>\n<p>虚拟主机已经是快被淘汰掉的上一代产物了。云计算涌现出很多改变传统IT架构和运维方式的新技术，比如虚拟机、容器、微服务，无论这些技术应用在哪些场景，降低成本、提升效率是云服务永恒的主题。Serverless的出现真正的解决了降低成本、提升效率的问题。它真正做到了弹性伸缩、高并发、按需收费、备份容灾、日志监控等。</p>\n<h3>二、传统模式和ServerLess模式下项目开发上线流程</h3>\n<p><strong>传统模式</strong></p>\n<p><img src=\"//static.cnodejs.org/FkAKf0N_-FFBJeLkfHAIRIGRaHWB\" alt=\"图片2.png\"></p>\n<p><strong>Serverless模式</strong></p>\n<p><img src=\"//static.cnodejs.org/FujjnTbCFWxsoRWvYvswpvsjvIYQ\" alt=\"图片3.png\"></p>\n<p>Serverless 正在改变未来软件开发的模式和流程\n<img src=\"//static.cnodejs.org/Fo0An9-HSBIKZzNJSYGnPVFmRD4A\" alt=\"图片4.png\"></p>\n<h3>三、Serverless 和ServerFul架构的区别</h3>\n<p><strong>1、传统的ServerFul 架构模式</strong>\nServerFul 架构就是 n 台 Server 通过 网络通信 的 方式 协作在一起，也可以说 ServerFul 架构是基于 Server和 网络通信（分布式计算） 的 软件实现架构 ， Server 可以是 虚拟机 物理机 ，以及基于硬件实现的云的云服务器。\n<img src=\"//static.cnodejs.org/FtT0j6_rKqbHrH016dakycYIanzS\" alt=\"图片5.png\"></p>\n<p><strong>2、Serverless  架构模式</strong></p>\n<p>Serverless 的核心特点就是实现自动弹性伸缩和按量付费。\n<img src=\"//static.cnodejs.org/FnQRSZtlryaZQzuzlosJ0FDO2WxH\" alt=\"图片6.png\"></p>\n<p><strong>相比ServerLes相比ServerFul 有下面一些特点：</strong></p>\n<p><strong>资源分配：</strong> 在 Serverless 架构中，你不用关心应用运行的资源（比如服务配置、磁盘大小）只提供一份代码就行。</p>\n<p><strong>计费方式：</strong> 在 Serverless 架构中，计费方式按实际使用量计费（比如函数调用次数、运行时长），不按传统的执行代码所需的资源计费（比如固定 CPU）。计费粒度也精确到了毫秒级，而不是传统的小时级别。个别云厂商推出了每个月的免费额度，比如腾讯云提供了每个月40万GBs的资源使用额度和100万次调用次数的免费额度。中小企业的网站访问量不是特别大的话完全可以免费使用。</p>\n<p><strong>弹性伸缩</strong>： Serverless 架构的弹性伸缩更自动化、更精确，可以快速根据业务并发扩容更多的实例，甚至允许缩容到零实例状态来实现零费用，对用户来说是完全无感知的。而传统架构对服务器（虚拟机）进行扩容，虚拟机的启动速度也比较慢，需要几分钟甚至更久。</p>\n<p>Serverless相关视频教程：<a href=\"https://www.bilibili.com/video/BV12h411Q7wz?p=2\">https://www.bilibili.com/video/BV12h411Q7wz?p=2</a></p>\n</div>",
      "title": "Serverless今年会火吗？",
      "author": {
        "loginname": "phonegap100",
        "avatar_url": "https://avatars.githubusercontent.com/u/5773766?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 30,
      "country": "USA"
    },
    {
      "id": "6184d33e1affc16a5a491513",
      "content": "<div class=\"markdown-text\"><p>1111111111111111111</p>\n</div>",
      "title": "12123321",
      "author": {
        "loginname": "2873395972",
        "avatar_url": "https://avatars.githubusercontent.com/u/83393754?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 31,
      "country": "China"
    },
    {
      "id": "5b3761c857137f22415c5157",
      "content": "<div class=\"markdown-text\"><p>使用vue开发稍复杂的项目时，为了方便状态管理我们都会引入vuex帮助我们管理整个应用的状态，所以一般会用类似下面的项目结构</p>\n<pre class=\"prettyprint language-bash\"><code>|-vue-project\n| |-src\n| | |-components\n| | |-store\n| | |-page\n</code></pre><p>按照这种方式我们就可愉快的进行开发了，有一天你希望页面刷新时当前页面的状态依然可以保持，我们首先想到的就是可以把vuex的状态树放到 <code>localStorage</code> 里。这个时候你会怎么办？google一下 <code>vuex localStorage</code> 看看有什么现有的解决方案，于是我们搜索到了<code>vuex-persistedstate</code> ，嗯，它就是我们今天的主角，让我们围绕<code>vuex-persistedstate</code> 展开讨论，看看有什么值得我们学习的地方。</p>\n<p>首先 vuex-persistedstate 用起来非常简单。先看下面的用法</p>\n<h2>安装</h2>\n<pre class=\"prettyprint language-bash\"><code>npm install vuex-persistedstate\n</code></pre><h2>用法</h2>\n<pre class=\"prettyprint language-js\"><code>import createPersistedState from &quot;vuex-persistedstate&quot;;\n\nconst store = new Vuex.Store({\n  &#x2F;&#x2F; ...\n  plugins: [createPersistedState()]\n});\n</code></pre><p>插件会自动帮你做如下两件事：</p>\n<ol>\n<li>当vuex状态发生改变时，自动同步保存到 localStorage</li>\n<li>当重新加载页面vuex初始化时，自动将 localStorage 存储的数据作为初始状态加载</li>\n</ol>\n<p>现在你又可以愉快的进行开发了，不需要对localStorage进行任何操作。唯一要做的就是由你来决定何时清除 localStorage</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 清除所有\nwindow &amp;&amp; window.localStorage.clear();\n\n&#x2F;&#x2F; 清除指定key\nwindow &amp;&amp; window.localStroage.removeItem(&#x27;vuex&#x27;)\n</code></pre><h2>由此引发的思考</h2>\n<p>几个关键字:</p>\n<ul>\n<li>职责单一</li>\n<li>解耦</li>\n<li>设计模式</li>\n</ul>\n<p>我们只做了很少的事件就达到了我们想要的功能，中间没有修改任何store的代码，比如你可能会在每一个 mutation 里操作localStroage</p>\n<p>before</p>\n<pre class=\"prettyprint language-js\"><code>state: {\n\ttoken: null\n},\nmutations: {\n\tSET_TOKEN(state, token){\n\t\tstate.token = token\n\t}\n}\n\n</code></pre><p>after</p>\n<pre class=\"prettyprint language-js\"><code>state: {\n\t&#x2F;&#x2F; 你可能会在这里操作 localStorage 获取 token\n\ttoken: window &amp;&amp; window.localStorage.getItem(&#x27;token&#x27;)\n},\nmutations: {\n\tSET_TOKEN(state, token){\n\t\tstate.token = token\n\t\t&#x2F;&#x2F; 你可能会在这里操作 localStorage 存储 token\n\t\twindow &amp;&amp; window.setItem(&#x27;token&#x27;, token)\n\t}\n}\n\n</code></pre><p>如上代码，目的是达到了，但是非常麻烦，代码严重耦合。而且如果想存储更多的值还得额外的去写更多代码，后期的维护成本增加了。所以上面的解决方案不可取。比较而言<code>vuex-persistedstate</code> 的解决方案更加优雅。</p>\n<blockquote>\n<p>Vuex 的 store 接受 plugins 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数：<a href=\"https://vuex.vuejs.org/zh/guide/plugins.html\">vuex 插件</a></p>\n</blockquote>\n<p><code>vuex-persistedstate</code> 正是利用这个vuex提供的这个特性，统一处理与 localStorage 相关的工作。</p>\n<pre class=\"prettyprint language-js\"><code>  ...\n  \n  return function(store) {\n    &#x2F;&#x2F; 从localStorage 中取值\n    const savedState = shvl.get(options, &#x27;getState&#x27;, getState)(key, storage);\n\t &#x2F;&#x2F; 如果 savedState 有值，则替换 vuex 的 store\n    if (typeof savedState === &#x27;object&#x27; &amp;&amp; savedState !== null) {\n      store.replaceState(merge(store.state, savedState, {\n        arrayMerge: options.arrayMerger || function (store, saved) { return saved },\n        clone: false,\n      }));\n    }\n\t  \n\t  &#x2F;&#x2F; 订阅 mutation 的每一次变化，换需决定是否保存到 localStorage\n    (options.subscriber || subscriber)(store)(function(mutation, state) {\n      if ((options.filter || filter)(mutation)) {\n        (options.setState || setState)(\n          key,\n          (options.reducer || reducer)(state, options.paths || []),\n          storage\n        );\n      }\n    });\n  };\n</code></pre><ul>\n<li>职责单一</li>\n</ul>\n<p>vuex , vuex-persistedstate 各伺其职， vuex 负责管理 整个 app 的状态，状态在内存中，它没有再多做什么， vuex-persistedstate 负责把内存中的状态同步到 localStorage, 及 把 localStorage存储的数据加载到vuex store， 从头到尾我们的app除了清理工作，再没有和 localStorage打交道就像下面这张图</p>\n<p><img src=\"//static.cnodejs.org/FlKYMaxyzm3NVDnYR08tZy7Q_7Pk\" alt=\"15303530418717.jpg\"></p>\n<p><strong>职责单一</strong>带来的好处就是充分的<strong>解耦</strong>。</p>\n<ul>\n<li>设计模式 插件模式</li>\n</ul>\n<p>其实整个app应用就是插件的集合， vuex 是 vue 的插件，  vuex-persistedstate 又是 vuex的插件。vue 和 vuex 在设计之初就充分的考虑到了以插件的方式进行功能扩展。而它们自身只实现领域范围内的事，不做多余的工作。</p>\n<blockquote>\n<p>插件（Plugin）模式向用户提供了一种扩展程序的接口，用户可以在程序本体之外，按照指定接口编写插件来为程序增加功能。</p>\n</blockquote>\n<p><strong>结论： 合理利用设计模式对于提高程序的扩展性和可维护性至关重要。</strong></p>\n<p>推荐阅读：</p>\n<p><a href=\"https://yuque.com/ant-h5/react/dybrh2\">思考方法与领域模型</a>\n<a href=\"https://vuex.vuejs.org/zh/guide/plugins.html\">vuex 插件</a></p>\n</div>",
      "title": "vuex 与 localStorage 协同工作 引发的思考",
      "author": {
        "loginname": "virtoolswebplayer",
        "avatar_url": "https://avatars0.githubusercontent.com/u/6807430?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 32,
      "country": "USA"
    },
    {
      "id": "616d2e7bdfe3c9c109f2b7fd",
      "content": "<div class=\"markdown-text\"><p>本人在开发一个项目，正在选型nodejs框架</p>\n</div>",
      "title": "跪求，国内哪个nodejs框架用的比较多啊",
      "author": {
        "loginname": "wallace5303",
        "avatar_url": "https://avatars.githubusercontent.com/u/6782673?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 33,
      "country": "China"
    },
    {
      "id": "61823e561affc1cc884905af",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-nodejs\"><code>let fs = require(&quot;fs&quot;);\nlet initSqlJs = require(&quot;.&#x2F;sql-wasm.js&quot;);\nlet filebuffer = fs.readFileSync(&quot;&#x2F;path&#x2F;to&#x2F;sample.sqlite&quot;);\n\ninitSqlJs().then(function (SQL) {\n  &#x2F;&#x2F; Create a new database with our existing sample.sqlite file\n  const db = new SQL.Database(filebuffer);\n});\n</code></pre><p>比如上面的代码，如果想在html里面用，可以实现吗？</p>\n</div>",
      "title": "sql-wasm可以用在html页面里吗？",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 34,
      "country": "Japan"
    },
    {
      "id": "618224410af0632c42c86ac1",
      "content": "<div class=\"markdown-text\"><p>中国 IP 地址访问雅虎旗下服务，会跳到一个网页，声明：“2021 年 11 月 1 日起，用户将无法从中国使用 Yahoo 的产品与服务。这并不影响 Yahoo 在全球其他地方的产品及服务。我们感谢你一直以來的支持。”暂时不清楚此举是临时性的还是永久性的。雅虎现在和 AOL 隶属于私募股权公司 Apollo Global Management，仍然沿用雅虎的名字，它旗下包含了大量的媒体和服务，包括雅虎(其中有 Yahoo! Mail、 Yahoo! Finance、Yahoo! News, Yahoo! Sports 等等)、AOL、Engadget、Netscape 和 TechCrunch，很多服务的 Alexa 排名都位居世界前列。</p>\n</div>",
      "title": "雅虎限制中国 IP 访问",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 35,
      "country": "China"
    },
    {
      "id": "60dbd3fd248d04133e4afa0b",
      "content": "<div class=\"markdown-text\"><p>Midway Serverless  用的人多吗？ Midway Serverless  和serverless framework什么区别？哪位老铁用过</p>\n</div>",
      "title": "Midway Serverless  用的人多吗",
      "author": {
        "loginname": "phonegap100",
        "avatar_url": "https://avatars.githubusercontent.com/u/5773766?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 36,
      "country": "USA"
    },
    {
      "id": "615bb05cfe0c510de0aecba2",
      "content": "<div class=\"markdown-text\"><p>打算用nodejs做saas系统，目前框架使用的是midwayjs，同时用到了TypeORM，请问TypeORM可以实现全局自动添加租户id查询条件吗？看TypeORM文档有个实体监听器和订阅者，是否可以通过AfterLoad、BeforeInsert等监听器来处理实现？可以的话需要怎么写呢？ 者有没有其他的好用的方法来实现？</p>\n</div>",
      "title": "nodejs做SaaS系统，用TypeORM可以实现全局自动添加租户id查询条件吗？",
      "author": {
        "loginname": "tuohuang",
        "avatar_url": "https://avatars.githubusercontent.com/u/14804820?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 37,
      "country": "Japan"
    },
    {
      "id": "615e642efe0c5145f9aecdc9",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FjhvnXI6dW_VsIYpgprjhX5cVSqE\" alt=\"2021-10-07_110507.jpg\"></p>\n</div>",
      "title": "有人用过mithril吗？",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 38,
      "country": "China"
    },
    {
      "id": "614a8789fe0c512666aeabc7",
      "content": "<div class=\"markdown-text\"><p>来说说有什么坑</p>\n</div>",
      "title": "有人用taro吗？",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 39,
      "country": "USA"
    },
    {
      "id": "6180d5b90af06343b6c86826",
      "content": "<div class=\"markdown-text\"><p>路由配置代码如下</p>\n<pre class=\"prettyprint\"><code>{\n    path: &#x27;&#x2F;&#x27;,\n    name: &#x27;ceshi&#x27;,\n    icon: &#x27;testicon&#x27;,\n    component: &#x27;.&#x2F;Ceshi&#x27;,\n  }\n</code></pre></div>",
      "title": "请教大家为什么ant design pro配置路由的时候， /路由会产生两个菜单，其中一个是/，另外一个会是/index.html",
      "author": {
        "loginname": "Choicelin",
        "avatar_url": "https://avatars.githubusercontent.com/u/10152588?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 40,
      "country": "Eurozone"
    },
    {
      "id": "616a19cadfe3c9d324f2b4ac",
      "content": "<div class=\"markdown-text\"><ul>\n<li><a href=\"https://tech.ifeng.com/c/89334gj5kEf\">https://tech.ifeng.com/c/89334gj5kEf</a></li>\n</ul>\n<p>官宣996 非法，够烂必须与动态语言在8小时内比开发效率，大家又回到同一个起跑线\n够烂码农要在8小时内手写完json 压力山大</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/419419999\">https://zhuanlan.zhihu.com/p/419419999</a></li>\n</ul>\n<p>头条很可能要归国有资本 够烂码农要过上一杯茶一张报纸一下午的国企生活了，那么问题来了，七大姑八大姨削尖脑门都扎堆的国企里面，够烂码农还能挣到钱吗？就算挣到钱还能拿到手吗</p>\n<ul>\n<li><a href=\"https://finance.sina.com.cn/blockchain/coin/2021-09-26/doc-iktzqtyt8245722.shtml\">https://finance.sina.com.cn/blockchain/coin/2021-09-26/doc-iktzqtyt8245722.shtml</a></li>\n</ul>\n<p>够烂的最大优势cpu密集计算领域的应用场景官宣非法 够烂要么出海malaysia，要么转入内卷行业\n<a href=\"https://www.163.com/money/article/GLRVP94S00259DLP.html\">https://www.163.com/money/article/GLRVP94S00259DLP.html</a>\n<a href=\"https://news.pedaily.cn/202110/479350.shtml\">https://news.pedaily.cn/202110/479350.shtml</a></p>\n</div>",
      "title": "够烂是不是凉凉了",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 41,
      "country": "USA"
    },
    {
      "id": "60d58e91248d0473cf4aefa6",
      "content": "<div class=\"markdown-text\"><h1>Egg Controller</h1>\n<p><img src=\"//static.cnodejs.org/FviaHZv71PmKF1bdoxGQgT2kiVLS\" alt=\"1624608589244.jpg\"></p>\n<h1>Swagger文档效果</h1>\n<p><img src=\"//static.cnodejs.org/FmmSFlWosBtYCWFDSvbCU2sIV9D6\" alt=\"1624608479414.jpg\"></p>\n<h1>插件地址</h1>\n<p>赶紧访问<a href=\"https://github.com/JsonMa/swagger-egg/blob/master/README.zh_CN.md\">Swagger-Egg</a>尝鲜吧！</p>\n</div>",
      "title": "你是否也在为写Egg API文档而烦恼？给大家安利一款可自动生成Swagger API文档的Egg插件！",
      "author": {
        "loginname": "JsonMa",
        "avatar_url": "https://avatars.githubusercontent.com/u/13042493?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 42,
      "country": "USA"
    },
    {
      "id": "617f4aa60af063db46c86397",
      "content": "<div class=\"markdown-text\"><p>node获取前台浏览器的cookie和ip通过header传给java后台结果数据混乱了，穿的数据不一致，是什么原因导致的？？？有什么解决办法？</p>\n</div>",
      "title": "node获取数据混乱",
      "author": {
        "loginname": "tixin",
        "avatar_url": "https://avatars.githubusercontent.com/u/10919054?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 43,
      "country": "USA"
    },
    {
      "id": "61107aa3a5d29d23f62d5460",
      "content": "<div class=\"markdown-text\"><h2>生命周期</h2>\n<ul>\n<li>事物从出生到死亡的过程</li>\n<li>Vue实例从创建到销毁的过程 ，这些过程中会伴随着一些函数的自调用。我们称这些函数为钩子函数</li>\n</ul>\n<p>常用的钩子函数</p>\n<table>\n<thead>\n<tr>\n<th>beforeCreate</th>\n<th>在实例初始化之后，数据观测和事件配置之前被调用 此时data 和 methods 以及页面的DOM结构都没有初始化   什么都做不了</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>created</td>\n<td>在实例创建完成后被立即调用此时data 和 methods已经可以使用  但页面还没有渲染出来</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>在挂载开始之前被调用   此时页面上还看不到真实数据 只是一个模板页面而已</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。  数据已经真实渲染到页面上  在这个钩子函数里面我们可以使用一些第三方的插件</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>数据更新时调用，发生在虚拟DOM打补丁之前。页面上数据还是旧的</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 页面上数据已经替换成最新的</td>\n</tr>\n<tr>\n<td>beforeDestroy</td>\n<td>实例销毁之前调用</td>\n</tr>\n<tr>\n<td>destroyed</td>\n<td>实例销毁后调用</td>\n</tr>\n</tbody>\n</table>\n</div>",
      "title": "aowin  之 vue的生命周期",
      "author": {
        "loginname": "Userzt",
        "avatar_url": "https://avatars.githubusercontent.com/u/78284561?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 44,
      "country": "China"
    },
    {
      "id": "61694077dfe3c906eff2b3e0",
      "content": "<div class=\"markdown-text\"><p>以前都花好多钱买服务器，一次性买6台三年，真香</p>\n<p><img src=\"//static.cnodejs.org/FlFRRrkz2Ld67hIFZ1disVx1uMqX\" alt=\"11.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtvkJoYQH_w7yRYJgCETFVW27D8v\" alt=\"WX20211025-091708@2x_gaitubao_275x271.png\"></p>\n</div>",
      "title": "这服务器真tm便宜",
      "author": {
        "loginname": "cool-team-official",
        "avatar_url": "https://avatars.githubusercontent.com/u/62868950?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 45,
      "country": "Eurozone"
    },
    {
      "id": "601e668a03d797cf5b66f437",
      "content": "<div class=\"markdown-text\"><h2>PPT地址</h2>\n<p><a href=\"https://github.com/midwayjs/subway-station/tree/master/No.10.HangZhou.Let%E2%80%99s%20imagine%202021\">https://github.com/midwayjs/subway-station/tree/master/No.10.HangZhou.Let’s imagine 2021</a>!</p>\n<h2>视频</h2>\n<p><a href=\"https://www.bilibili.com/video/BV1Af4y1t7EH?p=1\">https://www.bilibili.com/video/BV1Af4y1t7EH?p=1</a>\n《基于 Addon 的 Node.js 性能监控与线上故障定位解决方案》\n《Midway Hooks — 更具生产力的全栈框架：全栈、“零” API、Hooks 开发后端》\n<a href=\"https://www.bilibili.com/video/BV1Af4y1t7EH?p=2\">https://www.bilibili.com/video/BV1Af4y1t7EH?p=2</a>\n《比Webpack5快4倍的AirpackCDN — 新一代组件分发网络构建之路》\n《iMove—致力于提高开发效率的js框架：开启可视化编排的新型开发模式》\n《SSR framework 2.0 -同时支持React, Vue 的服务端渲染能力》\n<a href=\"https://www.bilibili.com/video/BV1Af4y1t7EH?p=3\">https://www.bilibili.com/video/BV1Af4y1t7EH?p=3</a>\n大佬圆桌会（死月，当轩，霸天，流司，侑夕）</p>\n<p>文档\n<a href=\"https://cnodejs.org/topic/601e668a03d797cf5b66f437\">https://cnodejs.org/topic/601e668a03d797cf5b66f437</a></p>\n<p>ppt\n<a href=\"https://github.com/midwayjs/subway-station/tree/master/No.10.HangZhou.Let%E2%80%99s%20imagine%202021\">https://github.com/midwayjs/subway-station/tree/master/No.10.HangZhou.Let’s imagine 2021</a>!</p>\n<h2>喜欢的自取</h2>\n<p>本次采用线上直播方式，会使用阿里的会议室，此次Node Party使用Node地下铁品牌。会在视频号：AlibabaF2E和Bilibili：支付宝体验科技同时直播。</p>\n<p>大家有啥想法可以随时补充。</p>\n<h2>主题分享</h2>\n<h3>1、《基于 Addon 的 Node.js 性能监控与线上故障定位解决方案》</h3>\n<p>选题理由：<strong>如果说2020国内Node.js社区最大的事件，我以为是 Easy-Monitor 3.0 版本开源了，它是一款Node.js 应用性能监控与线上故障定位解决方案。</strong></p>\n<p>Topic简介：旨在 Node.js 的开源生态工具链上，做一些能帮助到想使用和正在使用 Node.js 的开发者更好地感知自己的 Node.js 应用状态，以更好地面对来自性能和稳定性方面的挑战。</p>\n<p>个人简介：<a href=\"https://github.com/hyj1991/\">hyj1991</a>，开源 Node.js 性能监控工具 <a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a> 作者，参与了开源框架 Egg.js 的维护，以前 AliNode 的核心开发者之一，前端架构师，目前在社区一直致力于 Node.js 基础保障性质工具链的进一步完善。</p>\n<p><img src=\"//static.cnodejs.org/Fkm3ogNc8lbsjFMQatCF54qgyUul\" alt=\"16126047795218.jpg\"></p>\n<h3>2、《Midway Hooks — 更具生产力的全栈框架：全栈、“零” API、Hooks 开发后端》</h3>\n<p>选题理由：<strong>Midway Hooks是社区Web方向比较有新意的项目，面向FaaS让开发更简单，面向React开发者，让同构全栈更简单。</strong></p>\n<p>简介：<a href=\"https://github.com/midwayjs/hooks\">Midway Hooks</a> 是为前端开发者打造的全栈框架，具有以下优势：☁️ 全栈，在 src 目录中开发前后端代码、🌈 “零”API，极其简单的后端 Api 开发与调用方式、🌍 使用 “React Hooks” 开发后端。本次分享则将为大家介绍 Midway Hooks 的用法、设计理念以及背后的技术原理。</p>\n<p>个人简介：刘子健（花名繁易，Lxxyx：Node.js），淘系技术部-前端架构团队成员。开源爱好者，Node.js Core Collaborator，目前致力于打造更具生产力的全栈框架：Midway Hooks。</p>\n<p><img src=\"//static.cnodejs.org/FsqpQzPYFIz0xzXGGIwf5CxjFSML\" alt=\"16126048815842.jpg\"></p>\n<h3>3、《比Webpack5快4倍的AirpackCDN — 新一代组件分发网络构建之路》</h3>\n<p>选题理由：<strong>Deno带动了http import的发展，同时也使得社区从Commonjs到ESM的趋势日渐明显，这就促使社区会出现新一代CDN技术的诞生。</strong></p>\n<p>Topic简介：AirpackCDN 是适用于现代 Web 应用程序的组件分发网络 (Components Delivery Network for modern web apps)，是集团内第一个为现代 JavaScript 应用程序设计和优化的 CDN（注：还未开源，筹备中）。通过 Airpack 网络的分发的组件可以直接在浏览器中使用，且针对浏览器做了大量优化，几乎所有软件包都可以以 ES Module 的格式对外输出，我们致力于构建一个可以依赖的核心基础设施。</p>\n<p>作者简介：赵吉彤（花名：牧曈），阿里云体验技术团队前端工程师，主攻前端中后台、工程化方向，开源爱好者，资深极客。</p>\n<p><img src=\"//static.cnodejs.org/FjDKce673wxx97YeqhT62wpx94oO\" alt=\"16125037643179.jpg\"></p>\n<h3>4、《iMove—致力于提高开发效率的js框架：开启可视化编排的新型开发模式》</h3>\n<p>选题理由：<strong>前端智能化解决了设计稿到代码的UI渲染部分，但逻辑代码如何生成依然是一个难题。iMove算一个不错的探索</strong></p>\n<p>Topic简介：<a href=\"https://github.com/imgcook/imove\">iMove</a>是为开发者打造的支持可视化编排的js框架，具有以下优势：🔥逻辑可组装：接口和UI在最小粒度上的复用；☁️流程可视化：最小单元通过流程图进行编排；🌈 逻辑复用：将逻辑进行沉淀，变成可复用的能力；🌲运营配置收敛：降低运营操作成本。本次分享则将为大家介绍 iMove 的使用方法、底层原理、设计思想，以及此框架是如何解决低代码开发中的痛点问题的。</p>\n<p>个人简介：杨佩（花名冷卉），阿里淘系技术部f(x) team团队成员，iMove核心成员，开源爱好者。目前致力于打造用于提高开发效率的新一代智能化基建。</p>\n<p><img src=\"//static.cnodejs.org/FjXLoj0EpAmLhgACJK5Sw5OuJUMD\" alt=\"16126049650090.jpg\"></p>\n<h3>5、《SSR framework 2.0 -同时支持React, Vue 的服务端渲染能力》</h3>\n<p>选题理由：<strong>从egg-react-ssr到ykfe/ssr是一个不错的演进，Serverless-side render概念也慢慢被大家接受，2020年淘宝双十一使用了ssr，拼多多的页面渲染也使用了ssr，可见ssr是一个不可缺少的Web应用技术。</strong></p>\n<p>Topic简介：<a href=\"https://github.com/ykfe/ssr\">SSR framework 2.0</a>集成自ykfe/ssr 1.0，同时支持React, Vue 的服务端渲染能力，以插件化的形式支持任意服务端框架与前端框架的结合，同时支持Serverless方式或传统Node.js应用方式部署.</p>\n<p>个人简介：张宇昂，微信前端工程师，前阿里巴巴前端工程师，专注于 Node.js 与前端的结合在企业的实践落地，ykfe/ssr框架核心开发者, 下一代前端构建工具Vite爱好者和Rust 爱好者。</p>\n<p><img src=\"//static.cnodejs.org/FjnIQLlOsfUyoaFmt7_vbWrVWVmi\" alt=\"image.png\"></p>\n<h2>大佬圆桌会</h2>\n<p>待定：本次线下在杭州，大果、流司、雷姆、死月</p>\n<p>还没有沟通完成</p>\n<h2>直播信息</h2>\n<ul>\n<li>时间：2021年3月6日，下午2点-6点</li>\n<li>Obs推流</li>\n</ul>\n<h3>1）微信视频号：AlibabaF2E</h3>\n<p><img src=\"//static.cnodejs.org/FtM_sWKCWUbmiXTx36xP0dv50n7E\" alt=\"image.png\"></p>\n<h3>2）Bilibili：支付宝体验科技</h3>\n<p><img src=\"//static.cnodejs.org/FnaquwPttUJx7haOT51yjR8kekzP\" alt=\"image.png\"></p>\n<h2>活动安排</h2>\n<p>稍后给出</p>\n<h2>沟通群</h2>\n<p>如果想参加活动，反馈意见都可以加入下面这个钉钉群</p>\n<p><img src=\"//static.cnodejs.org/Ft0nBD73FkFw8CBbceGjo0HW29iu\" alt=\"image.png\"></p>\n</div>",
      "title": "2021年3月6日Node Party PPT",
      "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars.githubusercontent.com/u/3118295?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 46,
      "country": "USA"
    },
    {
      "id": "617f692c0af0631b62c86418",
      "content": "<div class=\"markdown-text\"><p>static checkMessageDuplication(messageId, callback) {\nvar key = <code>/messageIDs/${messageId}</code>\nredisClient.setnx(key, “”, function (err, res) {\nif (res == 1) {\nredisClient.expire(key, 60 * 60 * 6)\ncallback.call(this, false)\n} else {\ncallback.call(this, true)\n}\n})\n}\n\t这个函数中的callback.call(this,true)应该怎样理解，网上找了半天也没有找到解释的清楚点，所以特来论坛找大神帮忙，一个是想知道callback加个call是什么意思，然后加了call后，这个函数应该怎样理解？</p>\n</div>",
      "title": "我想问一下怎样理解callback.call()",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 47,
      "country": "USA"
    },
    {
      "id": "617f3b270af063299cc86338",
      "content": "<div class=\"markdown-text\"><p>做了一个微信小程序，用户可以赚取佣金提现，提现方式可以提现到支付宝或者银行卡，有没有大神做过的或者提供个思路 感激不尽</p>\n</div>",
      "title": "node 怎么做提现功能",
      "author": {
        "loginname": "905868332",
        "avatar_url": "https://avatars.githubusercontent.com/u/29794128?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 48,
      "country": "China"
    },
    {
      "id": "617e897f0af063ba9ec862a0",
      "content": "<div class=\"markdown-text\"><p>用ip138查询ip显示\n<img src=\"//static.cnodejs.org/FhZG3vq3fpXJ_rOTwnBZuaGkd_uy\" alt=\"cloudflare.png\"></p>\n</div>",
      "title": "cdnjs.cloudflare.com 有替代吗？",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 49,
      "country": "USA"
    },
    {
      "id": "617e5d990af0638c84c8626a",
      "content": "<div class=\"markdown-text\"><p><img src=\"https://user-images.githubusercontent.com/23253540/140098710-57b43962-4c24-449b-a799-164fa85642bc.png\" alt=\"image\"></p>\n<h2>背景</h2>\n<p>最近一段时间陆续有同学吐槽, 现有的开发环境打包太慢了, 原话如下</p>\n<ul>\n<li>同学 a: xxx 项目冷启动，刚刚计时是 3分45秒 左右，有空看看是否有优化空间哈。\n视频是 xxx 项目 f-xxx-6196 分支（yarn dev回车后开始计时）</li>\n<li>同学 b: 本地运行太慢了，想砍人</li>\n<li>同学 c: 我们项目启动很慢，咋整</li>\n<li>同学 d: xxx 项目编译时间太长了，改个东西容易电脑卡，不排除我的电脑问题，体验很差</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/23253540/139574683-cde367e6-3de6-460b-b28f-869fcd150e53.png\" alt=\"0cbf92807d10b552fccc77993449a821c97ecb14\"></p>\n<blockquote>\n<p>截图为该项目的 gitlab 信息</p>\n</blockquote>\n<p>也确实, 3分45秒 🐢🐢🐢 的等待时间谁又受得了 😣 ！ 那么我们现在的脚手架的问题出在哪里 ?</p>\n<blockquote>\n<p>现有脚手架是基于 webpack 打包，其实做了 如 babel, ts 等缓存优化，甚至 hard-source 这样的持久缓存。但是由于需求的快速迭代，一切换分支导致了大量 node_modules 依赖变化需要重新生成新的缓存，使得每次打包缓存等优化等都失效了, 此时我也埋下了 nopack (不打包 ❌📦 ) 的仇恨种子！</p>\n</blockquote>\n<p>所以当现有的优化手段都命中的时候，时间才能勉强减少到 40s 🐢 左右。</p>\n<p><img src=\"https://user-images.githubusercontent.com/23253540/139096712-0820fd05-b088-4504-ae7b-7ed0dbe8e161.png\" alt=\"image\"></p>\n<p>webpack5 也尝试去解决慢的这个问题, 比如新增了一个比较重量级的持久缓存的功能, 不过从 esbuild 官方给大家的数据来看, webpack5 却是最慢的 ! 😢</p>\n<blockquote>\n<p>这可能是 webpack5 被黑得最惨的一次… 因为第一次打包有一部分时间是在生成缓存了, 怎么不拿第二次缓存生效后的时间来遛一遛比一比了？在这种情况下, 我们升级 webpack5 可能还是解决不了痛点, 分支一来回切换又回到了解放前!</p>\n</blockquote>\n<p>当项目逐渐膨胀时, 似乎是已经到了 webpack 的瓶颈, 近期特别火的 vite 与 snowpack 或许才是真正的解决方案 ?</p>\n<h2>vite、snowpack</h2>\n<p>最终我想到的是接入 vite 或者 snowpack 解决现有的问题, 关于提到的这些工具的原理, 有不少文章都讲得很好了, 这里就不做过多的介绍。</p>\n<p>snowpack 刚出来不久就认真充满好奇的读了他的代码, 发现里面有不少写死的地方, 比如 define 是通过字符串的替换去实现, 这明显就会误伤无辜, css 的 import 也没处理, 最近作者也说会交给社区去维护, 自己有些力不从心了。</p>\n<blockquote>\n<p>Real-world testing is super important. I’m sure that sounds cliche, but its true. We had a few starter projects that we could test Snowpack against, but they were all small and simple. This created a huge experience gap between our internal projects and our actual users.</p>\n</blockquote>\n<p>文章出自 <a href=\"https://dev.to/fredkschott/5-more-things-i-learned-building-snowpack-to-20-000-stars-5dc9\">6 More Things I Learned Building Snowpack to 20,000 Stars (Part 2)</a>, 而我们更接近业务, 近 100 个大型项目, 包含各类系统与 h5, 几乎能踩完所有的坑。</p>\n<blockquote>\n<p>To be honest, I’m not sure where Snowpack goes from here. I burnt out on it at the end of last year, and haven’t found the energy to return. Usage and downloads began to trend down and the community has gotten quieter.</p>\n</blockquote>\n<blockquote>\n<p>At the same time, Vite (that Snowpack alternative that now powers SvelteKit) is taking off. To their credit, they do a lot of things really well. The good news is that two tools are very similar and easy to switch out. Even Astro is experimenting with moving from Snowpack to Vite in a future release.</p>\n</blockquote>\n<p>虽如此 snowpack 依然是个可敬的产品 🔥 ~</p>\n<p>所以综合体验下来还是 vite 值得信赖, 如果此时是新项目毫无疑问我推荐大家使用 vite, 但是我们这是老项目…</p>\n<p>何为老项目? 就是之前升级了一个 ts-loader 的大版本, 有俩项目测试环境白屏了。在试图接入 vite 时遇见了 cssModules 解析报错、js scss import 解析路径失败等问题。</p>\n<p>到这里我认为 vite 是没有任何问题的, 有些稀奇古怪, 百花齐放的问题的代码就得你自己去改, 当然实际继续挣扎下去可能会发现更多的奇葩问题, 其解决沟通成本和时间成本是无法估计的。</p>\n<h2>nopack</h2>\n<p><img src=\"https://user-images.githubusercontent.com/23253540/140097845-c9f71f77-6ea1-4195-875f-c65d22a62147.png\" alt=\"image\">\n最终我决定自己开发, 并且过渡阶段希望可以随意切换新的 esm 开发模式与现有的 webpack 模式。</p>\n<blockquote>\n<p>nopack 将以全局安装的形式存在, 即对现有项目 0 侵入，对线上环境 0 危险，对接入的项目源代码可以做到 0 修改就可以运行起来。</p>\n</blockquote>\n<h3>Q: 如何做到项目 0 改动接入 ?</h3>\n<ul>\n<li>vite 的大部分零件 jsResolver, sass 等的处理是偏向于 rollup 体系。要想无缝兼容现在项目中配置的 _moduleAliases 与 sass 中各种 import, 于是这部分我采用的 webpack 的零件, 主要是 enhanced-resolve 与 sass-loader 的处理逻辑。</li>\n<li>另一点不太重要的是发现大家都喜欢用 websocket 通信, vite、snowpack、webpack-dev-server 都是如此, 而 nopack 这里使用的是 sse。</li>\n</ul>\n<h3>Q: nopack 这个名字是啥意思 ?</h3>\n<ul>\n<li>\n<p>本意是只想做一个转译服务, 竭尽全力的不打包 ❌📦 。最初是想仅对 ts 与 jsx 文件请求进行一个转译后返回, 即总共只进行一次 AST 的操作。想法还是天真了, 因为 cjs to ejs 是一个不成立的事情, require 是运行时的, import 是静态的, 可能你想到了 import() 函数不也是运行时的吗 ? 不过 import() 返回的却是 Promise !</p>\n</li>\n<li>\n<p>事实证明初期只想做转译的思想不成立 👇\n<img src=\"https://user-images.githubusercontent.com/23253540/139574362-47435c1a-1bf7-4340-a2ad-d47beb72af10.png\" alt=\"image\"></p>\n</li>\n</ul>\n<h3>Q: 如何彻底消除 cjs 这些语法了 ?</h3>\n<ul>\n<li>那就只有预构建打包了, 合成一个文件, require 的代码直接塞在对应的位置了, 哪还会有 require 这些东西了</li>\n</ul>\n<h3>Q: nopack 不是坚决不打包吗 ?</h3>\n<ul>\n<li>为了这些不合法模块, 只能忍气吞声了, 这里 nopack 与 vite 这里有些区别, nopack 会试图判断这个 npm 包是不是 esm 的包, 比如 package.json 中有 module, browser 字段, 或者 import 的是 es, esm 目录的文件如 “packageA/es/a.js” 这种或许也是 esm 就不进行预构建了。这样下来项目 xxx 🔍 扫描到了 336 个包, 最后只会对 199 个包进行预构建 📦 。</li>\n</ul>\n<h3>Q: 这样看来比 vite 更快 ?</h3>\n<ul>\n<li>快是快了, 但是具有迷惑性行为的包也不少, 比如某个包也声明了 module 字段, 但我其实是 cjs 的代码。更有甚者一个包中大部分文件是 esm 的, 有1 ～ 2 文件个是 cjs 的🤯!  没办法, 你不是 nopack 吗, 这些包我忍你了, 我 hardcode 到一个数组中把你们加入黑名单。所以进行全量预构建的 vite 作为一个通用的工具可能也是无奈之举。</li>\n</ul>\n<h3>Q: 最终接入的效果如何 ?</h3>\n<ul>\n<li>号称 3分45秒 的项目通过 esbuild 预构建大概只花 8s 左右, 然后页面刷新时会对 src 下的 ts 与 jsx 通过 esbuid 进行转译, 大概 4s 的时间, 所以最终开始预构建到页面完全展示出来只花了 12s, esbuild 远比我想象中的更快 ⚡️⚡️⚡️。</li>\n</ul>\n<h3>Q: esm 开发的劣势?</h3>\n<ol>\n<li>刷新页面的等待时间会慢一点\n<ul>\n<li>esm 模式强调转译, 浏览器运行阶段代码从入口文件一直往下运行下去的时候, 会不断有 import 语法发起新的文件请求, 对于 jsx 与 ts 文件的请求还需要通过 esbuild 进行转译, 对于 scss 请求需要 dart-sass 转译, 直到所有的代码运行完成。</li>\n<li>webpack 模式强调打包, 打包阶段会把入口文件开始依赖分析, 最后打包出一个 main.js 交给浏览器运行, 所以浏览器运行阶段就会快很多。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>所以这里可以对 node_modules 的文件进行一个强缓存的优化, 以及通过 react-refresh 去做热更新, 避免页面刷新操作</p>\n</blockquote>\n<ol>\n<li>对性能有一定的要求\n<ul>\n<li>在其中一个项目接入时, 使用 windows 开发的同学说快是快了, 但是页面刷新的那一刻有点卡 🤔, 排查时发现这个项目 network 中发了 3000 多个 js 的请求, chrome 把 cpu 拉满了。所以 nopack 不得不又退步 😢, 只能把 node_modules 的包进行全量的预构建来达到合并更多的文件, 一下请求数降低到了 700, chrome 即使拉满了 cpu 也是短暂就下来了。所以最终 nopack 又进行了妥协, 采用了全量预构建的方式。事实证明文件请求减少页面刷新时白屏时间减少了, 预构建也只增加了 2s 左右的时间, 开发体验会更好一点。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>如果全量预构建 node_modules 还没解决该同学的问题, 我也开发了一个基于 esbuild ⚡️ 打包的开发环境开发的版本, 即像 webpack 一样, 把 src/index.js 为入口打包最后产出为一个 main.js 文件的模式, 对于这个 3分45s 的项目采用 esbuild ⚡️ 打包也仅花了 15s 左右!</p>\n</blockquote>\n<ol>\n<li>esbuild 不会对 ts 类型进行检查\n<ul>\n<li>可以参考 fork-ts-checker-webpack-plugin 实现一个插件配合 esbuild 检查\n<img src=\"https://user-images.githubusercontent.com/23253540/139782422-7bcb6645-1fc4-46b1-b5d6-facc309bddab.png\" alt=\"image\"></li>\n</ul>\n</li>\n<li>开发环境与生产环境不一致\n<ul>\n<li>esm 由于 js 文件请求过多, 页面展示的速度慢。生产环境还是得走现有的打包逻辑(文件合并, 丑化等), 开发环境与生产环境不一致可能会出现本地没有问题, 测试生产有问题的情况。</li>\n</ul>\n</li>\n</ol>\n<h3>Q: 生产环境能用上了吗 ?</h3>\n<ul>\n<li>nopack 也支持生产环境构建, 但是核心的老项目是不会使用 ⚠️⚠️⚠️ (不会为了这三分钟丢了饭碗 😨)。不过新的内部项目将会默认采用 nopack (其实这里可以用 vite 了, 为了不存在重复的工具就用 nopack 吧)。另外 nopack 生产环境打包是采用的 esbuild ⚡️ , vite 采用的是 rollup 📦 。</li>\n</ul>\n<h3>Q: esm 开发的时代是不是已经来了 ?</h3>\n<ul>\n<li>我觉得观望的同学也可以上了, 截止 2021-10-29 已经有 9 个项目接入了 nopack, 基本都是 0 改动接入运行。虽然期间暴露了各种各样的问题, 但是先驱者 vite 基本都有了各种解决方案可以进行参考。</li>\n</ul>\n<h3>Q: vite、snowpack、unbundled 这些推荐用哪个 ?</h3>\n<ul>\n<li>个人建议有 v 选 v。</li>\n</ul>\n<h2>swc、esbuild</h2>\n<p>选择编译器的时候, 调研了 swc 与 esbuild</p>\n<h3>swc</h3>\n<p>nextjs 已经实验性使用 swc。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;vercel&#x2F;next.js&#x2F;blob&#x2F;canary&#x2F;packages&#x2F;next&#x2F;build&#x2F;webpack-config.ts#L442\n\nconst getBabelOrSwcLoader = (isMiddleware: boolean) =&gt; {\n    return useSWCLoader\n      ? {\n          loader: &#x27;next-swc-loader&#x27;,\n          options: {\n            isServer: isMiddleware || isServer,\n            pagesDir,\n            hasReactRefresh: !isMiddleware &amp;&amp; hasReactRefresh,\n          },\n        }\n      : {\n      &#x2F;&#x2F; ...\n      }\n</code></pre><h3>esbuild</h3>\n<p>vite 与 snowpack 都是使用的 esbuild。</p>\n<p>目前仅发现范型函数赋值给变量编译会有问题。</p>\n<pre class=\"prettyprint\"><code>const Demo = &lt;T&gt;(num): T =&gt; {\n  return num\n}\n</code></pre><h3>测试数据</h3>\n<p>下面是 webpack 模式下测试 esbuild 与 swc 相关的测试数据</p>\n<ul>\n<li>\n<p>项目: xxx</p>\n</li>\n<li>\n<p>版本: 91a69d4e</p>\n</li>\n<li>\n<p>编译速度: 首次无缓存状态下的构建时间</p>\n<ul>\n<li>babel\n<ul>\n<li>yarn start  0.23s user 0.06s system 0% cpu 1:05.51 total</li>\n<li>yarn start  0.23s user 0.09s system 0% cpu 1:05.47 total</li>\n</ul>\n</li>\n<li>swc\n<ul>\n<li>yarn start 39.25s user 5.70s system 123% cpu 36.407 total</li>\n<li>yarn start 40.17s user 5.97s system 134% cpu 34.420 total</li>\n</ul>\n</li>\n<li>esbuild\n<ul>\n<li>yarn start 32.52s user 5.03s system 111% cpu 33.757 total</li>\n<li>yarn start 30.70s user 4.90s system 120% cpu 29.616 total</li>\n</ul>\n</li>\n<li>esbuild (ts 模式同时编译 ts、js)\n<ul>\n<li>yarn start 47.81s user 6.96s system 120% cpu 45.556 total</li>\n<li>yarn start 47.90s user 6.62s system 126% cpu 43.037 total</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>编译兼容:</p>\n<ul>\n<li>swc 编译 componets/ModalForFirstTime.js 等文件存在问题，其他路由页面表现正常。</li>\n<li>esbuild 编译 js 的装饰器不支持，故换成 ts 模式编译 js 文件，其他路由页面表现正常。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"/user/evanw\">@evanw</a> decorator spec unfortunately still seems like it’s a long way off, both based on low activity and based on how many things it looks like they still have to figure out.</p>\n</blockquote>\n<ul>\n<li>小结:\n<ul>\n<li>esbuild 与 swc 速度相差无几，但是 esbuild 对老项目的编译兼容性高于 swc。</li>\n</ul>\n</li>\n</ul>\n<h2>彩蛋</h2>\n<p>10月27日看到了字节大佬开源了基于 esbuild 的工具 unbundled, 当时还在想要是自己英语学好一点, 不用中式英语, 还指不一定也叫 unbundled 了 😄</p>\n</div>",
      "title": "巨石应用解决方案 ❌ 📦",
      "author": {
        "loginname": "xiaoxiaojx",
        "avatar_url": "https://avatars.githubusercontent.com/u/23253540?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 50,
      "country": "Eurozone"
    },
    {
      "id": "617cc80a0af06324d8c86185",
      "content": "<div class=\"markdown-text\"><p>constructor({serverAddress = “127.0.0.1:8883”, productName, deviceName, secret, clientID, storePath} <strong><em>= {}</em></strong>) 各位大神我想问一下这个构造函数的参数的最后面赋值个空括号“= {}”应该怎样理解？</p>\n</div>",
      "title": "node.js构造函数里面的参数赋一空括号是什么意思",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 51,
      "country": "China"
    },
    {
      "id": "6177990e0af0639467c85bb7",
      "content": "<div class=\"markdown-text\"><p>看这个：\n<a href=\"https://www.bilibili.com/video/bv1cR4y1n7sc\">https://www.bilibili.com/video/bv1cR4y1n7sc</a></p>\n</div>",
      "title": "低代码是真火了，夸得官方都不好意思了",
      "author": {
        "loginname": "Caluyan",
        "avatar_url": "https://avatars.githubusercontent.com/u/86812837?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 52,
      "country": "USA"
    },
    {
      "id": "5fe1368b98427e82fe6a9b02",
      "content": "<div class=\"markdown-text\"><p>对于大型互联网应用来说，面对持续增长的海量业务数据，分布式数据库架构几乎是标准配置。而如何让业务开发人员在面向分布式数据库开发时如同在同一个库中，让数据分片对应用开发人员透明，将副作用降到最低，是众多优秀程序员持续追求的目标。</p>\n<p><img src=\"//forum-assets.wuyuan.io/4/d4f4f4f4-43b7-4f80-bb3a-5243bf372dce16081992164770\" alt></p>\n<p>本文将通过一个简单实例，介绍如何使用 ShardingSphere 分片中间件，实现 Enhancer 应用对后台分布式数据库的操作。希望对您使用 Enhancer 应用管理大型分布式业务数据有所启发。</p>\n<h1>目标效果</h1>\n<p><img src=\"//forum-assets.wuyuan.io/4/336e4c0c-8fcc-42e4-9576-8be2e6c11d3216081901649150\" alt></p>\n<h1>实现步骤</h1>\n<h3>1. 准备 4 台 mysql 服务器并创建相关的实验数据库和表</h3>\n<ul>\n<li>1.1. 创建四个数据库分别命名为 user_db_0, user_db_1, user_db_2, user_db_3</li>\n<li>1.2. 在每个库中创建用户表</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>CREATE TABLE &#96;t_user&#96; (\n  &#96;id&#96; int(11) NOT NULL DEFAULT &#x27;0&#x27;,\n  &#96;name&#96; varchar(40) DEFAULT NULL,\n  &#96;gender&#96; char(1) DEFAULT NULL,\n  &#96;phone&#96; varchar(20) DEFAULT NULL,\n  &#96;address&#96; varchar(255) DEFAULT NULL,\n  &#96;created&#96; datetime DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n</code></pre><h3>2. 下载并安装 ShardingSphere</h3>\n<ul>\n<li>2.1.下载。实际上需要使用的是 ShardingSphere 的跨语言中间件产品 ShardingProxy : <a href=\"https://www.apache.org/dyn/closer.cgi/shardingsphere/5.0.0-alpha/apache-shardingsphere-5.0.0-alpha-shardingsphere-proxy-bin.tar.gz\">下载地址</a></li>\n</ul>\n<p><img src=\"//forum-assets.wuyuan.io/2/87f22edc-2146-43bb-89a8-9077fbe4ca7816081875476971\" alt></p>\n<ul>\n<li>2.2. 解压 tar 包，得到 apache-shardingsphere-xxx-shardingsphere-proxy-bin 目录。</li>\n<li>2.3. 下载 mysql 连接器 jar 包: <a href=\"https://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar\">mysql-connector-java-5.1.47.jar</a>，并将该 jar 包放入 apache-shardingsphere-xxx-shardingsphere-proxy-bin/lib 目录中。</li>\n</ul>\n<h3>3. 配置代理服务器和数据库分片规则</h3>\n<ul>\n<li>3.1 配置代理服务器 apache-shardingsphere-xxx-shardingsphere-proxy-bin/conf/server.yaml 文件，\n此文件描述了将来用作 Enhancer 工作台配置数据库连接的相关信息。注意配置文件中 <code>[xxxx]</code> （含中括号）为需要自行修改部分:</li>\n</ul>\n<pre class=\"prettyprint language-yaml\"><code>authentication:\n  users:\n    root:\n      password: [xxx]\n    [db_account_xxx]:\n      password: [xxx]\n      authorizedSchemas: user_db\n\nprops:\n  max-connections-size-per-query: 1\n  acceptor-size: 16  # The default value is available processors count * 2.\n  executor-size: 16  # Infinite by default.\n  proxy-frontend-flush-threshold: 128  # The default value is 128.\n    # LOCAL: Proxy will run with LOCAL transaction.\n    # XA: Proxy will run with XA transaction.\n    # BASE: Proxy will run with B.A.S.E transaction.\n  proxy-transaction-type: LOCAL\n  proxy-opentracing-enabled: false\n  proxy-hint-enabled: false\n  query-with-cipher-column: true\n  sql-show: false\n  check-table-metadata-enabled: false\n</code></pre><ul>\n<li>3.2 配置分片规则 apache-shardingsphere-xxx-shardingsphere-proxy-bin/conf/config-sharding.yaml 文件，此文件配置了分片数据库源信息和\nt_user 表在分布式数据库中的分片规则信息。注意配置文件中 <code>[xxxx]</code> （含中括号）为需要自行修改部分:</li>\n</ul>\n<pre class=\"prettyprint language-yaml\"><code>schemaName: user_db\n\ndataSourceCommon:\n connectionTimeoutMilliseconds: 30000\n idleTimeoutMilliseconds: 60000\n maxLifetimeMilliseconds: 1800000\n maxPoolSize: 50\n minPoolSize: 1\n maintenanceIntervalMilliseconds: 30000\n\ndataSources:\n  ds_0:\n    url: jdbc:mysql:&#x2F;&#x2F;[数据库IP地址0]:3306&#x2F;user_db_0?serverTimezone=UTC&amp;useSSL=false&amp;characterEncoding=utf8\n    username: [xxx]\n    password: [xxx]\n  ds_1:\n    url: jdbc:mysql:&#x2F;&#x2F;[数据库IP地址1]:3306&#x2F;user_db_1?serverTimezone=UTC&amp;useSSL=false&amp;characterEncoding=utf8\n    username: [xxx]\n    password: [xxx]\n  ds_2:\n    url: jdbc:mysql:&#x2F;&#x2F;[数据库IP地址2]:3306&#x2F;user_db_2?serverTimezone=UTC&amp;useSSL=false&amp;characterEncoding=utf8\n    username: [xxx]\n    password: [xxx]\n  ds_3:\n    url: jdbc:mysql:&#x2F;&#x2F;[数据库IP地址3]:3306&#x2F;user_db_3?serverTimezone=UTC&amp;useSSL=false&amp;characterEncoding=utf8\n    username: [xxx]\n    password: [xxx]\nrules:\n- !SHARDING\n  tables:\n    t_user:\n      actualDataNodes: ds_${0..3}.t_user # 配置表的实际数据节点数 0 ... n。\n      keyGenerateStrategy:\n        column: id\n        keyGeneratorName: snowflake\n  bindingTables:\n    - t_user\n  defaultDatabaseStrategy:\n    standard:\n      shardingColumn: id\n      shardingAlgorithmName: database_inline\n  defaultTableStrategy:\n    none:\n  \n  shardingAlgorithms:\n    database_inline:\n        type: INLINE\n        props:\n          algorithm-expression: ds_${id % 4}  # 使用简单的用 t_user 表的 id 字段对数据库节点数 n 求余规则来分片。\n          allow-range-query-with-inline-sharding: true\n  keyGenerators:\n    snowflake:\n      type: SNOWFLAKE\n      props:\n          worker-id: 123\n</code></pre><ul>\n<li>3.3 在 apache-shardingsphere-xxx-shardingsphere-proxy-bin 目录执行 ./bin/start.bat 或者 ./bin/start.sh 启动服务。</li>\n</ul>\n<h3>4. Enhancer 工作台配置连接 ShardingProxy，后续开发如常</h3>\n<ul>\n<li>\n<p>4.1. 在工作台-全局配置-数据库-连接中配置 3.1 所配置的数据库服务连接[用户 db_account_xxx]和[密码 password]，地址为 apache-shardingsphere-xxx-shardingsphere-proxy-bin 所在的机器地址，若在本机则填写为 127.0.0.1，端口号为 <code>3307</code>, 库名为 user_db。\n<img src=\"//forum-assets.wuyuan.io/2/87f22edc-2146-43bb-89a8-9077fbe4ca7816081875478612\" alt></p>\n</li>\n<li>\n<p>4.2. 在工作台-页面管理中创建一个页面，添加一个窗口组件 enhancer-jqgrid, 配置绑定 SQL：</p>\n</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>SELECT * FROM t_user\n</code></pre><h2>至此，保存后可以运行起来查看效果，后续相关开发如常。</h2>\n<h3>结语</h3>\n<p>本例仅仅是实现了对单一表的分片增、删、改、查操作。在分布式数据库实战业务开发中，对于一些复杂场景，尤其是在金融级数据强完整性、强一致性、强可用性的要求下，分片中间件并不能做到完全对应用开发层透明，比如多个大表跨数据库 join, 分布式事务等等。此时一般需要通过应用层合理设计，来补偿或者规避这些问题（比如支付宝不允许你跨年查账，也不会提供一个界面同时呈现总账和明细账，需要用户分多次多层点开逐步呈现）。对于已经采用 IOE 结构实现的大规模金融级应用来说，在不改动应用层的情况下就实现去 IOE，还有很长的路要走。而对于一般电商、社交级互联网应用使用 Enhancer + ShardingSphere 来实现对分布式数据库的管理，会是一个不错的选择。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://shardingsphere.apache.org/document/current/en/user-manual/shardingsphere-proxy/configuration/data-source/\">ShardingProxy 配置手册</a></li>\n<li><a href=\"https://shardingsphere.apache.org/document/current/en/features/sharding/\">数据库分片概念原理</a></li>\n<li><a href=\"https://wuyuan.io\">无远开发平台</a></li>\n</ul>\n</div>",
      "title": "Enhancer + ShardingSphere 实现分布式数据库应用开发",
      "author": {
        "loginname": "jquery",
        "avatar_url": "https://avatars2.githubusercontent.com/u/3049683?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 53,
      "country": "USA"
    },
    {
      "id": "60e25b8cba74602248862373",
      "content": "<div class=\"markdown-text\"><p>同上,各位老铁 Nestjs很火吗?为什么Star量以及每周下载量如此之高,这个框架国内用的多吗?</p>\n<p><img src=\"//static.cnodejs.org/FlKGhyRfHXLrr6bUlreNJUEF6U65\" alt=\"nestjs.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FoYcKcGW5iRUnxoPryjmqyrzRWcI\" alt=\"nest1.jpg\"></p>\n<p>同上,各位老铁 Nestjs很火吗?为什么Star量以及每周下载量如此之高,这个框架国内用的多吗?</p>\n</div>",
      "title": "Nestjs很火吗?为什么Star量以及每周下载量如此之高",
      "author": {
        "loginname": "wuwangju0",
        "avatar_url": "https://avatars.githubusercontent.com/u/64194964?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 54,
      "country": "Japan"
    },
    {
      "id": "617202f8dfe3c9f914f2bff4",
      "content": "<div class=\"markdown-text\"><h2>想下载时让显示进度条，但是我的不显示，连 console.log(ProgressEvent);都没有反映，可能没有触发？\n帮忙看看是哪里问题，代码在下面。\n\t   有下载就是看不到下载进度条。\n\t   给看看发给你50元的红包，吃屯饭。\n\t   会的联系我，发你红包QQ: 23-56-404-766（去年横线）</h2>\n<pre class=\"prettyprint\"><code>var axios = require(&#x27;axios&#x27;);\nvar fs = require(&#x27;fs&#x27;)\n\nlet ws = fs.createWriteStream(&#x27;.&#x2F;allimg&#x2F;atu.exe&#x27;)\naxios({\n\turl:&#x27;http:&#x2F;&#x2F;download.skycn.com&#x2F;hao123-soft-online-bcs&#x2F;soft&#x2F;2017_02_22_BaiduPlayer5Setup_5.exe&#x27;,\n\tresponseType:&#x27;stream&#x27;,\n\t  onDownloadProgress:function(ProgressEvent){\n\t  console.log(ProgressEvent);\n\t  var progress = Math.round(ProgressEvent.loaded &#x2F; ProgressEvent.total * 100) + &#x27;%&#x27;;\n\t  console.log(progress);\n\t  &#x2F;&#x2F; 进度完成之后\n\t  &#x2F;&#x2F; if(progress == 100){\n\t  \t&#x2F;&#x2F;...\n\t  &#x2F;&#x2F; }\n\t\t}\t\t\n\n}).then(res=&gt;{\n\tconsole.log(res.headers)\n\t      res.data.pipe(ws)\n          &#x2F;&#x2F; &#x2F;&#x2F;关闭写入流\n          &#x2F;&#x2F; res.data.on(&#x27;close&#x27;,function(){\n          &#x2F;&#x2F;   ws.close()\n          &#x2F;&#x2F; })\n})\n</code></pre></div>",
      "title": "axios 进度条不显示，发个红包给你",
      "author": {
        "loginname": "zhimeng2022",
        "avatar_url": "https://avatars.githubusercontent.com/u/92935544?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 55,
      "country": "USA"
    },
    {
      "id": "6174f7af0af0638e55c856ef",
      "content": "<div class=\"markdown-text\"><h1>Seneca &amp; Express 构建微服务中文件上传的问题</h1>\n<h3>问题描述</h3>\n<p>基于Seneca &amp; Express 技术栈，个人准备弄一个文件存储相关的服务，其中包括了文件上传的功能。通常在只基于Express框架的实现中，常用到multer、multiparty等第三方库用于解析“multipart/form-data”这种类型的数据。然而我将Seneca &amp; Express 组合至一起，在搭配上multer 或者 multiparty来解析“multipart/form-data”的数据时，当请求通过了解析“multipart/form-data”类型的中间件之后，请求无法传递至seneca的函数中进行处理。代码示例如下</p>\n<h5>file-service.js  启动文件相关微服务入口</h5>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; file-service.js 启动文件相关微服务入口\nconst path = require(&quot;path&quot;);\nconst Express = require(&quot;express&quot;);\nconst Seneca = require(&quot;seneca&quot;);\nconst BodyParser = require(&#x27;body-parser&#x27;);\nconst multiparty = require(&#x27;multiparty&#x27;);\nconst Web = require(&#x27;seneca-web&#x27;);\nconst ExpressAdapter = require(&#x27;seneca-web-adapter-express&#x27;);\nconst uploadAPI = require(&#x27;.&#x2F;api&#x2F;upload&#x27;);\nconst seneca = Seneca();\nconst app = Express();\n\napp.use(BodyParser.json());\napp.use(BodyParser.urlencoded());\nconst routes = [\n    {\n        pin:&quot;role:api,cmd:*&quot;,\n        prefix:&quot;&#x2F;file&#x2F;api&quot;,\n        map:{uploadFile:{POST:true }}\n    }\n]\nlet form = new multiparty.Form({ uploadDir: path.join(__dirname,&quot;uploads&quot;) })\napp.use(&quot;&#x2F;file&#x2F;api&#x2F;uploadFile&quot;,(req,res,next)=&gt;{\n    form.parse(req, (err, fields, files) =&gt; {\n        if (err) {\n            next(err);\n        }\n        next();\n\t\t&#x2F;&#x2F;文件正常处理，之后还能被Express的其他中间件处理。\n    })\n})\nconst webConfig = {\n    routes: routes,\n    adapter: ExpressAdapter,\n    context: app\n}\nseneca\n    .use(Web, webConfig)\n    .use(uploadAPI)\n    .ready(() =&gt; {\n        var server = seneca.export(&#x27;web&#x2F;context&#x27;)();\n        server.listen(&#x27;9001&#x27;, () =&gt; {\n            console.log(&#x27;server started on:9001&#x27;);\n        })\n    })\n</code></pre><h5>upload.js  向seneca中添加服务</h5>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; upload.js 向seneca中添加服务\nmodule.exports = function uploadAPI(options) {\n    this.add({ &#x27;role&#x27;: &#x27;api&#x27;, &#x27;cmd&#x27;: &#x27;uploadFile&#x27; }, (msg, done) =&gt; {\n\t\t&#x2F;&#x2F;请求无法传达到此处\n        console.log(msg.request$.query);\n        console.log(msg.request$.body);\n        console.log(msg.request$.file);\n        done(null, { &#x27;success&#x27;: true, &#x27;msg&#x27;: &#x27;调用成功&#x27;, data: {} });\n    })\n}\n</code></pre><h6>测试基本情况</h6>\n<ol>\n<li>文件能正常上传，经过文件上传相关的中间处理后能继续被Express请求链上的其他中间件继续处理，但是无法被seneca中的服务处理。</li>\n<li>如果不使用文件上传的中间件，请求能直接通过，经过seneca中的服务处理后返回。</li>\n</ol>\n<h3>备注</h3>\n<ol>\n<li>以上代码从实际代码中截取，稍微修改，可能正常运行需要调试。</li>\n<li>个人对于seneca以及express框架并没有太多深入理解过，表述可能不太清楚或者有误的地方希望各位指出。</li>\n</ol>\n</div>",
      "title": "Seneca + Express 构建的微服务中文件上传的问题",
      "author": {
        "loginname": "Sekaiiiii",
        "avatar_url": "https://avatars.githubusercontent.com/u/42423235?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 56,
      "country": "USA"
    },
    {
      "id": "617697a20af0638a5fc859f9",
      "content": "<div class=\"markdown-text\"><p>不是mvvm组件，　页面结构是分离的　比如页面布局三栏column<br>\ncol-1 生成图表，　col-2是输入数据的格式规则，说明　　col-3是　form表单</p>\n</div>",
      "title": "怎么样实现实时预览表单",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 57,
      "country": "China"
    },
    {
      "id": "605da2e85ac88c2dd115b429",
      "content": "<div class=\"markdown-text\"><p>0基础就可以学的nodejs教程，教程包括Nodejs基础，Nodejs手写一个express框架 ，Express使用，Mongodb使用，Mongoose等。</p>\n<p>B站地址：<a href=\"https://www.bilibili.com/video/av38925557/?p=1\">https://www.bilibili.com/video/av38925557/?p=1</a></p>\n<p>视频源码下载地址： <a href=\"https://pan.baidu.com/s/1L5SAAj0sRiX80xBPwMXmxA\">https://pan.baidu.com/s/1L5SAAj0sRiX80xBPwMXmxA</a>    提取码：abcd</p>\n<p>谁说Nodejs每人学我和谁急眼</p>\n<p><strong>教程包括：</strong></p>\n<p>其中包括Nodejs安装配置、Nodejs内置模块、Nodejs自定义模块、Nodejs第三方模块、npm包管理、Nodejs新特性 async await 、以及Nodejs创建web服务、模板引擎、NodeJs封装一个自己的Express框架、MongoDB安装、MongoDB增删改查、MongoDB索引、MongoDB权限管理、MongoDB聚合管道、MongoDB aggregate聚合管道 多表关联查询、Nodejs操作mongodb数据库、Express介绍、Express路由、Express Ejs 、Express Cookie、Express Session、Express Restfull APi、Express 上传图片、 Mongoose的安装、mongoose增删改查、mongoose默认参数 、mongoose模块化、Mongoose 预定义模式修饰符、自定义修饰符、Mongoose索引、扩展Mongoose内置查询方法、Mongoose 数据校验、Mongoose两个表关联查询aggregate、MongooseN个表关联查询aggregate、Mongoose、 DBRef  Populate、以及Express+Mongoose实战</p>\n</div>",
      "title": "40万人在学的Nodejs+Express+mongoose教程-B站免费看 源码免费下 谁说Node不火",
      "author": {
        "loginname": "phonegap100",
        "avatar_url": "https://avatars.githubusercontent.com/u/5773766?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 58,
      "country": "USA"
    },
    {
      "id": "61761c040af0636ffec858b9",
      "content": "<div class=\"markdown-text\"><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/188fe599ed124cc9b9a7789744f5a3ed~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<blockquote>\n<p>前言：日常开发中，好的工具往往能让我们事半功倍，有句老话说得好：工欲善其事，必先利其器。使用高效率的工具可以极大提升我们的开发效率。接下来分享下树酱平时开发中经常使用的一些效率工具</p>\n</blockquote>\n<h3>1 📁本地化工具篇</h3>\n<h4>1.1 Apifox</h4>\n<blockquote>\n<p>官方介绍: API 文档、调试、Mock、测试一体化协作平台。Apifox = Postman + Swagger + Mock + JMeter。<a href=\"https://www.apifox.cn\">官网地址</a></p>\n</blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/007591f341f6464fa0a0d6f835fc88ec~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<p>推荐理由：</p>\n<ul>\n<li>对于前端：拿来做mock mock出来的数据很人性化</li>\n<li>对于后端：拿来做调试 postmam的功能完全具备并支持自动校验数据结构</li>\n<li>对于测试：拿来做接口自动化测试 可视化配置断言功能杠杠的</li>\n<li>对于团队：一体化协同工具 打通前端、后端及测试研发闭环</li>\n</ul>\n<h4>1.2 Utools</h4>\n<blockquote>\n<p>官方介绍：uTools 是一个极简、插件化的现代桌面软件，通过自由选配丰富的插件，打造得心应手的工具集合。通过快捷键就可以快速呼出这个搜索框，统一的设计风格和操作方式，助你高效的得到结果。<a href=\"https://u.tools/\">官网地址</a></p>\n</blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5dfbb00f45147bf9dd712f2003353f0~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<p>推荐理由：</p>\n<ul>\n<li>丰富的插件中心： 每个插件解决一个具体场景的问题，简洁易用、随用随走</li>\n<li>多功能输入框： 支持文本、截图、图片、文件、文件夹</li>\n</ul>\n<h4>1.3 iTerm2</h4>\n<blockquote>\n<p>官方介绍：iTerm2 是终端的替代品，也是 iTerm 的继任者。它适用于 Mac 与 macOS 10.14 或较新的。iTerm2 将终端带入现代，具有您从来不知道自己一直想要的功能。 <a href=\"https://iterm2.com/\">官网链接</a></p>\n</blockquote>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74cb5a442cd54003acc01a32eff8829c~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<p>推荐理由：</p>\n<ul>\n<li>可以打造美观高效的 Mac 终端</li>\n<li>支持分屏！</li>\n</ul>\n<h4>1.4 Zsh</h4>\n<blockquote>\n<p>介绍：Zsh是一个Linux下强大的shell工具,是bash替代品中表现最佳的一个。跟Bash相比，Zsh的补全功能很强大，可以自动补全命令、参数、文件名、进程、用户名、变等等，同时还支持插件扩展，能支持更多功能方便我们高效使用 <a href=\"https://ohmyz.sh/\">官网链接</a></p>\n</blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5160927a794b4be6a8c4b0410ac8970c~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<p>推荐理由：</p>\n<ul>\n<li>支持命令提示与智能补全</li>\n<li>支持快速与自动跳转</li>\n</ul>\n<h4>1.5 Charles</h4>\n<blockquote>\n<p>介绍：最好用的抓包工具。 Charles 是一个支持多平台的 HTTP 代理器、HTTP 监控、反向代理器。它能够让开发者查看本地机器与互联网之间的所有 HTTP 以及 SSL/HTTPS 传输数据。<a href=\"https://www.charlesproxy.com/\">官方地址</a></p>\n</blockquote>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef93dc6413154a07ba1b023e03df45b1~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<h4>1.6 SourceTree</h4>\n<blockquote>\n<p>介绍：SourceTree 是非常好用的 Git 图形界面工具，它是由Atlassian开发的免费Git图形界面工具，可以操作任何 Git 库。如果你习惯使用命令行操作 Git，请忽略。<a href=\"https://www.sourcetreeapp.com/\">官网地址</a></p>\n</blockquote>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f6dcd04ce7a47b98a62e0611fd4c3fc~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<p>github与sourceTree什么区别？</p>\n<p>sourcetree是一个git的GUI客户端，类似svn时代的TortoiseSVN。而github是一个代码托管平台，使用git提供版本控制服务。</p>\n<h4>1.7 Tampermonkey 油猴脚本</h4>\n<blockquote>\n<p>介绍：Tampermonkey中文名俗称油猴，是一款免费的浏览器扩展和最为流行的用户脚本管理器是一款免费的浏览器插件，用户可以通过油猴添加和使用脚本。通过这些脚本，可以实现视频解析、音乐下载、网盘直连解析、屏蔽网站广告等等功能 <a href=\"https://www.tampermonkey.net/\">官网地址</a></p>\n</blockquote>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d4558d27ea44ebd8c384f88d1f7a253~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<h4>1.8 Typora</h4>\n<blockquote>\n<p>介绍：Typora 是一款支持实时预览的 Markdown 文本编辑器。简洁易用，相信你用了就爱了！<a href=\"https://typora.io/\">官网地址</a></p>\n</blockquote>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59899f87e9294f75a910f31382a3a73f~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<h4>1.9 Alfred</h4>\n<blockquote>\n<p>官方介绍：Alfred 是 macOS 屡获殊荣的应用程序，通过热键、关键字、文本扩展等提高您的效率。搜索您的 Mac 和 Web，通过自定义操作来控制您的 Mac，并提高效率。<a href=\"https://www.alfredapp.com\">官网地址</a></p>\n</blockquote>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24396c0a16e541efa87c9c439b9f12d8~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<h4>1.10 Dash</h4>\n<blockquote>\n<p>官方介绍：Dash 可让您的 Mac 即时离线访问 200+ API 文档集。<a href=\"https://kapeli.com/dash\">官方地址</a></p>\n</blockquote>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95a27d1872c74a0ca85b59feeb9f3492~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<p>推荐理由：</p>\n<ul>\n<li>离线文档查阅：快速方便的 API 索引，包含 JavaScript、React 等语言及库的文档</li>\n</ul>\n<h3>2 📘 在线工具篇</h3>\n<h4>2.1 CodeLF</h4>\n<blockquote>\n<p>变量命名神器。CodeLF 通过搜索在线开源平台Github, Bitbucket, Google Code, Codeplex, Sourceforge, Fedora Projec的项目源码，帮开发者从中找出已有的匹配关键字的变量名。\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91f1c82750a644b3ac1a509fc40c494b~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n</blockquote>\n<p>推荐理由：</p>\n<ul>\n<li>可以帮助开发者从中（Github, Bitbucket, Google Code等）找出已有的匹配关键字的变量名</li>\n<li>支持VScode编辑器里的插件</li>\n</ul>\n<h4>2.2 npm.devtool.tech</h4>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/339a1659571b44aa892da05501862d7b~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<p>推荐理由：</p>\n<ul>\n<li>最直观的查看流行的 npm 包</li>\n<li>可以在控制台直接调用调试某个npm包</li>\n<li>上传 package.json 查看该项目的技术栈，你可以层层递进点进去，了解各个依赖 package 的用途</li>\n</ul>\n<h4>2.3 Codesandbox</h4>\n<blockquote>\n<p>官方介绍：即时准备的全功能在线 IDE，用于使用浏览器的任何设备上的 Web 开发。</p>\n</blockquote>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a7c49292563490e90eb877899e6cb85~tplv-k3u1fbpfcp-watermark.image?\" alt></p>\n<p>推荐理由:</p>\n<ul>\n<li>快速开始：拥有所有流行框架的模板比如vue、react，方便你快速创建项目以及试验代码和想法</li>\n</ul>\n<h3>3 最后</h3>\n<blockquote>\n<p>如果你有其他效率工具推荐，欢迎你在评论区留言！ 有想了解更多协作工具的同学，可以阅读树酱的之前一篇1200赞的文章：<a href=\"https://juejin.cn/post/6844904176330375181\">聊聊前端开发日常的协作工具(全)</a></p>\n</blockquote>\n</div>",
      "title": "聊聊开发日常的效率提升工具（全）",
      "author": {
        "loginname": "littleTreeme",
        "avatar_url": "https://avatars.githubusercontent.com/u/62824719?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 59,
      "country": "China"
    },
    {
      "id": "6176626a0af063249ac85984",
      "content": "<div class=\"markdown-text\"><p>关注<a href=\"https://github.com/simon9124/my_demos/blob/master/README.md\">前端小讴</a>，阅读更多原创技术文章</p>\n<p><a href=\"https://cnodejs.org/topic/6165274cfe0c51db3baee418\">回顾：Promise源码渐进式解读（一）</a>\n<a href=\"https://cnodejs.org/topic/6167df78dfe3c92f44f2b131\">回顾：Promise源码渐进式解读（二）</a>\n<a href=\"https://cnodejs.org/topic/616d1aa1dfe3c9ee04f2b7d5\">回顾：Promise源码渐进式解读（三）</a>\n<a href=\"https://cnodejs.org/topic/616fe2e1dfe3c98e36f2bd12\">回顾：Promise源码渐进式解读（四）</a></p>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97/javascript/Promise/Promise%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81%2B%E6%B3%A8%E9%87%8A.js\">完整代码+注释</a>，可对照阅读</p>\n<p><code>Promise</code>源码解读系列的最后 1 篇，详解<code>Promise</code>构造函数的最后几个方法及<code>.finally</code>，封装<code>isArray</code>判断对象是否为数组：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;* isArray方法：判断对象是否为数组 *&#x2F;\nfunction isArray(x) {\n  return Boolean(x &amp;&amp; typeof x.length !== &#x27;undefined&#x27;)\n}\n</code></pre><h2>Promise.all - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Promise构造函数的all属性，指向函数\n * 参数arr：数组\n *&#x2F;\nPromise.all = function (arr) {\n  &#x2F;&#x2F; 返回一个新期约\n  return new Promise(function (resolve, reject) {\n    if (!isArray(arr)) {\n      return reject(new TypeError(&#x27;Promise.all accepts an array&#x27;)) &#x2F;&#x2F; 参数必须是数组\n    }\n    var args = Array.prototype.slice.call(arr) &#x2F;&#x2F; Array原型的slice方法，利用call绑定给arr（避免有自定义的slice方法）\n    if (args.length === 0) return resolve([]) &#x2F;&#x2F; 若数组长度为0，则立即执行执行器函数并返回，参数为空数组\n    &#x2F;&#x2F; ↑相当于：new Promise((resolve, reject) =&gt; resolve([]))\n\n    var remaining = args.length\n\n    &#x2F;**\n     * res()方法\n     * 参数i：数组下标\n     * 参数val：数组项\n     *&#x2F;\n    function res(i, val) {\n      try {\n        &#x2F;&#x2F; console.log(args[i], val) &#x2F;&#x2F; args[i]和val最初是一样的\n\n        &#x2F;* 如果该项为对象或函数对象，则对其then属性做特殊处理 *&#x2F;\n        if (val &amp;&amp; (typeof val === &#x27;object&#x27; || typeof val === &#x27;function&#x27;)) {\n          var then = val.then\n          &#x2F;&#x2F; 如果then指向一个函数（val是Promise类型或thenable对象），则做处理\n          if (typeof then === &#x27;function&#x27;) {\n            &#x2F;* 将该项的then方法体内的this指向该项本身，并执行then()\n               Promise.prototype.then原本接受2个参数onFulfilled和onRejected，将function(val){}和reject回调分别作为这两个方法传给.then()\n                -&gt; 创建Handler实例（this指向then前的Promise实例，即该项本身）\n                -&gt; 调用handle方法，根据_state进行下一步操作\n                  -&gt; 如_state为1，则调用Promise._immediateFn \n                  -&gt; 调用onFulfilled（即function(val)），参数为期约的_value值，即调用function(self._value)\n                  （若_state为0，则将Handler实例放入then()前Promise实例（该项本身）的_deferrends数组，同步执行暂停，整端代码执行终止，返回该项，即待定的期约）\n            *&#x2F;\n            then.call(\n              val,\n              function (val) {\n                res(i, val) &#x2F;&#x2F; 将期约的_value值作为val，再次调用res方法\n              },\n              reject\n            )\n            return\n          }\n        }\n\n        &#x2F;* 重写该项：若该项为解决的期约则被重写为其解决值&#x2F;拒绝理由，若为非期约则不变 *&#x2F;\n        args[i] = val\n        &#x2F;&#x2F; console.log(args[i], val)\n        &#x2F;&#x2F; console.log(args)\n\n        &#x2F;* 若所有的Promise都执行完毕（没有待定的），则执行执行器函数的resolve回调，参数为处理后的数组 *&#x2F;\n        if (--remaining === 0) {\n          resolve(args) &#x2F;&#x2F; doResolve()内部的done控制着resolve&#x2F;reject方法只执行一次\n        }\n      } catch (ex) {\n        &#x2F;* 只要其中一项出现异常，则全部执行退出，进入catch异常处理 *&#x2F;\n        reject(ex) &#x2F;&#x2F; doResolve()内部的done控制着resolve&#x2F;reject方法只执行一次\n      }\n    }\n\n    &#x2F;* 循环数组，针对每一项执行res()方法 *&#x2F;\n    for (var i = 0; i &lt; args.length; i++) {\n      res(i, args[i])\n    }\n  })\n}\n</code></pre><ul>\n<li><strong>参数</strong>必须是<strong>数组</strong>，若为<strong>空数组</strong>则等同于<code>new Promise((resolve, reject) =&gt; resolve([]))</code></li>\n<li>循环参数数组，若数组项为解决的期约，则被重写为其解决值/拒绝理由，若为非期约则不变</li>\n<li>若所有的<code>Promise</code>都执行完毕（没有待定的），则执行执行器函数的<code>resolve</code>回调，参数为处理后的数组\n<ul>\n<li>若有待定的期约，则会一直等待，直到执行完毕</li>\n</ul>\n</li>\n<li>只要其中一项出现异常，则全部执行退出，进入<code>catch</code>异常处理</li>\n</ul>\n<h2>Promise.all - 阶段测试</h2>\n<pre class=\"prettyprint language-js\"><code>setTimeout(\n  console.log,\n  0,\n  Promise.all(), &#x2F;&#x2F; 参数不是数组\n  &#x2F;* Promise { _state: 2, _handled: false, _value: &#x27;TypeError: Promise.all accepts an array&#x27;, _deferreds: null } *&#x2F;\n  Promise.all([]), &#x2F;&#x2F; 参数是空数组\n  &#x2F;* Promise { _state: 1, _handled: false, _value: [], _deferreds: null } *&#x2F;\n  new Promise((resolve, reject) =&gt; resolve([])), &#x2F;&#x2F; 等效于Promise.all([])\n  Promise.all([1, 2, 3]), &#x2F;&#x2F; 参数是数组，数组的每项不是Promise对象\n  &#x2F;* Promise { _state: 1, _handled: false, _value: [ 1, 2, 3 ], _deferreds: null } *&#x2F;\n  Promise.all([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]), &#x2F;&#x2F; 参数是数组，数组的每项是解决的Promise对象\n  &#x2F;* Promise { _state: 1, _handled: false, _value: [ 1, 2, 3 ], _deferreds: null } *&#x2F;\n  Promise.all([\n    Promise.resolve(true),\n    Promise.resolve(true),\n    Promise.resolve(true),\n  ]),\n  &#x2F;* Promise { _state: 1, _handled: false, _value: [true, true, true], _deferreds: null } *&#x2F;\n  Promise.all([Promise.resolve(1), Promise.reject(2), Promise.resolve(3)]), &#x2F;&#x2F; 参数是数组，数组中有拒绝的Promise对象\n  &#x2F;* Promise { _state: 2, _handled: false, _value: 2, _deferreds: null } *&#x2F;\n  Promise.all([Promise.resolve(1), new Promise(() =&gt; {}), Promise.resolve(3)]) &#x2F;&#x2F; 参数是数组，数组中有待定的Promise对象\n  &#x2F;* Promise { _state: 0, _handled: false, _value: undefined, _deferreds: null } *&#x2F;\n)\n</code></pre><h2>Promise.race - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Promise构造函数的race属性，指向函数\n * 参数arr：数组\n *&#x2F;\nPromise.race = function (arr) {\n  &#x2F;&#x2F; 返回一个新期约\n  return new Promise(function (resolve, reject) {\n    if (!isArray(arr)) {\n      return reject(new TypeError(&#x27;Promise.race accepts an array&#x27;)) &#x2F;&#x2F; 参数必须是数组\n    }\n    &#x2F;* 循环数组，针对每一项执行resolve()和.then()方法（若参数为空数组，则不执行，返回待定的期约） *&#x2F;\n    for (var i = 0, len = arr.length; i &lt; len; i++) {\n      &#x2F;**\n       * Promise.resolve()方法\n       * 参数arr[i]：数组项\n       *&#x2F;\n      Promise.resolve(arr[i]) &#x2F;&#x2F; 返回新期约\n        &#x2F;* Promise.prototype.then()方法\n           Promise.prototype.then原本接受2个参数onFulfilled和onRejected，将fn的resolve和reject回调分别作为这两个方法传给.then()\n           -&gt; 创建Handler实例（this指向then前的Promise实例，即Promise.resolve()返回的新期约）\n           -&gt; 调用handle方法，根据_state进行下一步操作\n              -&gt; 如_state为1，则调用Promise._immediateFn\n              -&gt; 调用onFulfilled，参数为期约的_value值，即调用function(self._value)\n        *&#x2F;\n        .then(resolve, reject) &#x2F;&#x2F; doResolve()内部的done控制着resolve&#x2F;reject方法只执行一次，因此只有最先落定（解决或拒绝）的Promise执行了resolve&#x2F;reject，后面的Promise都不执行\n    }\n  })\n  &#x2F;&#x2F; 以Promise.race([3, 2, 1])为例，可以简化为new Promise((resolve,reject)=&gt;{Promise.resolve(3).then(resolve, reject)})\n}\n</code></pre><ul>\n<li><strong>参数</strong>必须是<strong>数组</strong>，若为<strong>空数组</strong>则<strong>返回待定的期约</strong></li>\n<li>循环参数数组，按顺序调用<code>Promise.resolve</code>，参数为数组项</li>\n<li>只有最先落定（解决或拒绝）的<code>Promise</code>，根据其状态执行<code>resolve/reject</code>，后面的都不执行</li>\n<li><strong>核心思路比对</strong>：\n<ul>\n<li><code>Promise.all</code>：<code>resolve</code>数组所有项（如果该项是期约，则用其解决值/拒绝理由替换）</li>\n<li><code>Promise.race</code>：逐个<code>Promise.resolve</code>数组项（如果返回的期约已解决/拒绝，则不再<code>Promise.resolve</code>后面的项）</li>\n</ul>\n</li>\n</ul>\n<h2>Promise.race - 阶段测试</h2>\n<pre class=\"prettyprint language-js\"><code>setTimeout(\n  console.log,\n  0,\n  Promise.race(), &#x2F;&#x2F; 参数不是数组\n  &#x2F;* Promise { _state: 2, _handled: false, _value: &#x27;TypeError: Promise.race accepts an array&#x27;, _deferreds: null } *&#x2F;\n  Promise.race([]), &#x2F;&#x2F; 参数是空数组\n  &#x2F;* Promise { _state: 0, _handled: false, _value: undefined, _deferreds: null } *&#x2F;\n  Promise.race([3, 2, 1]), &#x2F;&#x2F; 参数是数组，数组的每项不是Promise对象\n  &#x2F;* Promise { _state: 1, _handled: false, _value: 3, _deferreds: null } *&#x2F;\n  Promise.resolve(3), &#x2F;&#x2F; 等效于Promise.race([3, 2, 1])\n  &#x2F;* Promise { _state: 1, _handled: false, _value: 3, _deferreds: null } *&#x2F;\n  Promise.race([Promise.resolve(3), Promise.resolve(2), Promise.resolve(1)]), &#x2F;&#x2F; 参数是数组，最先落定解决的Promise对象\n  &#x2F;* Promise { _state: 1, _handled: false, _value: 3, _deferreds: null } *&#x2F;\n  Promise.race([Promise.reject(1), Promise.resolve(2), Promise.resolve(3)]), &#x2F;&#x2F; 参数是数组，最先落定拒绝的Promise对象\n  &#x2F;* Promise { _state: 2, _handled: false, _value: 1, _deferreds: null }\n     Possible Unhandled Promise Rejection: 1 *&#x2F;\n  Promise.race([new Promise(() =&gt; {}), Promise.resolve(2), Promise.resolve(1)]) &#x2F;&#x2F; 参数是数组，最先落定解决的Promise对象\n  &#x2F;* Promise { _state: 1, _handled: false, _value: 2, _deferreds: null } *&#x2F;\n)\n</code></pre><h2>Promise.prototype.finally - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Promise原型的finally属性，指向函数\n * 参数callback：onFinally处理程序，在期约无论兑现还是拒绝后，最终执行的回调\n *&#x2F;\nPromise.prototype[&#x27;finally&#x27;] = function (callback) {\n  &#x2F;&#x2F; console.log(this, &#x27;finally&#x27;) &#x2F;&#x2F; this指向finally()前返回的Promise实例\n  &#x2F;&#x2F; console.log(this.constructor) &#x2F;&#x2F; constructor指向Promise构造函数\n  &#x2F;&#x2F; console.log(this.constructor === Promise) &#x2F;&#x2F; true\n  var constructor = this.constructor\n\n  &#x2F;* 调用Promise.prototype.then()方法，以下文setTimeout中的测试为例：\n     -&gt; 创建Handler实例（this指向finally()前的Promise实例），创建新Promise实例\n     -&gt; 调用handle()，_state为1，调用Promise._immediateFn，调用onFulfilled，调用后返回Promise实例（调用过程见onFulfilled内部）\n     -&gt; 调用resolve()，传入Handler实例的promise和onFulfilled返回值（是一个Promise实例），将_state赋值为3，_value赋值为onFulfilled返回的Promise实例\n     -&gt; 调用finale()，其_deferreds为[]，赋为null后执行结束\n     -&gt; 返回.then()内部创建的Promise实例：\n        Promise { \n          _state: 3,\n          _handled: false,\n          _value: Promise {\n            _deferreds: null,\n            _handled: false,\n            _state: 1,\n            _value: 2,\n          }\n          _deferreds: null\n        }\n  *&#x2F;\n  return this.then(\n    &#x2F;* onFulfilled处理程序 *&#x2F;\n    function (value) {\n      &#x2F;* 调用过程，以下文setTimeout中的测试为例：\n        -&gt; 调用callback，打印finally3，返回3\n        -&gt; 调用Promise.resolve()，创建解决的Promise实例，解决值为callback返回值3\n           此时then前的Promise实例为：Promise { _state: 1, _handled: false, _value: 3, _deferreds: null }\n        -&gt; 调用.then()（内部this指向Promise.resolve()返回的期约，_state为1，_value为3），创建Handler实例（只有onFulfilled），创建新Promise实例\n        -&gt; 调用handle()，内部state为1，将handled置为true，调用Promise._immediateFn，调用onFulfilled（即：function() {return value}），返回的value是finally前Promise实例的_value，即2\n        -&gt; 调用resolve()，传入Handler实例的promise和onFulfilled返回值2，将_state赋值为1，_value赋值为2\n        -&gt; 调用finale()，其_deferreds为[]，赋为null后执行结束\n        -&gt; 返回.then()内部创建的Promise实例（作为参数，传递给上层resolve()方法）\n           返回的Promise实例为：Promise { _state: 1, _handled: false, _value: 2, _deferreds: null }\n      *&#x2F;\n      &#x2F;&#x2F; return constructor.resolve(callback())\n      return constructor.resolve(callback()).then(function () {\n        &#x2F;&#x2F; console.log(value) &#x2F;&#x2F; finally()前返回的Promise实例的解决值\n        return value\n      })\n    },\n    &#x2F;* onRejected处理程序 *&#x2F;\n    function (reason) {\n      return constructor.resolve(callback()).then(function () {\n        &#x2F;&#x2F; console.log(reason) &#x2F;&#x2F; finally()前返回的Promise实例的拒绝理由\n        return constructor.reject(reason) &#x2F;&#x2F; 与onFulfilled不同的是，内部返回拒绝的期约，拒绝理由为finally()前Promise实例的拒绝理由\n        &#x2F;* \n          Promise._immediateFn最后一步均为调用resolve()方法，第二个参数若不是期约，则_state值会在resolve()中被赋为1\n          因此为了区分与onFulfilled的区别，返回拒绝的期约（而不是拒绝理由），第二个参数是期约，_state值在resolve()中被赋为3\n          因此最终返回的期约，会多嵌套一层Promise（onFulfilled嵌套2层，onRejected嵌套3层），最内层为这个拒绝的期约\n          Promise { \n            _state: 3,\n            _handled: false,\n            _value: Promise {\n              _deferreds: null,\n              _handled: false,\n              _state: 3,\n              _value: Promise { &#x2F;&#x2F; 最内层为拒绝的期约\n                _deferreds: null,\n                _handled: false,\n                _state: 2, &#x2F;&#x2F; 此处的_state\n                _value: 2\n              }\n            }\n            _deferreds: null\n          }\n        *&#x2F;\n      })\n    }\n\n    &#x2F;* 内层Promise实例赋给外层Promise实例的_value，逐层依次赋值递推 *&#x2F;\n  )\n}\n</code></pre><h2>Promise.prototype.finally - 阶段测试</h2>\n<pre class=\"prettyprint language-js\"><code>setTimeout(\n  console.log,\n  0,\n  Promise.resolve(2).finally(() =&gt; {\n    console.log(&#x27;finally3&#x27;) &#x2F;&#x2F; 打印&#x27;finally3&#x27;\n    return 3\n  })\n  &#x2F;* Promise为\n    Promise {\n      _state: 3,\n      _handled: false,\n      _value: Promise {\n        _state: 0,\n        _handled: false,\n        _value: undefined,\n        _deferreds: null\n      },\n      _deferreds: null\n    }\n  *&#x2F;\n  Promise.reject(2).finally(() =&gt; {\n    console.log(&#x27;finally4&#x27;) &#x2F;&#x2F; 打印&#x27;finally4&#x27;\n    return 4\n  })\n  &#x2F;* Promise为\n    Promise {\n      _state: 3,\n      _handled: false,\n      _value: Promise {\n        _state: 3,\n        _handled: false,\n        _value: Promise {\n          _state: 2,\n          _handled: false,\n          _value: 2,\n          _deferreds: null\n        },\n        _deferreds: null\n      },\n      _deferreds: null\n    }\n  *&#x2F;\n)\n</code></pre><h2>Promise.allSettled - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Promise构造函数的allSettled属性，指向函数\n * 参数arr：数组\n *&#x2F;\nPromise.allSettled = function (arr) {\n  &#x2F;&#x2F; console.log(this) &#x2F;&#x2F; this指向Promise构造函数\n  var P = this\n\n  &#x2F;&#x2F; 返回一个新期约\n  return new P(function (resolve, reject) {\n    &#x2F;&#x2F; 参数必须是数组\n    if (!(arr &amp;&amp; typeof arr.length !== &#x27;undefined&#x27;)) {\n      return reject(\n        new TypeError(\n          typeof arr +\n            &#x27; &#x27; +\n            arr +\n            &#x27; is not iterable(cannot read property Symbol(Symbol.iterator))&#x27;\n        )\n      )\n    }\n\n    var args = Array.prototype.slice.call(arr) &#x2F;&#x2F; Array原型的slice方法，利用call绑定给arr（避免有自定义的slice方法）\n    if (args.length === 0) return resolve([]) &#x2F;&#x2F; 若数组长度为0，则立即执行执行器函数并返回，参数为空数组\n    &#x2F;&#x2F; ↑相当于：new Promise((resolve, reject) =&gt; resolve([]))\n\n    var remaining = args.length\n\n    &#x2F;**\n     * res()方法\n     * 参数i：数组下标\n     * 参数val：数组项\n     *&#x2F;\n    function res(i, val) {\n      &#x2F;&#x2F; console.log(args[i], val) &#x2F;&#x2F; args[i]和val最初是一样的\n\n      &#x2F;* 如果该项为对象或函数对象，则对其then属性做特殊处理 *&#x2F;\n      if (val &amp;&amp; (typeof val === &#x27;object&#x27; || typeof val === &#x27;function&#x27;)) {\n        var then = val.then\n        &#x2F;&#x2F; 如果then指向一个函数（val是Promise类型或thenable对象），则做处理\n        if (typeof then === &#x27;function&#x27;) {\n          &#x2F;* 将该项的then方法体内的this指向该项本身，并执行then()\n             Promise.prototype.then原本接受2个参数onFulfilled和onRejected，将function(val){}和function(e){}回调分别作为这两个方法传给.then()\n             -&gt; 创建Handler实例（this指向then前的Promise实例，即该项本身）\n             -&gt; 调用handle方法，根据_state进行下一步操作\n               -&gt; 如_state为1，则调用Promise._immediateFn\n               -&gt; 调用onFulfilled（即function(val)），参数为期约的_value值，即调用function(self._value)\n               （若_state为0，则将Handler实例放入then()前Promise实例（该项本身）的_deferrends数组，同步执行暂停，整端代码执行终止，返回该项，即待定的期约）\n          *&#x2F;\n          then.call(\n            val,\n            function (val) {\n              res(i, val) &#x2F;&#x2F; 将期约的_value值作为val，再次调用res方法\n            },\n            function (e) {\n              args[i] = { status: &#x27;rejected&#x27;, reason: e } &#x2F;&#x2F; 将该项重写为{status:&#x27;rejected&#x27;,reason:错误原因}\n              &#x2F;* 若所有的项都执行完毕，则执行执行器函数的resolve回调，参数为处理后的数组 *&#x2F;\n              if (--remaining === 0) {\n                resolve(args)\n              }\n            }\n          )\n          return\n        }\n      }\n\n      &#x2F;* 重写该项：\n         若该项为解决的期约，则被重写为{status:&#x27;fulfilled&#x27;,value:解决值}\n         若该项为拒绝的期约，则被重写为{status:&#x27;rejected&#x27;,reason:拒绝理由}\n         若该项为非期约，则被重写为对象{status:&#x27;fulfilled&#x27;,value:该项}\n      *&#x2F;\n      args[i] = { status: &#x27;fulfilled&#x27;, value: val }\n      &#x2F;&#x2F; console.log(args[i], val)\n      &#x2F;&#x2F; console.log(args)\n\n      &#x2F;* 若所有的Promise都执行完毕（没有待定的），则执行执行器函数的resolve回调，参数为处理后的数组 *&#x2F;\n      if (--remaining === 0) {\n        resolve(args) &#x2F;&#x2F; doResolve()内部的done控制着resolve&#x2F;reject方法只执行一次\n      }\n    }\n\n    &#x2F;* 循环数组，针对每一项执行res()方法 *&#x2F;\n    for (var i = 0; i &lt; args.length; i++) {\n      res(i, args[i])\n    }\n  })\n}\n</code></pre><ul>\n<li><strong>参数</strong>必须是<strong>数组</strong>，若为<strong>空数组</strong>则等同于<code>new Promise((resolve, reject) =&gt; resolve([]))</code></li>\n<li>循环参数数组，并重写：\n<ul>\n<li>若该项为<strong>解决的期约</strong>，则被重写为<code>{status:'fulfilled',value:解决值}</code></li>\n<li>若该项为<strong>拒绝的期约</strong>，则被重写为<code>{status:'rejected',reason:拒绝理由}</code></li>\n<li>若该项为<strong>非期约</strong>，则被重写为对象<code>{status:'fulfilled',value:该项}</code></li>\n</ul>\n</li>\n<li>若所有的<code>Promise</code>都执行完毕（没有待定的），则执行执行器函数的<code>resolve</code>回调，参数为处理后的数组\n<ul>\n<li>若有待定的期约，则会一直等待，直到执行完毕</li>\n</ul>\n</li>\n</ul>\n<h2>Promise.allSettled - 阶段测试</h2>\n<pre class=\"prettyprint language-js\"><code>setTimeout(\n  console.log,\n  0,\n  Promise.allSettled(), &#x2F;&#x2F; 参数不是数组\n  &#x2F;* Promise { _state: 2, _handled: false, _value: &#x27;TypeError: undefined undefined is not iterable(cannot read property Symbol(Symbol.iterator))&#x27;, _deferreds: null } *&#x2F;\n  Promise.allSettled([]), &#x2F;&#x2F; 参数是空数组\n  &#x2F;* Promise { _state: 1, _handled: false, _value: [], _deferreds: null } *&#x2F;\n  Promise.allSettled([3, 2, 1]), &#x2F;&#x2F; 参数是数组，数组的每项都不是Promise对象\n  &#x2F;* \n    Promise {\n      _state: 1,\n      _handled: false,\n      _value: [\n        { status: &#x27;fulfilled&#x27;, value: 3 },\n        { status: &#x27;fulfilled&#x27;, value: 2 },\n        { status: &#x27;fulfilled&#x27;, value: 1 }\n      ],\n      _deferreds: null\n    }\n  *&#x2F;\n  Promise.allSettled([\n    Promise.resolve(3),\n    Promise.resolve(2),\n    Promise.resolve(1),\n  ]), &#x2F;&#x2F; 参数是数组，每项都是解决的Promise对象\n  &#x2F;* \n    Promise {\n      _state: 1,\n      _handled: false,\n      _value: [\n        { status: &#x27;fulfilled&#x27;, value: 3 },\n        { status: &#x27;fulfilled&#x27;, value: 2 },\n        { status: &#x27;fulfilled&#x27;, value: 1 }\n      ],\n      _deferreds: null\n    }\n  *&#x2F;\n  Promise.allSettled([\n    Promise.resolve(1),\n    Promise.reject(2),\n    Promise.resolve(3),\n  ]), &#x2F;&#x2F; 参数是数组，每项都是Promise对象，有拒绝的期约\n  &#x2F;* \n    Promise {\n      _state: 1,\n      _handled: false,\n      _value: [\n        { status: &#x27;fulfilled&#x27;, value: 1 },\n        { status: &#x27;rejected&#x27;, reason: 2 },\n        { status: &#x27;fulfilled&#x27;, value: 3 }\n      ],\n      _deferreds: null\n    }\n  *&#x2F;\n  Promise.allSettled([\n    Promise.resolve(2),\n    new Promise(() =&gt; {}),\n    Promise.resolve(1),\n  ]) &#x2F;&#x2F; 参数是数组，每项都是Promise对象，有待定的期约\n  &#x2F;* Promise { _state: 0, _handled: false, _value: undefined, _deferreds: [] } *&#x2F;\n)\n</code></pre><h2>实现结果总结</h2>\n<ul>\n<li>实现<code>Promise</code>构造函数方法：<code>Promise,all</code>、<code>Promise.race</code>、<code>Promise.allSettled</code></li>\n<li>实现<code>Promise</code>原型方法：<code>Promise.prototype.finally</code></li>\n</ul>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97/javascript/Promise/Promise%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB5.js\">截至本节的代码 →</a></p>\n</div>",
      "title": "Promise源码渐进式解读（五）",
      "author": {
        "loginname": "simon9124",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 60,
      "country": "Japan"
    },
    {
      "id": "60e5affeba7460385c862d68",
      "content": "<div class=\"markdown-text\"><p>udp长连接， 在游戏中，网络较差的情况下， 正常的小包体问题不大，但是当buffer 到达5k 多的时候，就会有明显的感觉返回慢\n请教下大佬们，有没有什么好的解决方案，思路， 求指点</p>\n</div>",
      "title": "node.js 游戏服务端 udp 返回过慢，疑似包体过大，有什么解决方案",
      "author": {
        "loginname": "panlongmao",
        "avatar_url": "https://avatars.githubusercontent.com/u/38491674?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 61,
      "country": "USA"
    },
    {
      "id": "617567720af06396fcc857e0",
      "content": "<div class=\"markdown-text\"><p>一个小白 准备学 nodejs，<a href=\"http://xn--ruby-china-g93p.org\">从ruby-china.org</a> 过来的， 请问下， 这套 社区系统  支持 sub tab 的吗？ 就是在 <a href=\"http://cnodejs.org/?tab=share\">cnodejs.org/?tab=share</a>  分享tab中 细分  不同话题.</p>\n<p><img src=\"//static.cnodejs.org/Fm1ko0qN9wQXI85V_IA8PSJ2A6hS\" alt=\"image.png\">\n在Ruby China ， 我们可以有 新帖和 精华贴 （在社区下）</p>\n</div>",
      "title": "这套 社区系统  支持 sub tab 的吗？",
      "author": {
        "loginname": "someoneyoulike",
        "avatar_url": "https://avatars.githubusercontent.com/u/60083820?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 62,
      "country": "USA"
    },
    {
      "id": "617562d10af0635084c85797",
      "content": "<div class=\"markdown-text\"><p>请问下 在哪里还可以下到 苹果的 客服端 app 谢谢\n从商店 搜不到， 和 gayhub 上的链接 也无效了。</p>\n</div>",
      "title": "请问下 在哪里还可以下到 苹果的 客服端 app 谢谢",
      "author": {
        "loginname": "someoneyoulike",
        "avatar_url": "https://avatars.githubusercontent.com/u/60083820?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 63,
      "country": "USA"
    },
    {
      "id": "61726380dfe3c9e075f2c0c1",
      "content": "<div class=\"markdown-text\"><p>如果我不存在这条数据，find 的结果确实是 undefined，typeorm 为什么不返回 &lt;T | undefined&gt; 呢？</p>\n</div>",
      "title": "为什么 typeorm 的各种 find 方法返回的不是 <T | undefined> 而是 <T>？",
      "author": {
        "loginname": "willx12123",
        "avatar_url": "https://avatars.githubusercontent.com/u/63331950?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 64,
      "country": "Eurozone"
    },
    {
      "id": "6167f4c9dfe3c942b2f2b1c9",
      "content": "<div class=\"markdown-text\"><p>创业 5 个月了, 用 rust 开发嵌入式, 做了个智能围棋盘, 后端主要是node.js(typescript). 简单分享下.</p>\n<p>rust用到的主要包:\ncortex-m-rtic\nstm32f4xx-hal\nheapless</p>\n<p>node.js用到的web框架: 小众的 moleculer</p>\n<p>总结:\nrust 用在嵌入式, 虽然还不够太完善, 但是完全够用了. 而且开发现代化, 开发速度快, 完全可以替代 C.\nnode.js + typescript 在后端一如既往, 业务开发快速, 方便 ,  如果性能不够, rust来凑.\nrust + js , YYDS!!!</p>\n<p>对围棋感兴趣的童鞋, 可以关注下, 说明从 <a href=\"http://cnodejs.org\">cnodejs.org</a> 过来的有优惠.</p>\n<p><img src=\"//static.cnodejs.org/FrElHDst4poTx23jqFu4bj3-6L58\" alt=\"WechatIMG258.jpeg\"></p>\n</div>",
      "title": "用 rust + nodejs 创业, 做了个智能硬件产品",
      "author": {
        "loginname": "xieren58",
        "avatar_url": "//gravatar.com/avatar/85394c77cd5d915f13c7b47ecb4c2c06?size=48"
      },
      "important": 3,
      "status": "published",
      "num": 65,
      "country": "Eurozone"
    },
    {
      "id": "61722b7bdfe3c94cccf2c052",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-js\"><code>class Fish { }\nReflect.defineProperty(Fish.prototype, &quot;prop&quot;, {\n\tconfigurable: true,\n\tenumerable: false, &#x2F;&#x2F;定义为不可枚举的\n\twritable: true,\n})\nvar fish = new Fish\nfish.prop = 123\nconsole.log(fish.propertyIsEnumerable(&quot;prop&quot;)) &#x2F;&#x2F;print: true (重新赋值后他变为了可枚举的)\nconsole.log(Reflect.propertyIsEnumerable(fish, &quot;prop&quot;)) &#x2F;&#x2F;print: false (但是这里又显示为不可枚举)\nconsole.log(JSON.stringify(fish)) &#x2F;&#x2F;print: {&quot;prop&quot;:123} (结果来看还是可枚举的，定义失败)\n</code></pre><p>看上去是因为属性实例化后一旦修改就脱离原型了，但不知为何描述符也弄丢了。\n另外两个propertyIsEnumerable输出结果不同也难以理解。</p>\n</div>",
      "title": "定义一些不可枚举的属性，遇到了坑",
      "author": {
        "loginname": "takayama-lily",
        "avatar_url": "https://avatars.githubusercontent.com/u/12014361?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 66,
      "country": "USA"
    },
    {
      "id": "616d3c1adfe3c96233f2b869",
      "content": "<div class=\"markdown-text\"><p>根目录有<code>typings</code>文件生成，但是无法在vscode中获得智能提示，</p>\n</div>",
      "title": "Egg 怎么支持 JS 智能提示？",
      "author": {
        "loginname": "chenkai0520",
        "avatar_url": "https://avatars.githubusercontent.com/u/30174970?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 67,
      "country": "Japan"
    },
    {
      "id": "616fe2e1dfe3c98e36f2bd12",
      "content": "<div class=\"markdown-text\"><p>关注<a href=\"https://github.com/simon9124/my_demos/blob/master/README.md\">前端小讴</a>，阅读更多原创技术文章</p>\n<p><a href=\"https://cnodejs.org/topic/6165274cfe0c51db3baee418\">回顾：Promise源码渐进式解读（一）</a>\n<a href=\"https://cnodejs.org/topic/6167df78dfe3c92f44f2b131\">回顾：Promise源码渐进式解读（二）</a>\n<a href=\"https://cnodejs.org/topic/616d1aa1dfe3c9ee04f2b7d5\">回顾：Promise源码渐进式解读（三）</a></p>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97/javascript/Promise/Promise%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81%2B%E6%B3%A8%E9%87%8A.js\">完整代码+注释</a>，可对照阅读</p>\n<h2>多个 then 串联 - 遗留的问题</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;* 暂时还未实现：不少于2个的.then()链式调用 *&#x2F;\nnew Promise((resolve, reject) =&gt; {\n  resolve(3)\n})\n  .then((res) =&gt; {\n    &#x2F;* 调用第1个then时，prom为当前then前返回的期约实例，是解决的期约实例，解决值为3\n       在handle()里打印self为Promise { _state: 1, _handled: true, _value: 3, _deferreds: [] }\n       将继续异步执行处理程序 *&#x2F;\n    return res\n  })\n  .then((res) =&gt; {\n    &#x2F;* 调用第2个then时，prom为当前then前返回的期约实例，是第1个then返回的prom，是一个新创建的、未解决的期约实例\n    将当前then中生成的Handler实例放入当前then前返回的期约实例的_deferreds数组，然后暂停并返回\n    此时handle()里打印self为Promise { _state: 0, _handled: false, _value: undefined, _deferreds: [ Handler {...} ] } *&#x2F;\n    console.log(res) &#x2F;&#x2F; 不打印res，第2个then及后面的处理程序，暂时还未实现\n  })\n</code></pre><ul>\n<li>多个<code>then</code>链式调用时，从第 2 个<code>then</code>开始，<code>then</code>前返回的<code>Promise</code>实例都是<code>pending</code>状态的空期约实例，因此都会<strong>将<code>Handler</code>实例放入<code>then</code>前返回的<code>Promise</code>实例的<code>_deferreds</code>数组</strong></li>\n<li>本节将详细讲解<code>handle()</code>和<code>finale()</code>2 个方法，<strong>重点剖析<code>Promise</code>实例的<code>_deferreds</code>数组在放入<code>Handler</code>实例后的操作</strong>，应反复阅读</li>\n</ul>\n<h2>handle() - 源码</h2>\n<ul>\n<li>终于到了<code>handler()</code>的源码！其实仅比上一节的测试代码完善了一些内容，我们<strong>主要观察多个<code>then</code>的串联</strong>（以 2 个为例）</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** handle()方法：核心\n * 参数self：上一个then()前返回的Promise实例\n * 参数deferred：本次创建的Handler实例\n *&#x2F;\nfunction handle(self, deferred) {\n  &#x2F;&#x2F; console.log(self, &#x27;handle&#x27;)\n  &#x2F;&#x2F; console.log(deferred)\n  &#x2F;* deferred为创建的Handler实例\n    Handler {\n      onFulfilled: [Function (anonymous)], &#x2F;&#x2F; onFulfilled处理程序，没有则为null\n      onRejected: [Function (anonymous)], &#x2F;&#x2F; onRejected处理程序，没有则为null\n      promise: Promise { &#x2F;&#x2F; promise属性指向一个新的Promise实例\n        _state: 0,\n        _handled: false,\n        _value: undefined,\n        _deferreds: []\n      }\n    }\n  *&#x2F;\n\n  &#x2F;* 如果返回的期约实例的解决值为promise类型，_state=3 *&#x2F;\n  while (self._state === 3) {\n    self = self._value &#x2F;&#x2F; 将解决值赋给返回的期约实例\n    &#x2F;&#x2F; console.log(self)\n  }\n\n  &#x2F;* 如果_state=0，即期约实例是pendding状态（还未执行onResolve或onReject处理程序） *&#x2F;\n  &#x2F;* 链式调用时，第二个或之后的then()前返回的Promise实例永远是新的Promise实例，其_state值为0 *&#x2F;\n  if (self._state === 0) {\n    self._deferreds.push(deferred) &#x2F;&#x2F; 将Handler实例放入上一个then()前返回的Promise实例的_deferrends数组，由于上一个Handler实例的promise指向上一个Promise实例，因此上一个Handler实例也受到相应的影响\n    &#x2F;&#x2F; console.log(self, &#x27;push&#x27;)\n    &#x2F;* \n      Promise {\n        _state: 0,\n        _handled: false,\n        _value: undefined,\n        _deferreds: [\n          Handler {\n            onFulfilled: [Function (anonymous)],\n            onRejected: [Function (anonymous)],\n            promise: [Promise]\n          }\n        ]\n      }\n    *&#x2F;\n    return &#x2F;&#x2F; 同步执行到此暂停，等待异步执行（执行前一个Promise的then里面的onResolve）\n  }\n\n  &#x2F;* 如果不是上述情况，标记当前进行的promise._handled为true *&#x2F;\n  self._handled = true\n  &#x2F;&#x2F; console.log(self)\n\n  &#x2F;** 通过事件循环异步来做回调的处理\n   * 注意：这里的事件是异步执行的，第二个then会比这里的方法先执行\n   *&#x2F;\n  Promise._immediateFn(function () {\n    &#x2F;&#x2F; console.log(deferred, &#x27;_immediateFn&#x27;) &#x2F;&#x2F; 注意：当有不少于2个.then()时，前一个.then()生成的Handler实例，其promise指向的Promise实例的_deferreds指向问题（后一个.then()里包含onFulfilled或onRejected回调函数，_deferreds不再指向空数组而是包含后一个Handler实例的数组）\n\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected &#x2F;&#x2F; 根据上一个then()前的Promise实力的_state，获取onFulfilled或onRejected处理程序\n    &#x2F;&#x2F; console.log(cb)\n\n    &#x2F;* 如果没有onFulfilled或onRejected回调函数，则携带当前的_value值，等待下一个Promise对象的回调 *&#x2F;\n    if (cb === null) {\n      &#x2F;&#x2F; console.log(deferred.promise, self._value)\n      ;(self._state === 1 ? resolve : reject)(deferred.promise, self._value)\n\n      &#x2F;**\n       * resolve()或reject方法：等待下一个Promise对象的回调\n       * 参数deferred.promise：Handler实例的promise，指向上一个then()前的Promise实例\n       * 参数self._value：上一个then()前返回的Promise实例的_value属性值\n       *&#x2F;\n      &#x2F;&#x2F; resolve(deferred.promise, self._value)\n      &#x2F;&#x2F; reject(deferred.promise, self._value)\n\n      return\n    }\n\n    &#x2F;* 如果有onFulfilled或onRejected回调函数，则执行自己的回调 *&#x2F;\n    var ret\n    try {\n      &#x2F;**\n       * cb()方法：执行onFulfilled或onRejected处理程序\n       * 参数self._value：then()前返回的Promise实例的解决值&#x2F;拒绝理由\n       *&#x2F;\n      ret = cb(self._value) &#x2F;&#x2F; 执行回调，返回值赋给ret\n    } catch (e) {\n      &#x2F;**\n       * reject()方法：处理下一个catch的回调方法\n       * 参数deferred.promise：创建的Handler实例的promise属性，指向新的Promise实例\n       * 参数e：错误信息\n       *&#x2F;\n      reject(deferred.promise, e)\n      return\n    }\n\n    &#x2F;**\n     * resolve()方法：处理下一个then的回调方法\n     * 参数deferred.promise：Handler实例的promise，指向上一个then()前的Promise实例\n     * 参数ret：执行当前then回调的返回值\n     *&#x2F;\n    &#x2F;&#x2F; console.log(deferred.promise, ret)\n    resolve(deferred.promise, ret)\n  })\n}\n</code></pre><ul>\n<li>第 2 个<code>then</code>前返回的<code>Promise</code>实例一定是<code>pending</code>状态，<strong>因此第 2 个<code>then</code>中生成的<code>Handler</code>实例会放入第 2 个<code>then</code>前返回的<code>Promise</code>实例的<code>_deferreds</code>数组</strong></li>\n<li><strong>重点来了</strong>，还记得<code>Handler</code>构造函数么？\n<ul>\n<li>每调用 1 次<code>then</code>，都生成 1 个<code>Handler</code>实例，2 个<code>then</code>串联会生成 2 个<code>Handler</code>实例</li>\n<li>每个<code>Handler</code>实例的<code>promise</code>，都指向当前<code>then</code>中生成的<code>Promise</code>实例<code>prom</code>（也就是下一个<code>then</code>前返回的<code>Promise</code>实例）</li>\n<li>但由于第 2 个<code>then</code>改变了第 2 个<code>then</code>前返回的<code>Promise</code>实例（<code>_deferreds</code>数组放入<code>Handler</code>实例），因此<strong>第 1 个<code>Handler</code>实例也随之改变</strong></li>\n<li>打开<code>handle()</code>尾部的注释<code>console.log(deferred.promise, ret)</code>可更好的观察<code>Handler</code>实例的变化</li>\n<li>总结来说，就是<strong>第 1 个<code>Handler</code>实例的<code>promise</code>属性指向的<code>Promise</code>实例，其<code>_deferreds</code>数组也放入了第 2 个<code>Handler</code>实例</strong></li>\n</ul>\n</li>\n<li><strong>第 2 个重点</strong>就是，调用处理程序后，会再次调用<code>resolve()</code>方法，保证第 2 个<code>then</code>能获取到第 1 个<code>then</code>中的返回值\n<ul>\n<li>还记得么？在<code>resolve()</code>中，会给其<code>_state</code>和<code>_value</code>赋值，并调用<code>finale()</code>方法。因此我们来到最后的源码——<code>finale()</code>方法</li>\n</ul>\n</li>\n</ul>\n<h2>finale() - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** finale()方法\n * 参数self：（期约）实例\n *&#x2F;\nfunction finale(self) {\n  &#x2F;&#x2F; console.log(self, &#x27;finale&#x27;)\n\n  &#x2F;* 如果_state的值为2（Promise执行reject()方法），且未提供回调函数（或未实现catch函数），则给出警告 *&#x2F;\n  if (self._state === 2 &amp;&amp; self._deferreds.length === 0) {\n    &#x2F;**\n     * 执行Promise构造函数的_immediateFn()方法\n     * 参数fn：要执行的警告方法\n     *&#x2F;\n    Promise._immediateFn(function () {\n      &#x2F;* 如果未被处理过，则给出警告 *&#x2F;\n      if (!self._handled) {\n        &#x2F;**\n         * 执行Promise构造函数的._unhandledRejectionFn()方法\n         * 参数self._value：拒绝理由\n         *&#x2F;\n        Promise._unhandledRejectionFn(self._value)\n      }\n    })\n  }\n\n  &#x2F;* 循环self._deferreds，每一项都执行handle()方法 *&#x2F;\n  for (var i = 0, len = self._deferreds.length; i &lt; len; i++) {\n    &#x2F;**\n     * handle()方法\n     * 参数self：（期约）实例\n     * 参数self._deferreds[i]：当前的Handle实例对象\n     *&#x2F;\n    &#x2F;&#x2F; console.log(self, self._deferreds[i])\n    handle(self, self._deferreds[i])\n  }\n\n  self._deferreds = null &#x2F;&#x2F; 全部执行后，将_deferreds数组重置为null\n}\n</code></pre><ul>\n<li>终于到了<code>_deferreds</code>数组真正起作用的时候了！<code>finale()</code>会循环这个数组，然后给每一项执行<code>handle()</code></li>\n<li>与<code>handle</code>一起，2 个<code>then</code>串联的过程就是：\n<ul>\n<li>第 1 个<code>then</code>前返回<code>Promise</code>实例（调用<code>resolve()</code>、<code>finale()</code>，<code>_deferreds</code>数组为空到此结束）</li>\n<li>调用第 1 个<code>then</code>，调用<code>handle()</code>，<code>Promise._immediateFn</code>放入异步线程 1</li>\n<li>调用第 2 个<code>then</code>，第 2 个<code>then</code>前返回的<code>Promise</code>实例的<code>_state</code>为 0，将第 2 个<code>Handle</code>实例放入第 2 个<code>then</code>前返回的<code>Promise</code>实例的<code>_deferreds</code>数组后返回（因此改变了第 1 个<code>Handle</code>）</li>\n<li>进入异步线程 1，执行第 1 个<code>then</code>的处理方法后，再次调用<code>resolve()</code>、<code>finale()</code>，<code>_deferreds</code>数组不为空因此调用<code>handle()</code>，<code>Promise._immediateFn</code>放入异步线程 2</li>\n<li>进入异步线程 2，执行第 2 个<code>then</code>的处理方法后，再次调用<code>resolve()</code>、<code>finale()</code>，<code>_deferreds</code>数组为空全部结束</li>\n</ul>\n</li>\n<li>如果上述流程还不明晰，下面会用测试例子一步一步的详解</li>\n</ul>\n<h2>多个 then 的链式调用 - 阶段测试</h2>\n<pre class=\"prettyprint language-js\"><code>new Promise((resolve, reject) =&gt; {\n  resolve(3)\n})\n  .then((res) =&gt; {\n    console.log(res)\n    return 4\n  })\n  .then((res) =&gt; {\n    console.log(res)\n    return 5\n  })\n</code></pre><ul>\n<li>根据源码，上述代码的完整调用流程为：\n<ul>\n<li><code>new Promise((resolve, reject) =&gt; {resolve(3)})</code>\n<ul>\n<li>执行<code>new Promise</code>，创建<code>Promise</code>实例，返回这个<code>Promise</code>实例</li>\n<li>执行<code>doResolve()</code>，<strong>同步立即执行执行器函数</strong><code>(resolve, reject) =&gt; {resolve(3)}</code></li>\n<li>执行<code>resolve(3)</code>，将<code>Promise</code>实例的<code>_state</code>赋为 1、<code>_value</code>赋为 3</li>\n<li>执行<code>finale()</code>，<code>Promise</code>实例的<code>_deferreds</code>为<code>[]</code>，赋为<code>null</code>后执行结束</li>\n<li>返回的<code>Promise</code>实例：<code>Promise { _state: 1, _handled: false, _value: 3, _deferreds: null }</code></li>\n</ul>\n</li>\n<li><code>.then((res) =&gt; {console.log(res);return 4})</code>\n<ul>\n<li>执行<code>Promise.prototype.then</code>，创建新<code>Promise</code>实例，传入空方法作为执行器函数，返回这个新的<code>Promise</code>实例</li>\n<li>执行<code>new Handler</code>，包装当前的<code>onFulfilled</code>处理程序<code>(res) =&gt; {console.log(res);return 4}</code>，返回<code>Handler</code>实例</li>\n<li>执行<code>handle()</code>，传入上一个<code>then()</code>前返回的<code>Promise</code>实例和<code>Handler</code>实例\n<ul>\n<li>上一个<code>Promise</code>实例的<code>_state</code>为 1，将其<code>_handled</code>赋为<code>true</code>，执行<code>Promise._immediateFn()</code>，将当前的<code>onFulfilled</code>处理程序放入<strong>异步线程 1</strong></li>\n</ul>\n</li>\n<li>返回<code>Promise</code>实例：<code>Promise { _state: 0, _handled: false, _value: undefined, _deferreds: [] }</code></li>\n</ul>\n</li>\n<li><code>.then((res) =&gt; {console.log(res);return 5})</code>\n<ul>\n<li>执行<code>Promise.prototype.then</code>，创建新<code>Promise</code>实例，传入空方法作为执行器函数，返回这个新的<code>Promise</code>实例</li>\n<li>执行<code>new Handler</code>，包装当前的<code>onFulfilled</code>处理程序<code>(res) =&gt; {console.log(res);return 5}</code>，返回<code>Handler</code>实例</li>\n<li>执行<code>handle()</code>，传入上一个<code>then()</code>前返回的<code>Promise</code>实例和<code>Handler</code>实例\n<ul>\n<li>上一个<code>Promise</code>实例的<code>_state</code>为 0，将本次的<code>Hander</code>实例放入其<code>_deferreds</code>空数组，<code>return</code>后因为暂无后续<code>.then()</code>，<strong>同步线程暂停</strong></li>\n<li>上一个<code>Promise</code>实例变为：<code>Promise { _state: 0, _handled: false, _value: undefined, _deferreds: [ Handler {} ] }</code>，<code>Handler</code>为本次的 <code>Handler</code>实例</li>\n<li><strong>重点来了</strong>：由于<code>Handler</code>实例的<code>promise</code>指向<code>.then()</code>中创建的<code>Promise</code>实例（<code>prom</code>），因此<strong>上一个<code>Handler</code>实例也受到影响，其<code>promise</code>指向的<code>Promise</code>实例（即上一个<code>Promise</code>实例）的<code>_deferreds</code>同样指向<code>[ Handler {} ]</code></strong></li>\n</ul>\n</li>\n<li><strong>回到异步线程 1</strong>，执行上一个<code>Handler</code>实例包装的<code>onFulfilled</code>处理程序，打印 3，返回 4</li>\n<li>执行<code>resolve()</code>，传入上一个<code>Handler</code>实例的<code>promise</code>（指向已发生变化的<code>Promise</code>实例）和<code>onFulfilled</code>返回值（4），将<code>_state</code>赋为 1、<code>_value</code>赋为 4\n<ul>\n<li>此时已发生变化的<code>Promise</code>实例更新为<code>Promise { _state: 1, _handled: false, _value: 4, _deferreds: [ Handler {} ] }</code></li>\n</ul>\n</li>\n<li>执行<code>finale()</code>，传入更新的<code>Promise</code>，循环<code>_deferreds</code>数组</li>\n<li>执行<code>handle()</code>，传入更新的<code>Promise</code>实例和本次的<code>Handler</code>实例\n<ul>\n<li>更新的<code>Promise</code>实例的<code>_state</code>为 1，将其<code>_handled</code>赋为<code>true</code>，执行<code>Promise._immediateFn()</code>，将当前的<code>onFulfilled</code>处理程序放入<strong>异步线程 2</strong>（嵌套在异步线程 1 中）</li>\n</ul>\n</li>\n<li>由于<strong>没有同步线程了，直接来到异步线程 2</strong>，执行本次<code>Handler</code>实例包装的<code>onFulfilled</code>处理程序，打印 4，返回 5</li>\n<li>执行<code>resolve()</code>，传入本次<code>Handler</code>实例的<code>promise</code>（未发生变化，初始的<code>Promise</code>实例）和<code>onFulfilled</code>返回值（5），将<code>_state</code>赋为 1、<code>_value</code>赋为 5\n<ul>\n<li>此时<code>Promise</code>实例更新为<code>Promise { _state: 1, _handled: false, _value: 5, _deferreds: [] }</code></li>\n</ul>\n</li>\n<li>执行<code>finale()</code>，传入更新的<code>Promise</code>，其<code>_deferreds</code>为<code>[]</code>，赋为<code>null</code>后执行结束</li>\n<li>返回<code>Promise</code>实例：<code>Promise { _state: 0, _handled: false, _value: undefined, _deferreds: [] }</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>再次总结：\n<ul>\n<li><code>new Promise</code>的<strong>执行器函数</strong>是<strong>同步</strong>的，最先执行</li>\n<li>无论多少个<code>.then</code>，其<strong>创建新<code>Promise</code>实例、创建<code>Handle</code>实例及<code>handle()</code>方法的前半部分（直至<code>Promise._immediateFn</code>前）<strong>都是</strong>同步</strong>的，依次执行</li>\n<li>后面的<code>.then</code>会改变前面返回的<code>Promise</code>实例，从而改变前面生成的<code>Handle</code>实例</li>\n<li>同步执行完毕后，执行首个<code>.then</code>中<code>handle()</code>中的异步方法<code>Promise._immediateFn</code>，开启异步线程\n<ul>\n<li>在异步线程的最后，执行<code>resolve()</code>方法再执行<code>finale()</code>方法</li>\n<li><strong>此时传入的<code>Promise</code>实例的<code>_deferreds</code>不再是空数组，而是放入了下一个<code>.then</code>中的处理方法</strong></li>\n<li>进而再次执行<code>handle()</code>方法及其中的<code>Promise._immediateFn</code>\n<ul>\n<li>在<strong>异步线程中嵌套新的异步线程</strong>，直至最终执行完毕</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>then 与 catch 交替的链式调用 - 阶段测试</h2>\n<pre class=\"prettyprint language-js\"><code>Promise.resolve(1)\n  .catch((err) =&gt; {\n    console.log(3) &#x2F;&#x2F; 不打印，resolve后面不执行onRejected处理程序\n    return 3\n  })\n  .then((res) =&gt; {\n    console.log(res) &#x2F;&#x2F; 1\n  })\n\nPromise.reject(1)\n  .then((res) =&gt; {\n    console.log(2) &#x2F;&#x2F; 不打印，reject后面不执行onResolved处理程序\n    return 2\n  })\n  .catch((err) =&gt; {\n    console.log(err) &#x2F;&#x2F; 1\n  })\n</code></pre><ul>\n<li><code>resolve</code>后面不会执行<code>onRejected</code>处理程序，<code>reject</code>后面不执行<code>onResolved</code>处理程序</li>\n</ul>\n<h2>中间的 then 或 catch 没有回调 - 阶段测试</h2>\n<pre class=\"prettyprint language-js\"><code>new Promise((resolve, reject) =&gt; {\n  resolve(3)\n})\n  .then() &#x2F;&#x2F; 没有回调，等待下个Promise的回调\n  .then((res) =&gt; {\n    console.log(res)\n  })\n\nnew Promise((resolve, reject) =&gt; {\n  reject(4)\n})\n  .catch() &#x2F;&#x2F; 没有回调，等待下个Promise的回调\n  .catch((res) =&gt; {\n    console.log(res)\n  })\n</code></pre><ul>\n<li>携带当前的<code>_value</code>值，等待下一个<code>Promise</code>对象的回调\n<ul>\n<li><code>handle()</code>方法里<code>Promise._immediateFn</code>里的<code>cb===null</code>，根据<code>then</code>前<code>Promise</code>对象的类型（解决/拒绝），调用<code>resolve()</code>或<code>reject()</code>方法</li>\n</ul>\n</li>\n</ul>\n<h2>实现结果总结</h2>\n<ul>\n<li>已实现：\n<ul>\n<li>多个<code>then</code>(<code>catch</code>)的链式调用</li>\n<li><code>then</code>与<code>catch</code>交替的链式调用</li>\n<li>中间的<code>then</code>或<code>catch</code>没有回调的链式调用</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97/javascript/Promise/Promise%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB4.js\">截至本节的代码 →</a></p>\n</div>",
      "title": "Promise源码渐进式解读（四）",
      "author": {
        "loginname": "simon9124",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 68,
      "country": "Eurozone"
    },
    {
      "id": "616a9342dfe3c94064f2b5b6",
      "content": "<div class=\"markdown-text\"><p>我买了美国的一个服务器，自己做了vv，但是有几个确实不能用。终于找到一个可以用的。那么污染，意味着我这个干净的ip，不能用在我普通手上上或者电脑上，会污染么？</p>\n</div>",
      "title": "做tiktok说ip会污染，是什么意思呢？",
      "author": {
        "loginname": "html5col",
        "avatar_url": "https://avatars.githubusercontent.com/u/11325151?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 69,
      "country": "China"
    },
    {
      "id": "61558081fe0c513bb3aec8be",
      "content": "<div class=\"markdown-text\"><p>今年用nodejs写了一个桌面软件开发框架，目前还不错，大家看一看</p>\n<p>目前已经800+ star 了，希望今年突破 1k，哈哈</p>\n<p><a href=\"https://gitee.com/wallace5303/electron-egg\">electron-egg</a>\n一个简单、快速、功能丰富的跨平台桌面软件开发框架。\n项目地址：<a href=\"https://gitee.com/wallace5303/electron-egg\">https://gitee.com/wallace5303/electron-egg</a>\n<img src=\"//static.cnodejs.org/FqG1F6W4i1rR6-vy--yapPVrpeos\" alt=\"home.png\">\n<img src=\"//static.cnodejs.org/FlHVB0_CNBb-bZaxqyLSNxbQj2oV\" alt=\"socket.png\"></p>\n<p>特性</p>\n<ol>\n<li>跨平台：一套代码，可以打包成windows版、Mac版、Linux版或者以web网站运行</li>\n<li>简单高效：支持vue、react、ejs等</li>\n<li>工程化：可以用服务端的开发思维，来编写桌面软件</li>\n<li>高性能：可启动多个工作进程</li>\n<li>功能丰富：服务端的技术场景都可以使用，如：路由、中间件、控制器、服务、定时任务、队列、插件等</li>\n<li>功能demo：桌面软件常见功能，后续逐步集成并完善或提供demo</li>\n</ol>\n</div>",
      "title": "用node.js后端思维，开发桌面软件",
      "author": {
        "loginname": "wallace5303",
        "avatar_url": "https://avatars.githubusercontent.com/u/6782673?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 70,
      "country": "Eurozone"
    },
    {
      "id": "616a69e4dfe3c926e9f2b557",
      "content": "<div class=\"markdown-text\"><p>这几天体验了下apifox，真的可以把postman扔掉了</p>\n<p>对于前端：拿来做mock mock出来的数据很人性化\n对于后端：拿来做调试 postmam的功能完全具备并支持自动校验数据结构\n对于测试：拿来做接口自动化测试 可视化配置断言功能杠杠的\n对于团队：一体化协同工具 打通前端、后端及测试研发闭环</p>\n<blockquote>\n<p>官方介绍：  API 文档、调试、Mock、测试一体化协作平台。Apifox = Postman + Swagger + Mock + JMeter</p>\n</blockquote>\n<p>通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好接口文档，接口调试、数据 Mock 、接口测试就可以直接使用，无需再次定义；接口文档和接口开发调试使用同一个工具，接口调试完成后即可保证和接口文档定义完全一致。高效、及时、准确！</p>\n<p>它的功能点：\n1.接口文档定义：Apifox 遵循 OpenApi 3.0 (原 Swagger)、JSON Schema 规范的同时，提供了非常好用的可视化文档管理功能，零学习成本，非常高效。\n2.接口调试：Postman 有的功能，比如环境变量、预执行脚本、后执行脚本、Cookie/Session 全局共享 等功能，Apifox 都有，并且和 Postman 一样高效好用。</p>\n<ol>\n<li>数据 Mock：内置 Mock.js 规则引擎，非常方便 mock 出各种数据，并且可以在定义数据结构的同时写好 mock 规则。支持添加“期望”，根据请求参数返回不同 mock 数据。最重要的是 Apifox 零配置 即可 Mock 出非常人性化的数据，具体在本文后面介绍。</li>\n<li>接口自动化测试：提供接口集合测试，可以通过选择接口（或接口用例）快速创建测试集。</li>\n</ol>\n<p>官网地址：<a href=\"http://apifox.cn\">http://apifox.cn</a></p>\n</div>",
      "title": "有没有人用过 Apifox，是不是可以扔掉 Postman 了？",
      "author": {
        "loginname": "littleTreeme",
        "avatar_url": "https://avatars.githubusercontent.com/u/62824719?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 71,
      "country": "USA"
    },
    {
      "id": "60dc5fa4248d04eff94afc83",
      "content": "<div class=\"markdown-text\"><p>请问在electron新窗口里怎么写react代码呢，求大佬指点一下</p>\n</div>",
      "title": "新手求助，关于electron",
      "author": {
        "loginname": "xiaoshadou",
        "avatar_url": "https://avatars.githubusercontent.com/u/28916379?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 72,
      "country": "USA"
    },
    {
      "id": "616d1aa1dfe3c9ee04f2b7d5",
      "content": "<div class=\"markdown-text\"><p>关注<a href=\"https://github.com/simon9124/my_demos/blob/master/README.md\">前端小讴</a>，阅读更多原创技术文章</p>\n<p><a href=\"https://cnodejs.org/topic/6165274cfe0c51db3baee418\">回顾：Promise源码渐进式解读（一）</a>\n<a href=\"https://cnodejs.org/topic/6167df78dfe3c92f44f2b131\">回顾：Promise源码渐进式解读（二）</a></p>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97/javascript/Promise/Promise%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81%2B%E6%B3%A8%E9%87%8A.js\">完整代码+注释</a>，可对照阅读</p>\n<h2>Promise.prototype.then - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Promise原型的then属性，指向函数\n * 参数onFulfilled：onResolved处理程序，在期约兑现时执行的回调\n * 参数onRejected：onRejected处理程序，在期约拒绝时执行的回调\n * 支持无限链式回调，每个then()方法返回新的Promise实例\n *&#x2F;\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  &#x2F;&#x2F; console.log(this, &#x27;then&#x27;) &#x2F;&#x2F; this指向then()前返回的Promise实例\n  &#x2F;&#x2F; console.log(this.constructor) &#x2F;&#x2F; constructor指向Promise构造函数\n  &#x2F;&#x2F; console.log(this.constructor === Promise) &#x2F;&#x2F; true\n\n  &#x2F;* 创建一个新期约实例（相当于new Promise(noop)），传入空方法noop作为执行器函数\n     注意：每次调用.then()都创建新的Promise实例，但调用下一个.then()会将上一个Promise实例的_deferreds数组改变（放入下一个的Handler实例）！\n  *&#x2F;\n  var prom = new this.constructor(noop) &#x2F;&#x2F; -&gt; var prom = new Promise(noop) -&gt; var prom = new Promise(()=&gt;{})\n  &#x2F;&#x2F; console.log(prom) &#x2F;&#x2F; Promise { _state: 0, _handled: false, _value: undefined, _deferreds: [] }，新期约\n  &#x2F;&#x2F; console.log(new Promise(noop)) &#x2F;&#x2F; Promise { _state: 0, _handled: false, _value: undefined, _deferreds: [] }，同上\n\n  &#x2F;**\n   * handle()方法\n   * 参数this：then()前返回的上一个Promise实例\n   * 参数new Handler(onFulfilled, onRejected, prom)：创建的Handler实例\n   *&#x2F;\n  handle(this, new Handler(onFulfilled, onRejected, prom))\n\n  return prom &#x2F;&#x2F; 返回新创建的期约实例，以便链式调用\n}\n\nfunction noop() {}\n</code></pre><ul>\n<li><code>then</code>指向的函数中的<code>this</code>，指向当前<code>then</code>前返回的<code>Promise</code>实例，因此<code>this.constructor</code>指向<code>Promise</code>构造函数</li>\n<li>每次调用<code>Promise.then</code>时：\n<ul>\n<li>将空方法<code>noop</code>作为执行器函数，调用<code>new this.constructor()</code>创建一个新的空<code>Promise</code>实例</li>\n<li>还会新创建一个<code>Handler</code>实例，然后调用<code>handle()</code>方法</li>\n<li>最终都<strong>返回新创建的期约实例</strong>，这是为了<strong>支持无限链式回调</strong></li>\n<li>“调用下一个<code>.then()</code>会将上一个<code>Promise</code>实例的<code>_deferreds</code>数组改变”，可后续再研究</li>\n</ul>\n</li>\n</ul>\n<h2>Handler 构造函数 - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Handler构造函数：打包onFulfilled、onRejected和promise，作为一个整体方便后面调用\n * 参数onFulfilled：resolve回调函数\n * 参数onRejected：reject回调函数\n * 参数promise：新的空promise实例\n *&#x2F;\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : null &#x2F;&#x2F; 是否有成功回调，若没有则赋为null\n  this.onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : null &#x2F;&#x2F; 是否有失败回调，若没有则赋为null\n  this.promise = promise &#x2F;&#x2F; Handler的promise，指向prom，即在.then()中创建的新Promise实例\n  &#x2F;&#x2F; console.log(this.promise, &#x27;new Handler&#x27;)\n  &#x2F;&#x2F; console.log(this)\n}\n</code></pre><ul>\n<li>接收 3 个参数：成功回调、失败回调新的空<code>promise</code>实例</li>\n</ul>\n<h2>handle() - 测试代码</h2>\n<ul>\n<li>在源码的基础上加以简化，方便做阶段测试</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** 测试用的handle()方法\n * 参数self：then()前返回的Promise实例\n * 参数deferred：创建的Handler实例\n *&#x2F;\nfunction handle(self, deferred) {\n  &#x2F;&#x2F; console.log(self)\n  &#x2F;&#x2F; console.log(deferred)\n\n  &#x2F;* deferred为创建的Handler实例\n    Handler {\n      onFulfilled: [Function (anonymous)], &#x2F;&#x2F; onFulfilled处理程序，没有则为null\n      onRejected: [Function (anonymous)], &#x2F;&#x2F; onRejected处理程序，没有则为null\n      promise: Promise { &#x2F;&#x2F; promise属性指向一个新的Promise实例\n        _state: 0,\n        _handled: false,\n        _value: undefined,\n        _deferreds: []\n      }\n    }\n  *&#x2F;\n\n  &#x2F;* 如果返回的期约实例的解决值为promise类型，_state=3 *&#x2F;\n  while (self._state === 3) {\n    self = self._value &#x2F;&#x2F; 将解决值赋给返回的期约实例\n  }\n\n  &#x2F;* 如果返回的期约实例是pendding状态，_state=0，即还没有执行resolve()或reject()方法 *&#x2F;\n  if (self._state === 0) {\n    self._deferreds.push(deferred) &#x2F;&#x2F; 将Handler实例放入实例的_deferrends数组，然后返回，继续等待\n    console.log(self)\n    return\n  }\n\n  &#x2F;* 标记当前进行的promise._handled为true *&#x2F;\n  self._handled = true\n  console.log(self)\n\n  &#x2F;* 通过事件循环异步来做回调的处理（注意：这里是异步的！） *&#x2F;\n  Promise._immediateFn(function () {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected &#x2F;&#x2F; 获取onFulfilled或onRejected处理程序\n\n    &#x2F;* 如果有onFulfilled或onRejected回调函数，则执行自己的回调 *&#x2F;\n    try {\n      &#x2F;**\n       * cb()方法：执行onFulfilled或onRejected处理程序\n       * 参数self._value：then()前返回的Promise实例的解决值&#x2F;拒绝理由\n       *&#x2F;\n      cb(self._value) &#x2F;&#x2F; 执行回调\n    } catch (e) {\n      &#x2F;* 若抛出错误，则调用reject()方法，参数为创建的Handler实例的promise（新Promise实例）和错误原因 *&#x2F;\n      reject(deferred.promise, e)\n      return\n    }\n  })\n}\n</code></pre><ul>\n<li><code>then</code>前返回的期约实例，根据<code>_state</code>值的不同，做不同的处理\n<ul>\n<li>返回非待定的期约，最终会执行<code>then</code>中的处理程序</li>\n<li>返回待定的期约，则不会执行<code>then</code>中的处理程序，但<strong>会将<code>then</code>中生成的<code>Handler</code>实例放入<code>then</code>前<code>Promise</code>实例的<code>_deferreds</code>数组</strong></li>\n</ul>\n</li>\n<li>执行<code>then</code>中的处理程序是<strong>异步</strong>的，会在所有同步操作都执行完才去执行</li>\n</ul>\n<h2>Promise.prototype.then - 阶段测试</h2>\n<pre class=\"prettyprint language-js\"><code>new Promise((resolve, reject) =&gt; {}).then(() =&gt; {\n  console.log(3) &#x2F;&#x2F; then前是未解决的期约，期约解决前不会执行处理程序\n})\n&#x2F;* 执行到handle()时，self._state为0，将Handler实例放入实例的_deferrends数组，不再执行后续操作，self为：\n  Promise {\n    _state: 0,\n    _handled: false,\n    _value: undefined,\n    _deferreds: [\n      Handler { \n        onFulfilled: [Function (anonymous)], \n        onRejected: null, \n        promise: Promise {_state: 0, _handled: false, _value: undefined, _deferreds: []}\n      }\n    ]\n  }\n*&#x2F;\n\nnew Promise((resolve, reject) =&gt; {\n  &#x2F;* 实际执行首个resolve或reject后，后续的resolve或reject不会再执行，这里仅把测试结果合并 *&#x2F;\n\n  resolve(3) &#x2F;&#x2F; 打印res为3，解决值为基本类型\n  &#x2F;* self为Promise { _state: 1, _handled: true, _value: 3, _deferreds: [] } *&#x2F;\n  resolve({ val: 3 }) &#x2F;&#x2F; 打印res为{ val: 3 }，解决值为普通对象\n  &#x2F;* self为Promise { _state: 1, _handled: true, _value: { val: 3 }, _deferreds: [] } *&#x2F;\n  resolve(new Promise(() =&gt; {})) &#x2F;&#x2F; 不打印res，解决值为pending的期约实例\n  &#x2F;* self与new Promise((resolve, reject) =&gt; {}).then()基本相同，onFulfilled不再是null*&#x2F;\n  resolve(Promise.resolve(3)) &#x2F;&#x2F; 打印res为3，解决值为fullfilled的期约实例，将fullfilled的解决值赋给self\n  &#x2F;* self为Promise { _state: 1, _handled: true, _value: 3, _deferreds: [] } *&#x2F;\n  resolve({\n    &#x2F;&#x2F; 解决值为thenable对象\n    value: 3,\n    then: function () {\n      console.log(this) &#x2F;&#x2F; { value: 3, then: [Function: then] }\n      console.log(this.value) &#x2F;&#x2F; 3\n    },\n  })\n  &#x2F;* self与resolve(new Promise(() =&gt; {}))相同 *&#x2F;\n}).then((res) =&gt; {\n  console.log(res) &#x2F;&#x2F; then()前返回的Promise的解决值\n})\n\nnew Promise((resolve, reject) =&gt; {\n  reject(3) &#x2F;&#x2F; 打印res为3\n  &#x2F;* self为Promise { _state: 2, _handled: true, _value: 3, _deferreds: [] } *&#x2F;\n}).then(null, (err) =&gt; {\n  console.log(err) &#x2F;&#x2F; then()前返回的Promise的拒绝理由\n})\n</code></pre><ul>\n<li>大体有了链式回调的雏形：\n<ul>\n<li>能够根据<code>Promise</code>实例的状态，获取其解决值/拒绝理由，并执行相应的处理程序（<code>onResolve</code>或<code>onReject</code>）</li>\n</ul>\n</li>\n<li><code>pedding</code>状态的期约调用<code>then</code>后，会将<code>then</code>中生成的<code>Handler</code>实例放入其<code>_deferreds</code>数组</li>\n</ul>\n<h2>Promise.prototype.catch - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Promise原型的catch属性，指向函数\n * 参数onRejected：onRejected处理程序，在期约拒绝时执行的回调\n * 支持无限链式回调，每个catch()方法返回新的Promise实例\n *&#x2F;\nPromise.prototype[&#x27;catch&#x27;] = function (onRejected) {\n  return this.then(null, onRejected)\n}\n</code></pre><ul>\n<li>在<code>Promise.prototype.then</code>上做一层封装，只接收<code>onRejected</code>处理程序</li>\n</ul>\n<h2>Promise.prototype.catch - 阶段测试</h2>\n<pre class=\"prettyprint language-js\"><code>new Promise((resolve, reject) =&gt; {}).catch(() =&gt; {\n  console.log(3) &#x2F;&#x2F; catch前是未解决的期约，期约解决前不会执行处理程序（同then）\n})\n\nnew Promise((resolve, reject) =&gt; {\n  &#x2F;* 实际执行首个resolve或reject后，后续的resolve或reject不会再执行，这里仅把测试结果合并 *&#x2F;\n\n  reject(4) &#x2F;&#x2F; 4，拒绝理由为基本类型\n  &#x2F;* self为Promise { _state: 2, _handled: true, _value: 4, _deferreds: [] } *&#x2F;\n  reject({ val: 4 }) &#x2F;&#x2F; { val: 4 }，拒绝理由为普通对象\n  &#x2F;* self为Promise { _state: 2, _handled: true, _value: { val: 4 }, _deferreds: [] } *&#x2F;\n  throw Error(&#x27;error!&#x27;) &#x2F;&#x2F; &#x27;Error: error!&#x27;，抛出错误\n  &#x2F;* self为Promise { _state: 2, _handled: true, _value: Error: error!, _deferreds: [] } *&#x2F;\n  reject(new Promise(() =&gt; {})) &#x2F;&#x2F; &#x27;Promise { _state: 0, _handled: false, _value: undefined, _deferreds: [] }&#x27;，期约本身作为拒绝理由（需与resolve区分）\n  &#x2F;* self为Promise { _state: 2, _handled: true, _value: Promise { _state: 0, _handled: false, _value: undefined, _deferreds: [] }, _deferreds: [] } *&#x2F;\n  reject(Promise.resolve(3)) &#x2F;&#x2F; &#x27;Promise { _state: 1, _handled: false, _value: 3, _deferreds: [] }&#x27;，同上，期约本身作为拒绝理由，与期约状态无关\n  &#x2F;* self为Promise { _state: 2, _handled: true, _value: Promise { _state: 1, _handled: false, _value: 3, _deferreds: [] }, _deferreds: [] } *&#x2F;\n}).catch((err) =&gt; {\n  console.log(err) &#x2F;&#x2F; catch()前返回的Promise的拒绝理由\n})\n</code></pre><ul>\n<li>与<code>Promise.prototype.then</code>的结果大致相同，需区分<code>catch</code>前期约的拒绝理由是<code>Promise</code>实例的情况</li>\n</ul>\n<h2>实现结果总结</h2>\n<ul>\n<li>单个<code>Promise.prototype.then</code>和<code>Promise.prototype.catch</code>的链式回调（多个还未实现）</li>\n</ul>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97/javascript/Promise/Promise%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB3.js\">截至本节的代码 →</a></p>\n</div>",
      "title": "Promise源码渐进式解读（三）",
      "author": {
        "loginname": "simon9124",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 73,
      "country": "China"
    },
    {
      "id": "61697539dfe3c96426f2b46e",
      "content": "<div class=\"markdown-text\"><p>看教程的过程中看到一个例子，觉得蛮奇怪的 <a href=\"https://www.nodejs.red/#/nodejs/events?id=%e7%bc%96%e7%a0%81%e5%ae%9e%e7%8e%b0\">https://www.nodejs.red/#/nodejs/events?id=编码实现</a></p>\n<p>这个解决并发问题的下面大篇幅的讲了 once 和 on 的区别，但是我亲手实践发现这里文件查找的例子将 once 换成 on 结果也是一样的， 这里难道不是基于 status 控制状态，readFile 是异步所以才能产生这个结果吗，为什么非要用 once 来解决，感觉用 on 来解决这里的问题也是一样的。。</p>\n</div>",
      "title": "Node Events 事件触发器 once 问题",
      "author": {
        "loginname": "HelloAny",
        "avatar_url": "https://avatars.githubusercontent.com/u/44696899?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 74,
      "country": "Japan"
    },
    {
      "id": "6144bd3ffe0c51544daea809",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/yobett/oec-nest\">https://github.com/yobett/oec-nest</a>\n我用了几个月了，欢迎加入</p>\n</div>",
      "title": "开源一个nest.js项目（BTC/ETH...交易助手）",
      "author": {
        "loginname": "yobett",
        "avatar_url": "https://avatars.githubusercontent.com/u/90440882?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 75,
      "country": "China"
    },
    {
      "id": "6166947fdfe3c98942f2aeae",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FnHdbv0fiecHiH3H0jn7R2unec2X\" alt=\"1634112530(1).png\"></p>\n<p><img src=\"//static.cnodejs.org/FtOk52mqxjQEnpse55T4u0-aGgDN\" alt=\"1634112582(1).png\">\n我的这个request请求用户名和密码想用evn文件定义的内容，我在文件头已经含包文件require(‘dotenv’).config();但是在测试这个程序时，服务器每一次都返回权限不对， 但是我不用这个process.env.*直接把env中的用户名和密码写上再运行这个程序，服务器就不报权限错误，不知道这是什么原因造成，编译器也没有语法报错，请大神们指点 一下？</p>\n</div>",
      "title": "我想问一下在node.js的request中怎样使用env文件定义用户名和密码？",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 76,
      "country": "USA"
    },
    {
      "id": "6166976bdfe3c9b15af2aee1",
      "content": "<div class=\"markdown-text\"><p>这是我的一个程序代码，\n<img src=\"//static.cnodejs.org/Fjv9TXXFEahcZwd_V12AsgikU_5w\" alt=\"1634113342(1).png\">\n（这个apiUrl是一个网址：<a href=\"http://localhost:8081/api/v4/clients/IotApp%2F1XBZ5x3PO%2Fconnect_to_server\">http://localhost:8081/api/v4/clients/IotApp%2F1XBZ5x3PO%2Fconnect_to_server</a>)\n这个划红线的变量的值 是IotApp/1XBZ5x3PO/connect_to_server，用什么软件包能把它进行urlEncode编码成IotApp%2F1XBZ5x3PO%2Fconnect_to_server，请高手指教一下的？</p>\n</div>",
      "title": "我想问一下怎样在node.js中的request中进行urlEncode编码",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 77,
      "country": "China"
    },
    {
      "id": "6167df78dfe3c92f44f2b131",
      "content": "<div class=\"markdown-text\"><p>关注<a href=\"https://github.com/simon9124/my_demos/blob/master/README.md\">前端小讴</a>，阅读更多原创技术文章</p>\n<p><a href=\"https://cnodejs.org/topic/6165274cfe0c51db3baee418\">回顾：Promise源码渐进式解读（一）</a></p>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97/javascript/Promise/Promise%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81%2B%E6%B3%A8%E9%87%8A.js\">完整代码+注释</a>，可对照阅读</p>\n<h2>Promise.resolve - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Promise构造函数的resolve属性，指向函数\n * 参数value：解决值\n *&#x2F;\nPromise.resolve = function (value) {\n  &#x2F;* 如果解决值的constructor属性指向Promise构造函数（即解决值是Promise实例） *&#x2F;\n  if (value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; value.constructor === Promise) {\n    return value &#x2F;&#x2F; 返回这个Promise实例\n  }\n\n  &#x2F;* 解决值不是Promise实例，返回新的Promise实例并调用其成功回调，参数作为解决值 *&#x2F;\n  return new Promise(function (resolve) {\n    resolve(value)\n  })\n}\n</code></pre><ul>\n<li>调用<code>Promise.resolve()</code>，相当于<code>new Promise(resolve=&gt;{resolve()})</code>，参数作为解决值</li>\n<li>若参数为<code>Promise</code>对象，则返回这个对象</li>\n</ul>\n<h2>Promise.reject - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Promise构造函数的reject属性，指向函数\n * 参数value：拒绝理由\n *&#x2F;\nPromise.reject = function (value) {\n  &#x2F;* 返回新的Promise实例并调用其失败回调，参数作为拒绝理由 *&#x2F;\n  return new Promise(function (resolve, reject) {\n    reject(value)\n  })\n}\n</code></pre><ul>\n<li>调用<code>Promise.reject</code>，相当于<code>new Promise(resolve=&gt;{reject()})</code>，参数作为拒绝理由</li>\n<li><strong>与<code>Promise.resolve()</code>不同的是</strong>，即便参数为<code>Promise</code>对象，也将其整体作为<code>new Promise</code>失败回调时的拒绝理由</li>\n</ul>\n<h2>Promise.resolve &amp; Promise.reject - 阶段测试</h2>\n<ul>\n<li><code>Promise.resolve</code>和<code>Promise.reject</code>其实就是<code>new Promise</code>的封装，注意观察<strong>参数为<code>Promise</code>实例时二者结果上的不同</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>Promise.resolve(3) &#x2F;&#x2F; &#x27;resolve:3&#x27;，解决值为基本类型\n&#x2F;* self为Promise { _state: 1, _handled: false, _value: 3, _deferreds: [] } *&#x2F;\nPromise.resolve({ val: 3 }) &#x2F;&#x2F; &#x27;resolve:[object Object]&#x27;，解决值为普通对象\n&#x2F;* self为Promise { _state: 1, _handled: false, _value: { val: 3 }, _deferreds: [] } *&#x2F;\nPromise.resolve(Promise.resolve(3)) &#x2F;&#x2F; &#x27;resolve:3&#x27;，解决值为期约实例\n&#x2F;* self为Promise { _state: 1, _handled: false, _value: 3, _deferreds: [] } *&#x2F;\nPromise.resolve({\n  &#x2F;&#x2F; 解决值为thenable对象\n  value: 3,\n  then: function () {\n    console.log(this) &#x2F;&#x2F; { value: 3, then: [Function: then] }，this指向解决值本身\n    console.log(this.value) &#x2F;&#x2F; 3\n  },\n})\nPromise.reject(3) &#x2F;&#x2F; &#x27;reject:3&#x27;，拒绝理由为基本类型\n&#x2F;* self为Promise { _state: 2, _handled: false, _value: 3, _deferreds: [] } *&#x2F;\nPromise.reject(Promise.resolve(3)) &#x2F;&#x2F; &#x27;reject:[object Object]&#x27;，拒绝理由为期约实例（此处与Promise.resolve()区分）\n&#x2F;* self为Promise { _state: 2, _handled: false, _value: Promise { _state: 1, _handled: false, _value: 3, _deferreds: [] }, _deferreds: [] } *&#x2F;\n</code></pre><h2>Promise._immediateFn - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Promise构造函数的_immediateFn属性，指向函数\n * 参数fn：要执行的方法（**注意：是异步调用**）\n *&#x2F;\nvar setTimeoutFunc = setTimeout\nvar setImmediateFunc = typeof setImmediate !== &#x27;undefined&#x27; ? setImmediate : null &#x2F;&#x2F; 判断浏览器是否有setImmediate方法\n\nPromise._immediateFn =\n  typeof setImmediateFunc === &#x27;function&#x27; &#x2F;&#x2F; 判断setImmediateFunc是否为函数对象\n    ? function (fn) {\n        setImmediateFunc(fn) &#x2F;&#x2F; 异步调用fn方法（立即）\n      }\n    : function (fn) {\n        setTimeoutFunc(fn, 0) &#x2F;&#x2F; 异步调用fn方法（0毫秒后）\n      }\n</code></pre><ul>\n<li>根据浏览器是否有<code>setImmediate</code>方法，指向不同</li>\n<li>但殊途同归，都是<strong>异步执行</strong>传入的方法</li>\n</ul>\n<h2>Promise._unhandledRejectionFn - 源码</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** Promise构造函数的_unhandledRejectionFn属性，指向函数\n * 参数err：拒绝理由\n *&#x2F;\nPromise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== &#x27;undefined&#x27; &amp;&amp; console) {\n    console.warn(&#x27;Possible Unhandled Promise Rejection:&#x27;, err) &#x2F;&#x2F; 浏览器给出警告\n  }\n}\n</code></pre><ul>\n<li>封装：失败回调时，在浏览器给出警告</li>\n</ul>\n<h2>finale() - 测试代码</h2>\n<ul>\n<li>更新手写的测试<code>finale()</code>方法，加入浏览器警告，使其更趋近于源码，方便做阶段测试</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>&#x2F;** 测试用的finale()方法\n * 参数self：（期约）实例\n *&#x2F;\nfunction finale(self) {\n  &#x2F;&#x2F; console.log(self)\n  &#x2F;&#x2F; if (self._state === 1) {\n  &#x2F;&#x2F;   console.log(&#x27;resolve:&#x27; + self._value)\n  &#x2F;&#x2F; } else if (self._state === 2) {\n  &#x2F;&#x2F;   console.log(&#x27;reject:&#x27; + self._value)\n  &#x2F;&#x2F; } else if (self._state === 3) {\n  &#x2F;&#x2F;   console.log(&#x27;resolve value is Promise&#x27;)\n  &#x2F;&#x2F; }\n\n  &#x2F;* 如果_state的值为2（失败回调），且_deferreds数组长度为0，则给出警告 *&#x2F;\n  if (self._state === 2 &amp;&amp; self._deferreds.length === 0) {\n    &#x2F;**\n     * 调用Promise构造函数的_immediateFn方法\n     * 参数fn：要执行的警告方法\n     *&#x2F;\n    Promise._immediateFn(function () {\n      &#x2F;* 如果未被处理过，则给出警告 *&#x2F;\n      if (!self._handled) {\n        &#x2F;**\n         * 调用Promise构造函数的._unhandledRejectionFn方法\n         * 参数self._value：拒绝理由\n         *&#x2F;\n        Promise._unhandledRejectionFn(self._value)\n      }\n    })\n  }\n}\n</code></pre><ul>\n<li>如果是失败回调（拒绝的期约），且<code>_deferreds</code>数组长度为 0，则给出警告</li>\n<li><code>_deferreds</code>数组长度由<code>Promise.reject()</code>后面是否有<code>catch</code>决定，详见后续</li>\n</ul>\n<h2>浏览器警告 - 阶段测试</h2>\n<pre class=\"prettyprint language-js\"><code>new Promise((resolve, reject) =&gt; {\n  reject(2) &#x2F;&#x2F; Possible Unhandled Promise Rejection: 2\n})\nPromise.reject(3) &#x2F;&#x2F; Possible Unhandled Promise Rejection: 3\nPromise.resolve(Promise.reject(4)) &#x2F;&#x2F; Possible Unhandled Promise Rejection: 4\nPromise.reject(Promise.reject(5)) &#x2F;&#x2F; Possible Unhandled Promise Rejection: Promise { _state: 2, _handled: false, _value: 5, _deferreds: [] }\n</code></pre><h2>实现结果总结</h2>\n<ul>\n<li><code>Promise.resolve</code>和<code>Promise.reject</code>对<code>new Promise</code>的基础上加以封装</li>\n<li><code>Promise.resolve</code>的参数若是期约，则返回该期约</li>\n<li>失败的回调暂时会在浏览器给出警告</li>\n</ul>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97/javascript/Promise/Promise%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB2.js\">截至本节的代码 →</a></p>\n</div>",
      "title": "Promise源码渐进式解读（二）",
      "author": {
        "loginname": "simon9124",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 78,
      "country": "Japan"
    },
    {
      "id": "61652f77fe0c512de1aee439",
      "content": "<div class=\"markdown-text\"><p>用命令行脚本生成数据库表</p>\n</div>",
      "title": "nodejs有db migration的package吗?",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 79,
      "country": "China"
    },
    {
      "id": "6162ef0cfe0c510578aedf4d",
      "content": "<div class=\"markdown-text\"><p>发布package的话又用哪种比较好？</p>\n</div>",
      "title": "现在后端应该转用esm还是继续保持commonjs？",
      "author": {
        "loginname": "takayama-lily",
        "avatar_url": "https://avatars.githubusercontent.com/u/12014361?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 80,
      "country": "Eurozone"
    },
    {
      "id": "590d3b633504ce1c2ac45904",
      "content": "<div class=\"markdown-text\"><p>我想创业。我想问一下，你们公司的老板给员工翻墙（只是在办公场所内翻墙，用于工作）是提供的什么VPN？这需不需要向有关部门登记呀？如果不登记，会不会遭到惩罚？</p>\n</div>",
      "title": "翻墙（办公用途）需要登记吗？",
      "author": {
        "loginname": "zhanzhenzhen",
        "avatar_url": "https://avatars3.githubusercontent.com/u/731796?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 83,
      "country": "USA"
    },
    {
      "id": "51bfe91daae4fcf74c01bbff",
      "content": "<div class=\"markdown-text\"><p>翻出来一些旧的资源:</p>\n<p>Lepture 写的编辑器: <a href=\"http://lab.lepture.com/editor/\">http://lab.lepture.com/editor/</a>\n来自一淘的介绍博客: <a href=\"http://ux.etao.com/posts/620\">http://ux.etao.com/posts/620</a>\n一个很漂亮的在线 Markdown Editor: <a href=\"http://oscargodson.github.io/EpicEditor/\">http://oscargodson.github.io/EpicEditor/</a>\nCheatSheet: <a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\">https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet</a>\n一个 Ubuntu 下的 Markdown 编辑器: <a href=\"http://uberwriter.wolfvollprecht.de/\">http://uberwriter.wolfvollprecht.de/</a>\nSublime 插件: <a href=\"http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/\">http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/</a>\n一个加简单的 Markdown 预览工具: <a href=\"http://joncom.be/experiments/markdown-editor/edit/\">http://joncom.be/experiments/markdown-editor/edit/</a>\nMou 是 Mac 下的一个 Markdown 编辑器: <a href=\"http://mouapp.com/\">http://mouapp.com/</a>\nMarkdown 语法说明: <a href=\"http://markdown.tw/\">http://markdown.tw/</a></p>\n<p>希望没用上 Markdown 的同学尽快跟上, 提升论坛的体验,\n最近论坛更改比较多, 可以看 Github 上的 Issue, 比如 watch 一下…\n<a href=\"https://github.com/cnodejs/nodeclub/issues?state=open\">https://github.com/cnodejs/nodeclub/issues?state=open</a>\n当中有聊 Markdown 的, 总之希望能尽快跟上吧</p>\n</div>",
      "title": "讲 Markdown 的帖子又来了",
      "author": {
        "loginname": "jiyinyiyong",
        "avatar_url": "https://avatars.githubusercontent.com/u/449224?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 84,
      "country": "China"
    },
    {
      "id": "6163dff8fe0c510d36aee168",
      "content": "<div class=\"markdown-text\"><p>最近在读vue的源码，根据源码改写的方法想做一些测试，不巧的是总会报<code>SyntaxError: Unexpected token ':'</code>，请问flow.js在vscode中怎么跑起来呀（只是想在单独的js文件中不报错）？</p>\n</div>",
      "title": "求助：flow.js",
      "author": {
        "loginname": "simon9124",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 85,
      "country": "China"
    },
    {
      "id": "6162a479fe0c51b270aedef7",
      "content": "<div class=\"markdown-text\"><p>有人能安装成功吗?</p>\n</div>",
      "title": "npm install  semantic-ui 提示ReferenceError: primordials is not defined",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 86,
      "country": "Eurozone"
    },
    {
      "id": "61603b10fe0c519e27aed518",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fnz0IqJhaiuV67-uu_e_I8hAFI8q\" alt=\"image.png\"></p>\n</div>",
      "title": "mac安装mongodb速度太慢,如何解决",
      "author": {
        "loginname": "huge689",
        "avatar_url": "https://avatars.githubusercontent.com/u/44516016?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 87,
      "country": "China"
    },
    {
      "id": "6162a776fe0c5111eeaedf01",
      "content": "<div class=\"markdown-text\"><p>如图, 加载的时候报第一个参数不是一个构造函数, 本质上第一个参数是export出来的class\n<img src=\"//static.cnodejs.org/Fg5a-GG5IMfxVkKBEaFCTBtDbgWJ\" alt=\"image.png\"></p>\n</div>",
      "title": "Eggjs 加载自定义目录的问题",
      "author": {
        "loginname": "InCodingNowLiu",
        "avatar_url": "https://avatars.githubusercontent.com/u/31758568?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 88,
      "country": "USA"
    },
    {
      "id": "6162ee1bfe0c519110aedf34",
      "content": "<div class=\"markdown-text\"><p>外层用flex设置布局，外层有较大的空白区域，  用flex宽度改变后不影响整体效果\n内层内容用float  只需要设置第一个节点float ，如果用flex 需要设置两层，这样会加深嵌套层级  而且内层内容节点一般比较密集，用不用flex看不出区别  另外float 全兼容，旧的浏览器看虽然外层样式乱了，但是内容还是很整齐</p>\n</div>",
      "title": "flex+float ff组合",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 89,
      "country": "USA"
    },
    {
      "id": "615db934fe0c51196faecd53",
      "content": "<div class=\"markdown-text\"><p>起因是之前无聊搞了个《塞尔达》游戏的希卡文生成/翻译器，文字翻译的实现是通过<strong>相似图片</strong>识别实现的，比较简单暴力，通用性也不是很高。最近正在摸一些机器学习的东西，正好看到一个卷积神经的经典示例：<a href=\"https://github.com/tensorflow/tfjs-examples/tree/master/mnist\">手写数字分类 MNIST</a>，于是依葫芦画瓢重新实现了希卡文翻译器。</p>\n<p>工具地址：<a href=\"https://kinglisky.github.io/zelda-words/index.html\">https://kinglisky.github.io/zelda-words/index.html</a></p>\n<p>仓库地址：<a href=\"https://github.com/kinglisky/zelda-words\">https://github.com/kinglisky/zelda-words</a></p>\n<p>前文：<a href=\"https://juejin.cn/post/6941003131891220517\">从希卡文翻译谈谈 OCR 的简单实现</a></p>\n<p>工具的功能很简单，可以实现《塞尔达》游戏中英文到希卡族文字的转换并下载成图片，也可将生成的席卡文图片翻译出来。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37470daa9c6041ea8f8e7e3be0dadfb1~tplv-k3u1fbpfcp-watermark.image?\" alt=\"output.gif\"></p>\n<p>对于图片的处理与文字切割这里就不做赘述了，有兴趣的同学可以看看前文的处理，我们重点来看看如果依葫芦画瓢实现一个希卡文识别的卷积神经网络模型。</p>\n<h2>如何画一只马</h2>\n<p>还是那个经典的问题，咱们先来看看如何画一只马：</p>\n<ul>\n<li>生成训练与测试数据</li>\n<li>训练与评估模型</li>\n<li>使用训练模型进行文字预测识别</li>\n</ul>\n<p>很简单嘛，就三步，咱们一步步来~</p>\n<h2>生成训练数据</h2>\n<p>要说前端机器学习，自然而然会想到 <a href=\"https://www.tensorflow.org/js?hl=zh-cn\"># TensorFlow.js</a>，我们下面的对于希卡文识别模型的实现是基于官方提供的一个<a href=\"https://github.com/tensorflow/tfjs-examples/tree/master/mnist\">手写数字分类 MNIST </a>的例子实现的，有兴趣的同学可以跑跑这个例子。</p>\n<blockquote>\n<p>MNIST 数据集表示经过改进的 NIST 数据集。其中，NIST 是美国国家标准与技术研究所（National Institute of Standards and Technology）的简称，这是因为 NIST 数据集是由该研究所收集并整理完成的。M 表示“经过改进”的（modified），体现了MNIST数据集是在原 NIST 数据集基础之上所做的改进。MNIST 数据集主要改进了两个方面：第一，将图像标准化为统一的 <strong>28 像素 × 28 像素</strong>，并进行抗锯齿处理，这让训练集和测试集更加一致；第二，确保训练集和测试集的手写数字来自没有重合的两组参与者。这些改进让数据集变得更易用，并且能够更加客观地计算模型的准确率。</p>\n</blockquote>\n<p>官方例子处理的是 0~9 十个手写数字分类的问题，而我们需要实现 40 希卡字符分类问题，大差不差。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54d0e5294a594172a42b68a57339f0a6~tplv-k3u1fbpfcp-watermark.image?\" alt=\"1.jpeg\"></p>\n<h3>张量与图片的 NHWC 编码</h3>\n<p>在 TensorFlow 中就如同它的名字一样，一切皆为张量（Tensor），我们所有需要处理的数据都得转换成张量的形式，张量是什么呢？一维的数组人们管它叫矢量，二维的数组叫做矩阵，那么三维、四维、N 维数组呢？起个名字就叫张量吧。这里简单的理解张量就是一个多维数组。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 一维张量\n[1, 0, 0]\n\n&#x2F;&#x2F; 二维张量\n[\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1],\n]\n\n&#x2F;&#x2F; 三维张量\n[\n    [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ],\n    [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ],\n    [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ]\n]\n&#x2F;&#x2F; ... N 维张量\n</code></pre><p>那我们应该如何用张量来表示一张图片呢？先来看一张只有四像素（2 x 2）的图片，图片只有第一个像素有值（白色），我们可以用一个三维张量来表示，这里不考虑图片的 alpha 通道，表示如下：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26d9ce6ca5f04b8494cfa65096c0c80e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"0.jpeg\"></p>\n<pre class=\"prettyprint language-javascript\"><code>[\n    &#x2F;&#x2F; 第一行像素\n    [\n        [255, 255, 255], &#x2F;&#x2F; rgb 通道值\n        [0, 0, 0],\n    ],\n    &#x2F;&#x2F; 第二行像素\n    [\n        [0, 0, 0],\n        [0, 0, 0],\n    ],\n]\n</code></pre><p>如果是一张灰度图片（只有一个颜色通道）我们可以这样表示：</p>\n<pre class=\"prettyprint language-javascript\"><code>[\n    &#x2F;&#x2F; 第一行像素\n    [\n        [255], &#x2F;&#x2F; 只有一个灰度通道\n        [0],\n    ],\n    &#x2F;&#x2F; 第二行像素\n    [\n        [0],\n        [0],\n    ],\n]\n</code></pre><p>TensorFlow 有个张量<strong>形状</strong>的概念，简单来说就是用一个数组来描述张量每一维度的长度，有兴趣的同学可以看看<a href=\"https://www.tensorflow.org/guide/tensor?hl=zh-cn#%E5%BD%A2%E7%8A%B6%E7%AE%80%E4%BB%8B\">张量的形状</a>的定义。</p>\n<p>上面的 RGB 图片与灰度图片的张量形状分别是：<code>[2, 2, 3]</code> 和 <code>[2, 2, 1]</code>，一般情况我们都可以将图片以如下形状张量来表示：</p>\n<pre class=\"prettyprint language-javasscript\"><code>[height, width, colorChannel]\n</code></pre><p>机器学习往往会涉及大量训练数据，有时考虑到数据储存大小，会对数据进行编码压缩操作，例如上面灰度图片的三维张量我们可以<strong>展平成一维数组</strong>来表示：</p>\n<pre class=\"prettyprint language-javascript\"><code>[\n    &#x2F;&#x2F; 第一行像素\n    [\n        [255], &#x2F;&#x2F; 只有一个灰度通道\n        [0],\n    ],\n    &#x2F;&#x2F; 第二行像素\n    [\n        [0],\n        [0],\n    ],\n]\n\n&#x2F;&#x2F; 转换成一维数组\n\n[255, 0, 0, 0]\n</code></pre><blockquote>\n<p>这种图像编码格式叫作 <strong>HWC</strong> 格式，即 “高度–宽度–颜色通道”（height-width-channel）格式。在对图像进行深度学习时，通常会将多张图片数据组合成一个批次，这样可以更高效地进行并行计算。在将图像打包成批次时，表示各个图像的维度总是第 1 个维度，因此，图像批次是一个四维张量，这四个维度分别是图像编号（N）、高度（H）、宽度（W）和颜色通道（C），这种编码格式叫作 <strong>NHWC</strong> 格式。</p>\n</blockquote>\n<p>假设我们有两张 HWC 编码格式的灰度图片（2x2 大小），转成 NHWC 的格式存储如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>[255, 0, 0, 0] &#x2F;&#x2F; 图片 1（HWC）\n[0, 255, 0, 0] &#x2F;&#x2F; 图片 2（HWC）\n\n[255, 0, 0, 0, 0, 255, 0, 0] &#x2F;&#x2F; 组合成批次（NHWC）\n</code></pre><p>我们将使用 NHWC 格式作为图像编码格式，这也是 TensorFlow 默认支持的格式。</p>\n<p>监督学习中对于每一个样本我们都需要提供一个输入与输出项（目标）。在手写数字分类中是输入图片与图片内容对应的数字，而在希卡文分类中是输入的图片与对应的字符的索引。</p>\n<h3>确认样本特征</h3>\n<p>因为希卡文翻译问题本质就是<strong>字符图片的分类</strong>问题，我们会提取出图片中每个希卡文字符与对应的 40 个英文字符进行分类，字符映射规则如下：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/569151f8df03479fbccd008ac8610a3c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"ocr-map.jpeg\"></p>\n<p>再来看一眼生成的希卡文图片特征再来决定我们应该生成怎样的训练图片：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c947e96146941c2a5f9c79a021dc405~tplv-k3u1fbpfcp-watermark.image?\" alt=\"3.png\"></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acb401e9d1194cc0994cf9071984fd0f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"4.png\"></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c60d9bbb0eb43ec92e8f8134244b06a~tplv-k3u1fbpfcp-watermark.image?\" alt=\"2.png\"></p>\n<p>希卡字符图片的尺寸、文字颜色与文字背景都不尽相同，我们可以根据这些特征，生成训练图片：</p>\n<ul>\n<li>图片文字不同</li>\n<li>图片大小不同</li>\n<li>图片的文字颜色不同</li>\n<li>图片的背景颜色不同</li>\n</ul>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3f2d4b5d4c84ad7b803977147e4b76e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"5.jpg\"></p>\n<p>按照上述的特征，我们可以随机生成不同训练图片。但这里有个疑问，它们是合适的训练集吗？</p>\n<p>会问出这个问题答案显然不是，最早模拟训练集图片时我想着丰富样本的特性，还为生成的训练图片新增旋转与拉伸一类特性，想着训练出模型可以适应更多的场景，结果不言而喻。实际训练出的模型并不能达到使用的水准，原因出在哪呢？</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3df231c07e47482491ce9c4734b7498b~tplv-k3u1fbpfcp-watermark.image?\" alt=\"6.png\"></p>\n<p>答案是<strong>样本的特征定义并不准确</strong>，实际应用中我们应该<strong>精简样本特征</strong>，尽量选择具有代表性特征，弱化或剔除不相关的特征。希卡文的识别其实最为重要就是<strong>图片内容</strong>（文字的形状），文字颜色和背景颜色无论如何变化都不会影响希卡文最终识别，所以这两特征是多余特征可以剔除掉。那为什么图片的大小需要考虑进来呢？</p>\n<p>因为我们本身生成希卡文图片的文字大小并不相同，在最终生成训练数据图片需要统一转成 28 x 28 的尺寸，和 MNIST 数据集保持一致，不同尺寸大图片缩放到 28 x 28 尺寸时图片都会有不同程度的噪化，想想原本 200 x 200 字符图片缩小到 28 像素时文字会出现模糊情况，这会影响文字的形状，所以需要把大小这一特征考虑进来。所以我们的训练图片特征应该是两点：</p>\n<ul>\n<li>图片的文字不同</li>\n<li>图片的大小不同</li>\n</ul>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/392423eafe364676ba019202ebff0424~tplv-k3u1fbpfcp-watermark.image?\" alt=\"7.jpg\"></p>\n<p>生成的训练图片如上图所示，实际我们在解析图片拆分希卡字符图片是也会做一层处理，也会将所有字符的文字颜色统一白色（255）背景统一成黑色（0），这样就能与训练的数据保持一致了。</p>\n<h3>生成训练图片</h3>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d2ed8fcd3f342b2a3c0232f946d9bca~tplv-k3u1fbpfcp-watermark.image?\" alt=\"9.jpg\"></p>\n<p>希卡文字符的原始图片是 40 字符对应的 svg 图片，<a href=\"https://github.com/kinglisky/zelda-words/tree/master/src/assets/sheikah-icon\">希卡文字符文件集合</a>如上，我们可以生成一份字符图片路径的配置文件：</p>\n<pre class=\"prettyprint language-json\"><code>&#x2F;&#x2F; words.json\n[\n    {\n        &quot;symbol&quot;: &quot;a&quot;,\n        &quot;path&quot;: &quot;sheikah-icon&#x2F;a.svg&quot;\n    },\n    {\n        &quot;symbol&quot;: &quot;b&quot;,\n        &quot;path&quot;: &quot;sheikah-icon&#x2F;b.svg&quot;\n    },\n    {\n        &quot;symbol&quot;: &quot;c&quot;,\n        &quot;path&quot;: &quot;sheikah-icon&#x2F;c.svg&quot;\n    },\n    ......\n]\n</code></pre><p>文字内容由 path 构成（默认是黑色），而我们想要的<strong>白色的文字</strong>与<strong>黑色的背景</strong>，所以需要稍稍改造下 svg 图片的内容使它可以支持颜色的填充：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0815ef4e6cfc4e7b89dbbf332b900fd8~tplv-k3u1fbpfcp-watermark.image?\" alt=\"10.jpg\"></p>\n<pre class=\"prettyprint language-JavaScript\"><code>function fillSvg(svg, color) {\n    const $ = cheerio.load(svg, { xmlMode: true });\n    const fill = Color(color).hex();\n    $(&#x27;svg&#x27;).attr(&#x27;fill&#x27;, fill);\n    return $.xml();\n}\n\nasync function loadSvg(word) {\n    const svgPath = path.join(__dirname, &#x27;..&#x2F;src&#x2F;assets&#x27;, word.path);\n    const data = await readFile(svgPath, &#x27;utf8&#x27;);\n    &#x2F;&#x2F; 文字填充为白色\n    const svgContent = fillSvg(data, {\n        r: 255,\n        g: 255,\n        b: 255,\n    });\n    return Buffer.from(svgContent);\n}\n</code></pre><p>将 svg 填充色指定为白色后，需要做一个随机的大小缩放然后与黑色背景做融合；这里我们使用了 <a href=\"https://github.com/lovell/sharp\">sharp</a> 库来处完成我们的操作，sharp 是个非常好用的 node 图片处理库，实现上述的操作也十分简单，直接上代码了：</p>\n<pre class=\"prettyprint language-JavaScript\"><code>const IMAGE_WIDTH = 28;\nconst IMAGE_HEIGHT = 28;\n\nfunction randomValue(value, base = 0) {\n    return Math.floor(Math.random() * value + base);\n}\n\nasync function createWordImage(word) {\n    const size = randomValue(200, 24);\n    const svg = await loadSvg(word);\n    &#x2F;&#x2F; 生成大小不同的图片\n    const resizeImageBuffer = await sharp(svg)\n        .resize(size, size)\n        .trim()\n        .png().toBuffer();\n    &#x2F;&#x2F; 统一缩放成 28 x 28 大小\n    const wordImageBuffer = await sharp(resizeImageBuffer)\n        .resize(IMAGE_WIDTH, IMAGE_HEIGHT)\n        .png().toBuffer();\n    &#x2F;&#x2F; 字符背景图片\n    const baseImageBuffer = await sharp({\n        create: {\n            width: IMAGE_WIDTH,\n            height: IMAGE_HEIGHT,\n            channels: 4,\n            background: {\n                r: 0,\n                g: 0,\n                b: 0,\n                alpha: 0,\n            },\n        }\n    }).png().toBuffer();\n    &#x2F;&#x2F; 将文字图片绘制到背景图片上，做锐化并且以 raw 格式输出\n    const image = await sharp(baseImageBuffer).composite([{\n        input: wordImageBuffer,\n        top: 0,\n        left: 0,\n    }]).sharpen().raw().toBuffer();\n    return image;\n}\n</code></pre><p>sharp 中我们可以将图片导出成 buffer 来使用，最后一步我们将文字与背景图片融合后导出，导出前加了两个操作：</p>\n<ul>\n<li>sharpen 图片锐化抗锯齿处理</li>\n<li>raw 格式导出 buffer</li>\n</ul>\n<p>锐化是为了突出图片文字的形状特征，raw 格式的 buffer 数据格式与 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data\">ImageData.data</a> 一致，每个像素点由 rgba 通道值组成。</p>\n<p>我们完成了单张图片的生成，接下来就是批量随机生成图片集合了，操作也很简单：</p>\n<pre class=\"prettyprint language-JavaScript\"><code>const tf = require(&#x27;@tensorflow&#x2F;tfjs&#x27;);\nconst WORDS = require(&#x27;..&#x2F;src&#x2F;data&#x2F;words.json&#x27;);\nconst WORDS_INDEXS = Array.from({ length: WORDS.length }).map((_, i) =&gt; i);\nconst IMAGE_WIDTH = 28;\nconst IMAGE_HEIGHT = 28;\nconst COUNT = 100;\nconst NAME = &#x27;train&#x27;;\n\n(async function main() {\n    let data = null;\n    const indexs = [];\n    for (let i = 0; i &lt; COUNT; i++) {\n        &#x2F;&#x2F; 打乱字符 40 字符索引顺序\n        tf.util.shuffle(WORDS_INDEXS);\n        const createWords = WORDS_INDEXS.map(async (index) =&gt; {\n            const word = WORDS[index];\n            const buffer = await createWordImage(word);\n            return {\n                index,\n                buffer,\n            };\n        });\n        const res = await Promise.all(createWords);\n        res.forEach(({ index, buffer }) =&gt; {\n            const pixs = [];\n            &#x2F;&#x2F; rgb 转灰度\n            for (let i = 0; i &lt; buffer.length; i += 4) {\n                const a = buffer[i + 3] &#x2F; 255;\n                const r = buffer[i] * a;\n                const g = buffer[i + 1] * a;\n                const b = buffer[i + 2] * a;\n                pixs.push(Math.floor(r * 0.299 + g * 0.587 + b * 0.114));\n            }\n            indexs.push(index);\n            const pixsBuffer = Buffer.from(pixs);\n            &#x2F;&#x2F;  buffer 拼接图片\n            data = data ? Buffer.concat([data, pixsBuffer]) : pixsBuffer;\n        });\n        const meta = {\n            indexs,\n            count: (i + 1) * WORDS_INDEXS.length,\n            width: IMAGE_WIDTH,\n            height: IMAGE_HEIGHT,\n            buffer: &#96;${NAME}.buffer&#96;,\n        };\n        &#x2F;&#x2F; 保存训练数据\n        await writeFile(path.join(__dirname, &#96;..&#x2F;src&#x2F;data&#x2F;${NAME}.buffer&#96;), data);\n        await writeFile(path.join(__dirname, &#96;..&#x2F;src&#x2F;data&#x2F;${NAME}.json&#96;), JSON.stringify(meta));\n    }\n    console.log(&#x27;done!&#x27;);\n})();\n</code></pre><p>这里需要注意一点，在 <code>createWordImage</code> 导出的是包含 RGBA 通道的 buffer 数据（形状为<code>[28, 28, 4]</code>），而最终我们使用的图片数据形状应该是 <code>[28, 28, 1]</code> ，所以需要生成 buffer 需要将图片转成灰度图片，只保留一个颜色通道。另一个就是需要将每张图片对应的席卡文符号<strong>索引</strong>需要记录下来作为每个样本的输出项。</p>\n<p>接下来就是泡一杯茶，耐心的等待训练数据的生成的。实际操作中我生成训练集包含了 8000 希卡字符样例，测试集 1600 样例。</p>\n<p>这里稍微提一下<strong>测试集</strong>数据，我们使用训练集的数据训练完模型后，需要对模型的<strong>准确率</strong>做一个验证，测试集就是做校验用的样本集合，一般要求测试集的数据不能在<strong>训练集</strong>中出现过。</p>\n<p>具体的训练与测试集数据可以戳这儿：<a href=\"https://github.com/kinglisky/zelda-words/tree/master/src/data\">https://github.com/kinglisky/zelda-words/tree/master/src/data</a></p>\n<h2>训练与评估模型</h2>\n<h3>加载数据与 oneHot 编码</h3>\n<p>捣腾完训练数据后，训练的第一步就是将训练数据加载进来，训练数据是以 buffer 的二进制文件存储的，所以我们先提供个加载 buffer 文件的方法：</p>\n<pre class=\"prettyprint language-JavaScript\"><code>const loadBuffer = async (data) =&gt; {\n    const {\n        count,\n        width,\n        height,\n        url,\n        indexs,\n    } = data;\n    const buffers = await fetch(url).then(res =&gt; res.arrayBuffer());\n    const images = new Float32Array(new Uint8ClampedArray(buffers));\n    for (let i = 0; i &lt; images.length; i++) {\n        &#x2F;&#x2F; 将像素值统一成 0 ~ 1 Float32 值\n        images[i] = images[i] &#x2F; 255;\n    }\n    const labels = new Int32Array(indexs);\n    return {\n        count,\n        width,\n        height,\n        images,\n        labels,\n    };\n}\n</code></pre><p>这里有个特殊处理，我们将像素值除以 255 将其值变成变成了 0~1 区间的值，这其实是机器学习中处理数据的一种常规操作，为的是将输入的<strong>特征数值尽量统一在数量级</strong>上；举个例子，假设我们需要做一个黑洞的预测模型，有两个输入特征：</p>\n<ul>\n<li>黑洞体积（1 ~ 1000）</li>\n<li>黑洞质量（100000000 ~ 100000000000）</li>\n</ul>\n<p>这两个黑洞模型的特征值，存在 N 个数量集的差距，这在训练时会十分影响训练模型特征的权重，所以一般需要将差别较大的特征值统一在一个数量级内，常用的是换算成一个特征值区间内的比例系数。</p>\n<ul>\n<li>黑洞体积（0 ~ 1）</li>\n<li>黑洞质量（0 ~ 1）</li>\n</ul>\n<p>这样可以排除一些极端特征值的影响，另一方面也大大减小了数值计算的成本。接下来我们需要将加载 buffer 数据封装成 TensorFlow 需要的张量：</p>\n<pre class=\"prettyprint language-JavaScript\"><code>&#x2F;&#x2F; data.js\nimport * as tf from &#x27;@tensorflow&#x2F;tfjs&#x27;;\nimport TRAIN from &#x27;..&#x2F;data&#x2F;train.json&#x27;;\nimport TEST from &#x27;..&#x2F;data&#x2F;test.json&#x27;;\nimport trainBufferURL from &#x27;..&#x2F;data&#x2F;train.buffer?url&#x27;;\nimport testBufferURL from &#x27;..&#x2F;data&#x2F;test.buffer?url&#x27;;\n\nTRAIN.url = trainBufferURL;\nTEST.url = testBufferURL;\n\nexport const WORDS_COUNT = 40;\nexport const IMAGE_H = 28;\nexport const IMAGE_W = 28;\n\nclass Dataset {\n    constructor() {\n        this.dataset = {};\n    }\n\n    async loadData() {\n        const train = await loadBuffer(TRAIN);\n        const test = await loadBuffer(TEST);\n        this.dataset = {\n            train,\n            test,\n        };\n    }\n\n    getData(key) {\n        const target = this.dataset[key];\n        const imagesShape = [target.count, target.height, target.height, 1];\n        return {\n            &#x2F;&#x2F; 转成 [8000, 28, 28, 1] 的张量\n            images: tf.tensor4d(target.images, imagesShape),\n            &#x2F;&#x2F; 输出目标这里使用 oneHot 编码\n            labels: tf.oneHot(tf.tensor1d(target.labels, &#x27;int32&#x27;), WORDS_COUNT).toFloat(),\n        };\n    }\n    \n    &#x2F;&#x2F; 获取训练数据\n    getTrainData() {\n        return this.getData(&#x27;train&#x27;);\n    }\n    \n    &#x2F;&#x2F; 获取测试数据\n    getTestData(numExamples) {\n        const res = this.getData(&#x27;test&#x27;);\n        if (numExamples) {\n            return {\n                images: res.images.slice([0, 0, 0, 0], [numExamples, IMAGE_H, IMAGE_W, 1]),\n                labels: res.labels.slice([0, 0], [numExamples, WORDS_COUNT]),\n            };\n        }\n        return res;\n    }\n}\n\nexport const dataset = new Dataset();\n</code></pre><p>转换直接使用 <code>tf.tensor4d</code> 即可将 NHWC 的数据转成 [N, H, W, C] 形状的 4 维张量，需要特殊处理的是输出目标（labels），这里使用 <a href=\"https://zh.wikipedia.org/wiki/One-hot\">oneHot 编码</a>将原本形状为 [N] 的目标数据变成 [N, 40] 的形状。oneHot 编码简单理解就是对于分类目标进行二进制编码，举个例子：</p>\n<p>假设我们只有三个字符 ABC 需要识别，因为是分类问题， ABC 对应的索引是 012，索引看起来是连续的而实际对应是个分类问题，使用数据索引容易引起混淆，何不为 ABC 设置一个编码用来区分彼此：</p>\n<pre class=\"prettyprint language-JavaScript\"><code>const labels = tf.oneHot(tf.tensor1d([0, 1, 2], &#x27;int32&#x27;), 3);\nconsole.log(labels, labels.dataSync());\n</code></pre><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd00916818ba40269f7f0dec7c4d72fe~tplv-k3u1fbpfcp-watermark.image?\" alt=\"11.png\"></p>\n<pre class=\"prettyprint language-JavaScript\"><code>[0, 1, 2]\n&#x2F;&#x2F; 原本的 [N] 形状的数据变成了 [N, 3] 形状\n[\n    [1, 0, 0],\n    [0, 1, 0],\n    [0 0, 1],\n]\n</code></pre><ul>\n<li>A 索引为 0 对应编码 [1, 0, 0]</li>\n<li>B 索引为 1 对应编码 [0, 1, 0]</li>\n<li>C 索引为 2 对应编码 [0, 0, 1]</li>\n</ul>\n<p>一个分类对应一个唯一编码值，而且 oneHot 编码还与最终模型的预测结果相关，使用 tensorflow 训练模型做预测时，模型的输出结果并不会输出字符对应的索引值，而是各个分类的概率。假设我们模型预测输出为：</p>\n<pre class=\"prettyprint language-json\"><code>[\n    &#x2F;&#x2F; 001 -&gt; C\n    [\n        0.022, &#x2F;&#x2F; 0\n        0.024, &#x2F;&#x2F; 0\n        0.026, &#x2F;&#x2F; 1\n    ],\n    &#x2F;&#x2F; 010 -&gt; B\n    [\n        0.021, &#x2F;&#x2F; 0\n        0.028, &#x2F;&#x2F; 1\n        0.026, &#x2F;&#x2F; 0\n    ],\n    &#x2F;&#x2F; 100 -&gt; A\n    [\n        0.027, &#x2F;&#x2F; 1\n        0.024, &#x2F;&#x2F; 0\n        0.025, &#x2F;&#x2F; 0\n    ],\n]\n</code></pre><p>我们将预测输出数组中概率（数值）最大的设为 1 其他置为 0 即可得到一个 oneHot 编码，这个 oneHot 编码对应的分类就是我们预测结果。</p>\n<h3>训练模型</h3>\n<p>这里的模型我们直接使用 MNIST 示例的模型，先来看一下模型的定义：</p>\n<pre class=\"prettyprint language-JavaScript\"><code>import * as tf from &#x27;@tensorflow&#x2F;tfjs&#x27;;\nimport { IMAGE_H, IMAGE_W, WORDS_COUNT } from &#x27;.&#x2F;data&#x27;;\n\nfunction createModel() {\n    const model = tf.sequential();\n    &#x2F;&#x2F; conv2d 层，进行卷积操作\n    model.add(tf.layers.conv2d({\n        inputShape: [IMAGE_H, IMAGE_W, 1],\n        kernelSize: 3,\n        filters: 16,\n        activation: &#x27;relu&#x27;\n    }));\n    &#x2F;&#x2F; 卷积后进行池化\n    model.add(tf.layers.maxPooling2d({ poolSize: 2, strides: 2 }));\n    &#x2F;&#x2F; 在重复一次卷积与池化\n    model.add(tf.layers.conv2d({ kernelSize: 3, filters: 32, activation: &#x27;relu&#x27; }));\n    model.add(tf.layers.maxPooling2d({ poolSize: 2, strides: 2 }));\n    model.add(tf.layers.conv2d({ kernelSize: 3, filters: 32, activation: &#x27;relu&#x27; }));\n    &#x2F;&#x2F; 扁平化张量\n    model.add(tf.layers.flatten({}));\n    &#x2F;&#x2F; 添加层密集增加神经网络的容量\n    model.add(tf.layers.dense({ units: 64, activation: &#x27;relu&#x27; }));\n    &#x2F;&#x2F; 为多分类问题配置归一化指数激活函数\n    model.add(tf.layers.dense({ units: WORDS_COUNT, activation: &#x27;softmax&#x27; }));\n    return model;\n}\n</code></pre><p>这里不对模型做过多解释（我不会而已），拿来用就行。模型定义了一个 7 层网络结构，主要由卷积、池化与密集组成。卷积层与池化层用做图片的特征提取，密集层用于增加神经网络的容量，需要关注下最后一层的归一化 softmax 输出：</p>\n<pre class=\"prettyprint language-JavaScript\"><code>tf.layers.dense({ units: WORDS_COUNT, activation: &#x27;softmax&#x27; });\n</code></pre><p>还记得上文我们所说的最后预测结果是一个与 oneHot 对应的概率数组吗？这里定义了最终模型针对<strong>每个样本</strong>的预测输出是一个 WORDS_COUNT（40）长度的数组，数组的值经过 <a href=\"https://zh.wikipedia.org/wiki/Softmax%E5%87%BD%E6%95%B0\">softmax 激活函数</a>归一化处理后是一个处于 0~1 概率值。</p>\n<p>接下来就是训练模型了：</p>\n<pre class=\"prettyprint language-JavaScript\"><code>import * as tf from &#x27;@tensorflow&#x2F;tfjs&#x27;;\nimport { dataset, IMAGE_H, IMAGE_W, WORDS_COUNT } from &#x27;.&#x2F;data&#x27;;\n\nasync function train({ model, data }) {\n    model.compile({\n        &#x2F;&#x2F; RMSprop 优化器\n        optimizer: &#x27;rmsprop&#x27;,\n        &#x2F;&#x2F; 交叉熵损失函数\n        loss: &#x27;categoricalCrossentropy&#x27;,\n        &#x2F;&#x2F; 度量依据精度\n        metrics: [&#x27;accuracy&#x27;],\n    });\n    &#x2F;&#x2F; 每个批次选多少个样本\n    const batchSize = 400;\n    &#x2F;&#x2F; 校验集比例\n    const validationSplit = 0.15;\n    &#x2F;&#x2F; 训练轮次\n    const trainEpochs = 20;\n\n    let trainBatchCount = 0;\n    let trainEpochCount = 0;\n\n    const trainData = data.getTrainData();\n    const testData = data.getTestData();\n    &#x2F;&#x2F; 剔除掉校验集合后的总训练样本数量\n    const totalNumBatches = Math.ceil(trainData.images.shape[0] * (1 - validationSplit) &#x2F; batchSize) * trainEpochs;\n\n    let valAcc;\n    &#x2F;&#x2F; 执行模型训练\n    await model.fit(trainData.images, trainData.labels, {\n        batchSize,\n        validationSplit,\n        epochs: trainEpochs,\n        callbacks: {\n            &#x2F;&#x2F; 每个批次训练结束调用\n            onBatchEnd: async (batch, logs) =&gt; {\n                trainBatchCount++;\n                console.log(&#96;训练进度：${(trainBatchCount &#x2F; totalNumBatches * 100).toFixed(1)}%&#96;);\n                console.log(&#96;损失: ${logs.loss}&#96;);\n                console.log(&#96;准确率: ${logs.acc}&#96;);\n                await tf.nextFrame();\n            },\n            &#x2F;&#x2F; 每个轮次训练结束调用\n            onEpochEnd: async (epoch, logs) =&gt; {\n                trainEpochCount++;\n                valAcc = logs.val_acc;\n                console.log(&#96;训练进度：轮次 ${trainEpochCount}&#96;);\n                console.log(&#96;校验集损失: ${logs.val_loss}&#96;);\n                console.log(&#96;校验集准确率: ${logs.val_acc}&#96;);\n                await tf.nextFrame();\n            }\n        }\n    });\n    const testResult = model.evaluate(testData.images, testData.labels);\n    const testAccPercent = testResult[1].dataSync()[0] * 100;\n    const finalValAccPercent = valAcc * 100;\n    console.log(&#96;检验集准确率: ${finalValAccPercent.toFixed(1)}%&#96;);\n    console.log(&#96;测试集准确率: ${testAccPercent.toFixed(1)}%&#96;);\n    const saveResults = await model.save(&#x27;downloads:&#x2F;&#x2F;zelda-words-model&#x27;);\n    console.log(&#x27;保存模型&#x27;, saveResults);\n}\n\nasync function run() {\n    await dataset.loadData();\n    const model = createModel();\n    train({\n        model,\n        data: dataset,\n    });\n};\n</code></pre><p>模型的训练流程也和 MNIST 流程一致，我们主要关注几个训练参数：</p>\n<ul>\n<li><code>batchSize</code> 每个训练批次样本数量</li>\n<li><code>validationSplit</code> 训练时校验集比例</li>\n<li><code>trainEpochs</code> 训练次数（轮次）</li>\n</ul>\n<p>训练时我们不是一股脑将一堆数据全丢进去，需要拆分成多个批次，batchSize 用于设置每个批次样本数量，数量不宜太大也不宜太小，一般有训练集合数据量决定，我们这里设置是 400。</p>\n<p><code>validationSplit</code> 表示需要从训练集合取多大比例的样本数据用做校验，我们训练集有 8000 个样本，validationSplit 为 0.15，<code>8000 * 0.15 = 1200</code> 则每次训练我们从训练集中单独调出 1200 个样本用做校验，校验集的数据不会出现在训练中，每个轮次训练结束我们可以使用校验集数据对模型做一个评估，判断模式的可用性。</p>\n<p><code>trainEpochs</code> 训练的次数（轮数）会显著影响模型最终准确性，这也是最简单好用的提升模型质量的方法了，我们这里尝试了训练 1 次、5 次、10 次与 18 次的效果：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edc73f2a01b5437597e95029d6a2e87f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"12-1.jpg\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0105abac62624ef5b211dfc631955cdc~tplv-k3u1fbpfcp-watermark.image?\" alt=\"12-2.jpg\"></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94eb30040fe648f1addc79648fa3d0aa~tplv-k3u1fbpfcp-watermark.image?\" alt=\"12-3.jpg\"></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/712be46f6dee4173abe0c5fe6fcd142e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"12-4.jpg\"></p>\n<p>训练 1 次与 10 次能看到模型有质的飞越，这里我们的模型比较简单，大约 18 次左右以后就能达到很高准确率。\n但暴力加次数也是有极限的，之前制作的样本加了文字颜色与旋转后，样本大概训练了 100 次左右后准确率就一直稳定在 80% 不再增加了，后续将训练次数提到 200 ~ 300 次（心疼我的电脑呀），也没丝毫的提升，这时候就需要对模型或者数据动刀子了，模型我这块我不会只好拿训练数据开刀了。</p>\n<h2>模型的导出使用</h2>\n<p>模型训练完成后需要将其导出，用于后续的使用：</p>\n<pre class=\"prettyprint language-javascript\"><code>await model.save(&#x27;downloads:&#x2F;&#x2F;zelda-words-model&#x27;);\n</code></pre><p>模型导出时会包含两个文件 <code>model.json</code> 与 <code>model.weights.bin</code>：</p>\n<blockquote>\n<ul>\n<li>model.json 是一个 JSON 文件，它包含了保存的模型拓扑结构。此处的“拓扑结构”包括：组成模型的层的类型、各层对应的配置参数，以及层之间的连接方式。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>除了模型的拓扑结构，model.json 还包含模型的权重清单。权重清单部分包含模型所有权重的名字、形状、数据类型，以及权重值存储的位置。weights.bin是一个二进制文件，它存储了模型的所有权重值。</li>\n</ul>\n</blockquote>\n<p>使用时需要确保这里两个文件位于<strong>同一目录下</strong>，当然也可以将导出模型数据放在服务器上，但需要保证这两文件需要在<strong>同一资源路径</strong>下。使用时载入 model.json 即可：</p>\n<pre class=\"prettyprint language-javascript\"><code>import * as tf from &#x27;@tensorflow&#x2F;tfjs&#x27;;\nimport { dataset } from &#x27;.&#x2F;data&#x27;;\nimport modelURL from &#x27;..&#x2F;data&#x2F;model.json?url&#x27;;\n\nasync function predict() {\n    &#x2F;&#x2F; 载入训练完成的模型\n    const model = await tf.loadLayersModel(modelURL);\n    await dataset.loadData();\n    const examples = dataset.getTestData(40);\n    &#x2F;&#x2F; 使用模型进行预测\n    const output = model.predict(examples.images);\n    const axis = 1;\n    &#x2F;&#x2F; 输出测试集目标索引\n    const labels = Array.from(examples.labels.argMax(axis).dataSync());\n    &#x2F;&#x2F; 预测结果的索引\n    const predictions = Array.from(output.argMax(axis).dataSync());\n    const res = predictions.filter((it, index) =&gt; it === labels[index]);\n    console.log(&#x27;预测结果&#x27;, res.length, res);\n}\n</code></pre><p>最终的预测输出的结果是个是 <code>[N, 40]</code> 形状的二维张量，而我们想要的最终的字符的索引序号，这里可以通 <code>argMax</code> 取到对应维度上数值最大索引，由于我们是取第二维数据最大索引所以 axis 为 1（数值从 0 开始）。</p>\n<pre class=\"prettyprint language-javascript\"><code>[\n    [0.01, 0.02, 0.03],\n    [0.03, 0.02, 0.01],\n    [0.01, 0.03, 0.03],\n];\n\n&#x2F;&#x2F; -- argMax(1) --&gt;\n\n[\n    2,\n    0,\n    1,\n];\n</code></pre><p>最后只需要在原本的席卡文翻译流程使用训练好的模型进行识别即可：</p>\n<pre class=\"prettyprint language-javascript\"><code>function convertToPredictData(images: Chunk[], imageSize: number) {\n    images.forEach(it =&gt; {\n        const imageData = resizeCanvas(it.canvas, imageSize);\n        const pixs = new Float32Array(imageData.data.length &#x2F; 4);\n        let index = 0;\n        &#x2F;&#x2F; rgb 转灰度\n        for (let i = 0; i &lt; imageData.data.length; i += 4) {\n            const r = imageData.data[i];\n            const g = imageData.data[i + 1];\n            const b = imageData.data[i + 2];\n            pixs[index] = (r * 0.299 + g * 0.587 + b * 0.114) &#x2F; 255;\n            index += 1;\n        }\n        it.data = pixs;\n    });\n    const shape: [number, number, number, number] = [images.length, imageSize, imageSize, 1];\n    const shapeSize = tf.util.sizeFromShape(shape);\n    const concatData = new Float32Array(shapeSize);\n    images.forEach((image, index) =&gt; {\n        concatData.set(image.data as Float32Array, index * imageSize * imageSize);\n    });\n    &#x2F;&#x2F; 将图片转换成张量\n    return tf.tensor4d(concatData, shape);\n}\n\nexport async function readMetaInfoByCnn(imageUrl: string) {\n    const modelURL = &#x27;https:&#x2F;&#x2F;xxx-server.com&#x2F;model.json&#x27;;\n    const imageSize = 28;\n    const readImage = await loadImage(imageUrl);\n    &#x2F;&#x2F; 将希卡文的图片拆分出来\n    const images = splitImage(readImage, false);\n    &#x2F;&#x2F; 转换成模型需要的张量格式\n    const predictData = convertToPredictData(images, imageSize);\n    &#x2F;&#x2F; 加载训练号的模型\n    const model = await tf.loadLayersModel(modelURL);\n    const output = model.predict(predictData) as tf.Tensor;\n    const axis = 1;\n    &#x2F;&#x2F; 获取预测结果的索引\n    const predictIndexs = Array.from(output.argMax(axis).dataSync());\n    &#x2F;&#x2F; 通过索引找到目标字符\n    const results = predictIndexs.map((predictIndex, index) =&gt; {\n        const target = words[predictIndex];\n        return {\n            ...images[index],\n            word: target.symbol,\n        };\n\n    });\n    console.log(&#x27;results&#x27;, results);\n    if (results.length) {\n        return printfSymbols(\n            results,\n            readImage.naturalWidth,\n            readImage.naturalHeight\n        );\n    }\n    window.alert(&#x27;无法解析&#x27;);\n    throw new Error(&#x27;PARSE ERROR&#x27;);\n}\n</code></pre><p>希卡文字符拆分提取之前已经实现了，只需要将拆分图片转成 <code>[N, H, W, C]</code> 形状的张量即可；通过模型预测我们可以到最终的预测字符索引，自此希卡文翻译模型接入完成。</p>\n<p>目前本菜对于机器学习的了解还只限于刷过几节吴恩达老师的课，粗粗翻了下<a href=\"https://www.ituring.com.cn/book/2813\">《JavaScript深度学习》</a>的程度，本文主要是梳理下功能实现流程，有纰漏的地方还多请赐教，溜~</p>\n<h2>最后</h2>\n<p>今年 E3 展会上，老任公布了最新的《旷野之息》续作，很是值得期待，英雄的征途还在，请不要随便死在路上。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1647217de62b4104ba5e1931dc97a2eb~tplv-k3u1fbpfcp-watermark.image?\" alt=\"IMG_9599.JPG\"></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b161be8b17f4ae7adbce5b04921d0eb~tplv-k3u1fbpfcp-watermark.image?\" alt=\"IMG_9600.JPG\"></p>\n</div>",
      "title": "CNN 手写数字分类与希卡文翻译",
      "author": {
        "loginname": "kinglisky",
        "avatar_url": "https://avatars.githubusercontent.com/u/15852576?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 90,
      "country": "USA"
    },
    {
      "id": "61613ee0fe0c516ffeaedbc9",
      "content": "<div class=\"markdown-text\"><p>如题。</p>\n</div>",
      "title": "nodejs 开发一个磁力下载软件合适不",
      "author": {
        "loginname": "victimsss",
        "avatar_url": "https://avatars.githubusercontent.com/u/39045881?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 91,
      "country": "China"
    },
    {
      "id": "615ff3f2fe0c511b7eaed30a",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FvjQeIruf12qbbHuPr_WfE3E1aMi\" alt=\"unknown.png\"><img src=\"//static.cnodejs.org/FsdX0nYQUx_W1WlFdsfL3cAjpi9i\" alt=\"unknow1n.png\"></p>\n</div>",
      "title": "node调试,点击inspect,新窗口一片空白",
      "author": {
        "loginname": "huge689",
        "avatar_url": "https://avatars.githubusercontent.com/u/44516016?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 92,
      "country": "USA"
    },
    {
      "id": "5e5b7a73b5a36940fe1ce674",
      "content": "<div class=\"markdown-text\"><p>完全基于浏览器，可以采集屏幕分享、本地视频、本地图片、画板、远程视频流等内容，合并到统一的视频流里，可以用来实时分享或者生成一个独立视频文件。\n此功能是pplink2.0的实现，pplink1.0主要实现点到点的文件传输与文字内容交互，用于多个电脑、手机之家的数据同步很方便。</p>\n<p>网址： <a href=\"https://www.pplink.link/\">www.pplink.link</a></p>\n</div>",
      "title": "网页版实时视频流，可以用于点到点屏幕分享、视频会议、视频合并等",
      "author": {
        "loginname": "cicada",
        "avatar_url": "//gravatar.com/avatar/4c9345e30837b73f114986e1b977e009?size=48"
      },
      "important": 4,
      "status": "published",
      "num": 93,
      "country": "Japan"
    },
    {
      "id": "615d0389fe0c5184d0aecc53",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-htm\"><code>&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;\n\t\t&lt;meta charset=&quot;utf8&quot; &#x2F;&gt;\n\t\t&lt;title&gt;textarea&lt;&#x2F;title&gt;\n\t\t&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;\n\t\t&lt;script src=&quot;jquery-2.1.1.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\t\n&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;\n\n&lt;div class=&quot;row&quot;&gt;\n\t&lt;div class=&quot;col five&quot;&gt;\n\t\t&lt;label for=&quot;test&quot;&gt;title&lt;&#x2F;label&gt;\n\t\t&lt;textarea name=&quot;title&quot; rows=&quot;18&quot; cols=&quot;50&quot;  &gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;div&gt;\n\t\n\t&lt;div class=&quot;col six&quot;&gt;\n\t\t&lt;textarea name=&quot;content&quot; rows=&quot;28&quot; cols=&quot;50&quot;&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;\n\t\n&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n</code></pre><p>如果用jade/pug ，会增额外的复杂性，比如看效果必须要部署个动态服务器，各种编辑器不一定支持自定义扩展名语法高亮, ide对带模板的html格式化以后总有些小问题\n如果用纯html，大部分编辑器都支持语法高亮，但是嵌套层级一多的情况下容易看串行<br>\n这种写法的只需要记住 一个规则，parent结点的结束标签放在最后一个子结点末尾 (lastchild后面跟关闭标签，关闭标签的个数对应缩进的级别个数 )   这样lastchild一行会比较长，再根据lastchild找previosSibling 也很好找</p>\n</div>",
      "title": "纯html缩进的写法",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 94,
      "country": "China"
    },
    {
      "id": "60e2e45aba7460ad8d862567",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://www.bilibili.com/video/BV1hM4y1u7B4\"><img src=\"//static.cnodejs.org/Fh6glLHJh9_kScZjSM0LPj3UpxAC\" alt=\"image.png\"></a>\n<strong>↑↑↑ 全程 110 分钟干货分享视频 ↑↑↑</strong></p>\n<h2>TSRPC 是什么</h2>\n<p>TSRPC 是一个 TypeScript 的 RPC 框架，适用于浏览器 Web 应用、WebSocket 实时应用、NodeJS 微服务等场景。\n是目前世界上唯一支持 TypeScript 复杂类型运行时检测和二进制序列化的 RPC 框架</p>\n<p>中文文档：<a href=\"https://tsrpc.cn\">https://tsrpc.cn</a>\nGitHub：<a href=\"https://github.com/k8w/tsrpc\">https://github.com/k8w/tsrpc</a>\n视频教程：<a href=\"https://www.bilibili.com/video/BV1hM4y1u7B4\">https://www.bilibili.com/video/BV1hM4y1u7B4</a></p>\n<p>目前，大多数项目仍在使用传统的 Restful API 进行前后端通信，这存在一些痛点。</p>\n<ol>\n<li>依赖文档进行协议定义，前后端联调常被低级错误困扰（如字段名大小写错误，字段类型错误等）。</li>\n<li>一些框架虽然实现了协议定义规范，但需要引入 <a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#decorators\">Decorator</a> 或第三方 IDL 语言。</li>\n<li>一些框架虽然实现了类型校验，但无法支持 TypeScript 的高级类型，例如业务中常见的 <a href=\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types\">Union Type</a>：</li>\n</ol>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; 用户信息\ninterface UserInfo {\n  &#x2F;&#x2F; 来源渠道\n  from: { type: &#x27;老用户邀请&#x27;, fromUserId: string }\n    | { type: &#x27;推广链接&#x27;, url: string }\n    | { type: &#x27;直接进入&#x27; },\n  &#x2F;&#x2F; 注册时间\n  createTime: Date\n}\n</code></pre><ol>\n<li>JSON 支持的类型有限，例如不支持 <code>ArrayBuffer</code>，实现文件上传会非常麻烦。</li>\n<li>请求和响应都是明文，破解门槛太低，字符串加密方式有限且强度不够。</li>\n<li>等等…</li>\n</ol>\n<p>我们无法找到一个能完美解决这些问题的现成框架，于是我们全新设计和创造了 <strong>TSRPC</strong> 。</p>\n<h2>概览</h2>\n<p>一个名为 <code>Hello</code> 的协议，从定义、实现到浏览器调用。</p>\n<h3>协议定义</h3>\n<p>直接使用 <code>type</code> 或 <code>interface</code> 定义协议，无需 Decorator 和第三方 IDL 语言。</p>\n<pre class=\"prettyprint language-ts\"><code>export interface ReqHello {\n  name: string;\n}\n\nexport interface ResHello {\n  reply: string;\n}\n</code></pre><h3>服务端实现</h3>\n<p>运行时自动校验类型，请求参数一定类型安全。</p>\n<pre class=\"prettyprint language-ts\"><code>import { ApiCall } from &quot;tsrpc&quot;;\n\nexport async function ApiHello(call: ApiCall&lt;ReqHello, ResHello&gt;) {\n  call.succ({\n    reply: &#x27;Hello, &#x27; + call.req.name\n  });\n}\n</code></pre><h3>客户端调用</h3>\n<p>跨项目复用协议定义，全程代码提示，不需要接口文档。</p>\n<pre class=\"prettyprint language-ts\"><code>let ret = await client.callApi(&#x27;Hello&#x27;, {\n    name: &#x27;World&#x27;\n});\nconsole.log(ret); &#x2F;&#x2F; { isSucc: true, res: { reply: &#x27;Hello, World&#x27; } }\n</code></pre><p><img src=\"//static.cnodejs.org/FlCzOaoeVOyuFpf5G14FtEw09s7X\" alt=\"code-hint.gif\"></p>\n<h2>特性</h2>\n<p>TSRPC 具有一些前所未有的强大特性，给您带来极致的开发体验。</p>\n<ul>\n<li>🥤 <strong>原汁原味 TypeScript</strong>\n<ul>\n<li>直接基于 TypeScript <code>type</code> 和 <code>interface</code> 定义协议</li>\n<li>无需额外注释，无需 Decorator，无需第三方 IDL 语言</li>\n</ul>\n</li>\n<li>👓 <strong>自动类型检查</strong>\n<ul>\n<li>在编译时刻和运行时刻，自动进行输入输出的类型检查</li>\n<li>总是类型安全，放心编写业务代码</li>\n</ul>\n</li>\n<li>💾 <strong>二进制序列化</strong>\n<ul>\n<li>比 JSON 更小的传输体积</li>\n<li>比 JSON 更多的数据类型：如 <code>Date</code>, <code>ArrayBuffer</code>, <code>Uint8Array</code> 等</li>\n<li>方便地实现二进制加密</li>\n</ul>\n</li>\n<li>🔥 <strong>史上最强大的 TypeScript 序列化算法</strong>\n<ul>\n<li>无需任何注解，直接实现将 TypeScript 源码中的类型定义序列化</li>\n<li>首个也是目前唯一支持 TypeScript 高级类型的二进制序列化算法，包括：\n<ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types\">Union Type</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types\">Intersection Type</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys\">Pick Type</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype\">Partial Type</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html\">Indexed Access Types</a></li>\n<li>等等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>☎ <strong>多协议</strong>\n<ul>\n<li>同时支持 HTTP / WebSocket</li>\n</ul>\n</li>\n<li>💻 <strong>多平台</strong>\n<ul>\n<li>NodeJS / 浏览器 / App / 小程序</li>\n</ul>\n</li>\n<li>⚡️ <strong>高性能</strong>\n<ul>\n<li>单核单进程 5000+ QPS 吞吐量（测试于 Macbook Air M1, 2020)</li>\n<li>单元测试、压力测试、DevOps 方案齐备</li>\n<li>经过数个千万用户级项目验证</li>\n</ul>\n</li>\n</ul>\n<h2>兼容性</h2>\n<p>完全可以在 Server 端使用 TSRPC，同时兼容传统前端。</p>\n<ul>\n<li><strong>兼容 JSON 形式的 Restful API 调用</strong>\n<ul>\n<li>可自行使用 <code>XMLHttpRequest</code>、<code>fetch</code> 或其它 AJAX 框架以 JSON 方式调用接口</li>\n</ul>\n</li>\n<li><strong>兼容纯 JavaScript 的项目使用</strong>\n<ul>\n<li>可在纯 JavaScript 项目中使用 TSRPC Client，也能享受类型检查和序列化特性</li>\n</ul>\n</li>\n<li><strong>兼容 Internet Explorer 10 浏览器</strong>\n<ul>\n<li>浏览器端兼容至 IE 10 ，Chrome 30</li>\n</ul>\n</li>\n</ul>\n<h2>运行时类型检测的实现原理</h2>\n<p>众所周知，TypeScript 的类型检测仅发生在编译时刻，这是因为类型信息（如 <code>type</code>、<code>interface</code>）会在编译时刻被抹除。而 TSRPC 竟然能在运行时刻也检测这些被抹除的类型信息？\n况且 TypeScript 编译器有大几 MB，而 TSRPC 才几十 KB……</p>\n<p>其实，这是因为我们遵循 TypeScript 类型系统，独立实现了一套轻量的类型系统，可以在运行时完成类型检测，甚至是二进制序列化。它支持了绝大多数常用的 TypeScript 类型。</p>\n<p><a href=\"https://tsrpc.cn/docs/tsrpc-inside/supported-types\">支持的类型清单</a></p>\n<h2>上手试试</h2>\n<p>使用 <code>create-tsrpc-app</code> 工具，可以快速创建 TSRPC 项目。</p>\n<pre class=\"prettyprint language-shell\"><code>npx create-tsrpc-app@latest\n</code></pre><p>创建过程是交互式的，在菜单上选择相应的配置，即可轻松创建包含前后端的 TSRPC 全栈应用项目。</p>\n<p><img src=\"//static.cnodejs.org/Fs3Tg6Fa-wBoVRjowCUojIDxd42P\" alt=\"create-tsrpc-app.gif\"></p>\n<p>如果你选择创建 <strong>HTTP 短连接服务</strong>，则会创建一个留言板的演示项目；如果选择 <strong>WebSocket 长连接服务</strong>，则会创建一个实时聊天室的演示项目。</p>\n<h2>参考资料</h2>\n<p>GitHub：<a href=\"https://github.com/k8w/tsrpc\">https://github.com/k8w/tsrpc</a>\n中文文档：<a href=\"https://tsrpc.cn\">https://tsrpc.cn</a>\n视频教程：<a href=\"https://www.bilibili.com/video/BV1hM4y1u7B4\">https://www.bilibili.com/video/BV1hM4y1u7B4</a></p>\n</div>",
      "title": "[全程干货] TSRPC 和 TypeScript 全栈开发实践：前后端共享代码 / 运行时类型检测 / 二进制序列化",
      "author": {
        "loginname": "k8w",
        "avatar_url": "https://avatars.githubusercontent.com/u/1681689?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 95,
      "country": "Eurozone"
    },
    {
      "id": "615bf39cfe0c51aff2aecbd1",
      "content": "<div class=\"markdown-text\"><p>看 egg-mongoose 的代码 第 <a href=\"https://github.com/eggjs/egg-mongoose/blob/master/lib/mongoose.js#L34\">34</a> 行 和 第 <a href=\"https://github.com/eggjs/egg-mongoose/blob/master/lib/mongoose.js#L45\">45</a> 行 ，分别 用 egg 的 <a href=\"https://eggjs.org/zh-cn/advanced/plugin.html\">app.addSingleton</a> 方法 和 app.mongoose 都给 app 添加了 mongoose 属性。而且这两个操作 。\n34行增加的是 mongoose.js 的实例 ，\n45行增加的是 mongoose.js 本身。\n想问一下这两个操作不会冲突嘛？为什么需要这样操作？</p>\n<p><a href=\"https://github.com/eggjs/egg-mongoose/blob/master/lib/mongoose.js#L34\">https://github.com/eggjs/egg-mongoose/blob/master/lib/mongoose.js#L34</a>\n<a href=\"https://github.com/eggjs/egg-mongoose/blob/master/lib/mongoose.js#L45\">https://github.com/eggjs/egg-mongoose/blob/master/lib/mongoose.js#L45</a></p>\n</div>",
      "title": "egg-mongoose 代码问题请教",
      "author": {
        "loginname": "PeakFish",
        "avatar_url": "https://avatars2.githubusercontent.com/u/4606475?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 96,
      "country": "USA"
    },
    {
      "id": "61584584fe0c51b4beaeca62",
      "content": "<div class=\"markdown-text\"><p>最近使用 scoop 安装了 nodejs，尝试了了 node 16.0.0 以及 node-lts 14.0， 安装后执行 node 命令提示：</p>\n<p>无法定位程序输入点GetHostNameW于动态链接库WS2_32.dll上。</p>\n<p><img src=\"//static.cnodejs.org/Fs_7UqYKAt24BhQk_aOf2MeMvWMx\" alt=\"image.png\"></p>\n</div>",
      "title": "Win7无法启动node",
      "author": {
        "loginname": "wsdjeg",
        "avatar_url": "https://avatars.githubusercontent.com/u/13142418?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 97,
      "country": "Eurozone"
    },
    {
      "id": "61583971fe0c515c4eaeca37",
      "content": "<div class=\"markdown-text\"><p>在编辑页面，传统方式是服务器输出模板，如果字段很多的情况下，简直就是个体力活(还要处理select/option/radio/checkbox的当前值)\n用　jquery表单回填插件，不管字段多少就一行代码</p>\n<pre class=\"prettyprint language-nodejs\"><code> $.get(&quot;&#x2F;item&#x2F;&quot;+id,function(data){\n        $(&quot;#myform&quot;).jsonToForm(data);\n });\t\n</code></pre><p>这样　添加页面和编辑页面可以共用一个模板(是insert/还是update　后台程序 区分一下提交的id是不是null就可以)，模板页面也很干净，就是纯的html (不同模板，不同后台语言都可以通用）\n安装  <code>npm i jquery-json-form-binding</code>\n有特殊的字段（并不是name=value的情况)可以写回调函数 具体用法参考github <a href=\"https://github.com/devWaleed/JQuery-JSON-Form-Binding\">https://github.com/devWaleed/JQuery-JSON-Form-Binding</a></p>\n</div>",
      "title": "推荐一个jquery表单回填插件",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 98,
      "country": "Japan"
    },
    {
      "id": "613ef0aefe0c511fc5ae9c53",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FiV16gTgN1t8FgNioOGiuSb0Gaa0\" alt=\"2021-09-13_143230.jpg\"></p>\n<p>from:</p>\n<ul>\n<li><a href=\"https://www.163.com/dy/article/GJKOTA3T055061FK.html\">https://www.163.com/dy/article/GJKOTA3T055061FK.html</a></li>\n<li><a href=\"https://new.qq.com/omn/20210913/20210913A04YWM00.html\">https://new.qq.com/omn/20210913/20210913A04YWM00.html</a></li>\n</ul>\n</div>",
      "title": "移动互连网的互连互通来了",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 99,
      "country": "Eurozone"
    },
    {
      "id": "6156dfdafe0c51ccbbaec987",
      "content": "<div class=\"markdown-text\"><p>主要特性</p>\n<ul>\n<li>加载快</li>\n<li>类名好记 (无须正版英文文档,会width百分比即可写代码)</li>\n<li>流式分栏布局</li>\n<li>无限级嵌套</li>\n<li>支持响应式设计</li>\n<li>支持ie8</li>\n<li>支持渐进渐强，移动优先</li>\n</ul>\n<p><a href=\"https://github.com/mourner/dead-simple-grid\">https://github.com/mourner/dead-simple-grid</a></p>\n</div>",
      "title": "推荐一个前端用的250字节的css框架",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 100,
      "country": "Japan"
    },
    {
      "id": "6152946cfe0c51558caec018",
      "content": "<div class=\"markdown-text\"><p>琢磨着写个种田养鱼、建设城镇、外出打怪的游戏，写了一部分接口了，有兴趣的一起来搞事呀！（诚心参与的来，打嘴仗请退散）</p>\n<p>刚才有人给我 Email 问有没有原型，自己做了个简陋的原型hah，准备先用后台 UI 轮子，用 Vue 写个能玩的 demo 出来。</p>\n<p>目前进度：</p>\n<ul>\n<li>服务器 is done</li>\n<li>域名 is done</li>\n<li>demo 的策划案 is done</li>\n<li>demo 的接口编码 is done</li>\n<li>demo 的测试版接口部署 is 95%（less pull code）</li>\n<li>demo 的原型 is 75%</li>\n<li>demo 的网站编码 is 10%</li>\n<li>demo 的正式版接口部署 is 95%（less pull code）</li>\n</ul>\n<p>我的 QQ：3112743654，想参与的话，可以来详谈两毛钱的——不想参与请别加，我最近状态不好，态度有些差</p>\n</div>",
      "title": "一起写个网页游戏，有兴趣的吗",
      "author": {
        "loginname": "Sun-FreePort",
        "avatar_url": "https://avatars.githubusercontent.com/u/19473984?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 101,
      "country": "China"
    },
    {
      "id": "6155694efe0c515752aec808",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/ckpack/parameter\">https://github.com/ckpack/parameter</a>\n例子:</p>\n<pre class=\"prettyprint language-js\"><code>import { Parameter } from &#x27;@ckpack&#x2F;parameter&#x27;;\nconst parameter = new Parameter();\n\nconst rule = {\n  isAdmin: &#x27;boolean&#x27;,\n  age: {\n    type: &#x27;int&#x27;,\n    min: 0,\n    max: 200,\n  },\n  ids: {\n    type: &#x27;array&#x27;,\n    itemType: &#x27;int&#x27;,\n    itemRule: {\n      min: 1\n    }\n  }\n}\n\nconst data = {\n  isAdmin: true,\n  age: 18,\n  ids: [1, 2, 3]\n};\n\nconst errors = parameter.validate(rule, data);\n</code></pre><h1>支持的验证类型</h1>\n<h2>int</h2>\n<p>如果类型为<code>int</code>，则有以下选项规则</p>\n<ul>\n<li><code>max</code> - 值的最大值，值必须 &lt;= <code>max</code></li>\n<li><code>min</code> - 值的最小值，值必须 &gt;= <code>min</code></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>{\n  score: &#x27;int&#x27;,\n}\n&#x2F;&#x2F; or\n{\n  score: {\n    type: &#x27;int&#x27;,\n    min: 0,\n    max: 200,\n  }\n}\n</code></pre><h2>number</h2>\n<p>如果类型为<code>number</code>，则有以下选项规则</p>\n<ul>\n<li><code>max</code> - 值的最大值，值必须 &lt;= <code>max</code></li>\n<li><code>min</code> - 值的最小值，值必须 &gt;= <code>min</code></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>{\n  score: &#x27;number&#x27;,\n}\n&#x2F;&#x2F; or\n{\n  score: {\n    type: &#x27;number&#x27;,\n    min: 0,\n    max: 100,\n  }\n}\n</code></pre><h2>string</h2>\n<p>如果类型为<code>string</code>，则有以下选项规则</p>\n<ul>\n<li><code>regex</code> - 检查字符串格式的正则表达式</li>\n<li><code>max</code> - 字符串的最大长度</li>\n<li><code>min</code> - 字符串的最小长度</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>{\n  username: &#x27;string&#x27;,\n}\n&#x2F;&#x2F; or\n{\n  username: {\n    type: &#x27;string&#x27;,\n    regexp: &#x2F;\\S{4,20}&#x2F;\n  }\n}\n</code></pre><h2>boolean</h2>\n<p>检查是否是<code>boolean</code>类型</p>\n<pre class=\"prettyprint language-js\"><code>{\n  isAll: &#x27;boolean&#x27;,\n}\n&#x2F;&#x2F; or\n{\n  isAll: {\n    type: &#x27;boolean&#x27;,\n  }\n}\n</code></pre><h2>array</h2>\n<p>如果类型是数组，则有以下选项规则</p>\n<ul>\n<li><code>itemType</code> - 此数组中每个项目的类型</li>\n<li><code>itemRule</code> - 此规则中每个项目的规则</li>\n<li><code>itemChecker</code>- 每个项目的检查器，在这种情况下，您可以省略 <code>itemType</code> 和 <code>itemRule</code></li>\n<li><code>max</code> - 数组的最大长度</li>\n<li><code>min</code> - 数组的最小长度</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>{\n  ids: {\n    itemType: &#x27;int&#x27;,\n    itemRule: {\n      min: 1,\n      max: 1000,\n    },\n    min: 0,\n    max: 100,\n  }\n}\n\n</code></pre><h2>enum</h2>\n<p>如果类型是<code>enum</code>，则有以下规则</p>\n<ul>\n<li><code>enum</code> - 数组,其中的值必须为其中一个</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>{\n  sex: [&#x27;man&#x27;, &#x27;woman&#x27;]\n}\n&#x2F;&#x2F; or\n{\n  sex: {\n    type: &#x27;enum&#x27;\n    enum: [&#x27;man&#x27;, &#x27;woman&#x27;]\n  }\n}\n</code></pre><h2>object</h2>\n<p>如果类型是对象，则有以下规则\n<code>rule</code> - 验证对象属性的对象</p>\n<pre class=\"prettyprint language-js\"><code>{\n  people: {\n    type: &#x27;object&#x27;,\n    rule: {\n      name: &#x27;string&#x27;,\n      age: {\n        isRequired: false,\n        type: &#x27;int&#x27;,\n        min: 1,\n        max: 200\n      }\n    }\n  }\n}\n</code></pre><h2>custom</h2>\n<p>你也可以定义自定义验证类型</p>\n<pre class=\"prettyprint language-js\"><code>import { Parameter } from &#x27;@ckpack&#x2F;parameter&#x27;;\nconst parameter = new Parameter();\n&#x2F;&#x2F; 验证是否为偶数\nparameter.addRule(&#x27;even&#x27;, (rule, value) =&gt; {\n  return value % 2 === 0 ? null : &#96;${value} is not even&#96;;\n});\n\n&#x2F;&#x2F; rule\n{\n  someNumber: &#x27;even&#x27;\n}\n&#x2F;&#x2F; or\n{\n  someNumber: {\n    type: &quot;even&quot;,\n  }\n}\n</code></pre><p>对于自定义验证类型你也可以添加参数如:</p>\n<pre class=\"prettyprint language-js\"><code>import { Parameter } from &#x27;@ckpack&#x2F;parameter&#x27;;\nconst parameter = new Parameter();\n\n&#x2F;&#x2F; 验证能否被某个数字整除\nparameter.addRule(&#x27;times&#x27;, (rule, value) =&gt; {\n  const { times } = rule;\n  return value % times === 0 ? null : &#96;not an integer multiple of ${times}&#96;;\n});\n\n&#x2F;&#x2F; rule\n{\n  someNumber: {\n    type: &quot;times&quot;,\n    times: 3,\n  }\n}\n</code></pre></div>",
      "title": "最近在学`typescript`, 试着把<https://github.com/node-modules/parameter> 重构了,欢迎使用😁",
      "author": {
        "loginname": "chenkai0520",
        "avatar_url": "https://avatars.githubusercontent.com/u/30174970?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 102,
      "country": "Japan"
    },
    {
      "id": "615566f7fe0c518477aec7f4",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FsQXDvkxz04cIy4Wy2oiTi_n6Bu_\" alt=\"2021-09-30_152628.jpg\">\nfrom <a href=\"https://www.163.com/dy/article/GL14AP240511CUMI.html\">https://www.163.com/dy/article/GL14AP240511CUMI.html</a></p>\n</div>",
      "title": "开源软件终于可以赚钱了",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 103,
      "country": "Eurozone"
    },
    {
      "id": "615434befe0c514e49aec418",
      "content": "<div class=\"markdown-text\"><p>如题， 一般在哪看 活动 ，？</p>\n</div>",
      "title": "杭州近期 有node  活动吗。",
      "author": {
        "loginname": "dyjiang",
        "avatar_url": "https://avatars.githubusercontent.com/u/37732251?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 104,
      "country": "USA"
    },
    {
      "id": "61541ce2fe0c516c3aaec338",
      "content": "<div class=\"markdown-text\"><p>关注<a href=\"https://github.com/simon9124/my_demos/blob/master/README.md\">前端小讴</a>，阅读更多原创技术文章</p>\n<h1>异步函数</h1>\n<ul>\n<li>ES8 新增异步函数（<code>async/await</code>），是 ES6 期约模式在 ECMAScript 函数中的应用</li>\n<li>以<strong>同步方式的代码执行异步</strong></li>\n</ul>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89/%E7%AC%AC11%E7%AB%A0%20%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/11.3.%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0.js\">相关代码→</a></p>\n<h2>异步函数</h2>\n<ul>\n<li>ES8 对函数进行了扩展，新增 2 个关键字<code>async</code>和<code>await</code></li>\n</ul>\n<h3>async</h3>\n<ul>\n<li><code>async</code>关键字用于声明异步函数，可用在<strong>函数声明</strong>、<strong>函数表达式</strong>、<strong>箭头函数</strong>和<strong>方法</strong>上</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {} &#x2F;&#x2F; 用在函数声明\nlet bar = async function () {} &#x2F;&#x2F; 用在函数表达式\nlet baz = async () =&gt; {} &#x2F;&#x2F; 用在箭头函数\nclass Qux {\n  async qux() {} &#x2F;&#x2F; 用在方法\n}\n</code></pre><ul>\n<li><code>async</code>关键字让函数具有<strong>异步特性</strong>，代码仍<strong>同步求值</strong>，参数或闭包也具有普通 JS 函数的正常行为</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  console.log(1)\n}\nfoo()\nconsole.log(2)\n&#x2F;* \n  1，foo()函数先被求值\n  2\n*&#x2F;\n</code></pre><ul>\n<li>异步函数<code>return</code>返回的值，会被<code>Promise.resolve()</code>包装成期约对象，调用异步函数<strong>始终返回该期约对象</strong>\n<ul>\n<li>若<code>return</code>关键字返回的是实现<code>thenable</code>接口的对象（<code>callback</code>、期约），该对象由提供给<code>then()</code>的处理程序<strong>解包</strong></li>\n<li>若<code>return</code>关键字返回的是常规的值，返回值被当作<strong>已解决的期约</strong>（无<code>return</code>关键字，返回值被当作 undefined）</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  return &#x27;foo&#x27; &#x2F;&#x2F; 返回原始值\n}\nconsole.log(foo()) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &quot;foo&quot;}，被当作已解决的期约\nfoo().then((result) =&gt; console.log(result)) &#x2F;&#x2F; &#x27;foo&#x27;\n\nasync function bar2() {\n  return [&#x27;bar&#x27;] &#x2F;&#x2F; 返回没有实现thenable接口的对象\n}\nconsole.log(bar2()) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: [&#x27;bar&#x27;]}，被当作已解决的期约\nbar2().then((result) =&gt; console.log(result)) &#x2F;&#x2F; [&#x27;bar&#x27;]\n\nasync function baz2() {\n  const thenable = {\n    then(callback) {\n      callback(&#x27;baz&#x27;)\n    },\n  }\n  return thenable &#x2F;&#x2F; 返回实现了thenable接口的非期约对象\n}\nconsole.log(baz2()) &#x2F;&#x2F; Promise {&lt;pending&gt;}\nbaz2().then((result) =&gt; console.log(result)) &#x2F;&#x2F; &#x27;baz&#x27;，由then()解包\n\nasync function qux() {\n  return Promise.resolve(&#x27;qux&#x27;) &#x2F;&#x2F; 返回解决的期约\n}\nconsole.log(qux()) &#x2F;&#x2F; Promise {&lt;pending&gt;}\nqux().then((result) =&gt; console.log(result)) &#x2F;&#x2F; &#x27;qux&#x27;，由then()解包\n\nasync function rejectQux() {\n  return Promise.reject(&#x27;qux&#x27;) &#x2F;&#x2F; 返回拒绝的期约\n}\nconsole.log(rejectQux()) &#x2F;&#x2F; Promise {&lt;pending&gt;}\nrejectQux().then(null, (result) =&gt; console.log(result)) &#x2F;&#x2F; &#x27;qux&#x27;，由then()解包\n&#x2F;&#x2F; Uncaught (in promise) qux\nrejectQux().catch((result) =&gt; console.log(result)) &#x2F;&#x2F; &#x27;qux&#x27;，由catch()解包\n</code></pre><ul>\n<li>异步函数中<strong>抛出错误</strong>会返回<strong>拒绝的期约</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  console.log(1)\n  throw 3\n}\nfoo().catch((result) =&gt; console.log(result)) &#x2F;&#x2F; 给返回的期约添加拒绝处理程序\nconsole.log(2)\n&#x2F;* \n  1，foo()函数先被求值\n  2\n  3\n*&#x2F;\n</code></pre><ul>\n<li>异步函数中**拒绝期约的错误（非“返回拒绝的期约”）**不会被异步函数捕获</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  Promise.reject(3) &#x2F;&#x2F; 拒绝的期约（非返回）\n}\nfoo().catch((result) =&gt; console.log(result)) &#x2F;&#x2F; catch()方法捕获不到\n&#x2F;&#x2F; Uncaught (in promise) 3，浏览器消息队列捕获\n</code></pre><h3>await</h3>\n<ul>\n<li>使用<code>await</code>关键字可以<strong>暂停</strong>异步函数代码执行，<strong>等待期约解决</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 1000, 3)\n})\np.then((x) =&gt; console.log(x)) &#x2F;&#x2F; 3\n\n&#x2F;&#x2F; 用async&#x2F;await重写\nasync function foo() {\n  let p = new Promise((resolve, reject) =&gt; {\n    setTimeout(resolve, 1000, 3)\n  })\n  console.log(await p)\n}\nfoo() &#x2F;&#x2F; 3\n</code></pre><ul>\n<li><code>await</code>会尝试<strong>解包</strong>对象的值（与<code>yield</code>类似），然后将该值传给表达式，而后异步恢复执行异步函数</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  console.log(await Promise.resolve(&#x27;foo&#x27;)) &#x2F;&#x2F; 将期约解包，再将值传给表达式\n}\nfoo()\n\nasync function bar2() {\n  return await Promise.resolve(&#x27;bar&#x27;)\n}\nbar2().then((res) =&gt; console.log(res)) &#x2F;&#x2F; &#x27;bar&#x27;\n\nasync function baz2() {\n  await new Promise((resolve, reject) =&gt; {\n    setTimeout(resolve, 1000)\n  })\n  console.log(&#x27;baz&#x27;)\n}\nbaz2() &#x2F;&#x2F; &#x27;baz&#x27;（1000毫秒后）\n</code></pre><ul>\n<li><code>await</code>根据等待的值，执行不同的操作\n<ul>\n<li>若等待的值是实现<code>thenable</code>接口的对象（<code>callback</code>、期约），该对象由<code>await</code>来<strong>解包</strong></li>\n<li>若等待的值是常规值，该值被当作<strong>已解决的期约</strong>（然后再由<code>await</code>来解包）</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  console.log(await &#x27;foo&#x27;) &#x2F;&#x2F; 等待原始值，被当作已解决的期约Promise.resolve(&#x27;foo&#x27;)，再由await解包\n}\nfoo() &#x2F;&#x2F; &#x27;foo&#x27;\n\nasync function bar2() {\n  console.log(await [&#x27;bar&#x27;]) &#x2F;&#x2F; 等待值是没有实现thenable接口的对象，被当作已解决的期约再由await解包\n}\nbar2() &#x2F;&#x2F; [&quot;bar&quot;]\n\nasync function baz2() {\n  const thenable = {\n    then(callback) {\n      callback(&#x27;baz&#x27;)\n    },\n  }\n  console.log(await thenable) &#x2F;&#x2F; 等待值是实现了thenable接口的非期约对象，由await解包\n}\nbaz2() &#x2F;&#x2F; &#x27;baz&#x27;\n\nasync function qux() {\n  console.log(await Promise.resolve(&#x27;qux&#x27;)) &#x2F;&#x2F; 等待值是解决的期约\n}\nqux() &#x2F;&#x2F; &#x27;qux&#x27;\n</code></pre><ul>\n<li>等待会<strong>抛出错误</strong>的同步操作，会返回<strong>拒绝的期约</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  console.log(1)\n  await (() =&gt; {\n    throw 3 &#x2F;&#x2F; 抛出错误的同步操作\n  })()\n}\nfoo().catch((result) =&gt; console.log(result)) &#x2F;&#x2F; 给返回的期约添加拒绝处理程序\nconsole.log(2)\n&#x2F;* \n  1\n  2\n  3\n*&#x2F;\n</code></pre><ul>\n<li>对<strong>拒绝的期约</strong>使用<code>await</code>，会<strong>释放</strong>错误值（将拒绝期约返回）</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  console.log(1)\n  await Promise.reject(3) &#x2F;&#x2F; 对拒绝的期约使用await，将其返回（后续代码不再执行）\n  console.log(4) &#x2F;&#x2F; 不执行\n}\nfoo().catch((result) =&gt; console.log(result)) &#x2F;&#x2F; 给返回的期约添加拒绝处理程序\nconsole.log(2)\n&#x2F;* \n  1\n  2\n  3\n*&#x2F;\n</code></pre><h3>await 的限制</h3>\n<ul>\n<li><strong>必须</strong>在<strong>异步函数</strong>中使用</li>\n<li><strong>不能</strong>在顶级上下文（如<code>&lt;script&gt;</code>标签或模块）中使用</li>\n<li>可以<strong>定义并立即调用</strong>异步函数</li>\n<li>异步函数的特质<strong>不会扩展到嵌套函数</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  console.log(await Promise.resolve(3)) &#x2F;&#x2F; 必须在异步函数中使用\n}\nfoo() &#x2F;&#x2F; 3\n;(async function () {\n  console.log(await Promise.resolve(3)) &#x2F;&#x2F; 3，立即调用的异步函数表达式\n})()\n\nconst syncFn = async () =&gt; {\n  console.log(await Promise.resolve(3)) &#x2F;&#x2F; 在箭头函数中使用，箭头函数前一样要加async\n}\nsyncFn() &#x2F;&#x2F; 3\n\nfunction foo() {\n  &#x2F;&#x2F; console.log(await Promise.resolve(3)) &#x2F;&#x2F; 不允许在同步函数中使用\n}\n\nasync function foo() {\n  &#x2F;&#x2F; function bar() {\n  &#x2F;&#x2F;   console.log(await Promise.resolve(3)) &#x2F;&#x2F; 错误：异步函数不会扩展到嵌套函数\n  &#x2F;&#x2F; }\n  async function bar() {\n    console.log(await Promise.resolve(3)) &#x2F;&#x2F; 需要在bar前加async\n  }\n}\n</code></pre><h2>停止和恢复执行</h2>\n<ul>\n<li><code>async/await</code>真正起作用的是<code>await</code>（<code>async</code>只是标识符）\n<ul>\n<li>JS 在运行时碰到<code>await</code>关键字，会<strong>记录</strong>在哪里暂停执行</li>\n<li>等到<code>await</code><strong>右边的值可以用</strong>时，JS 向消息队列推送任务，该任务<strong>恢复异步函数的执行</strong></li>\n<li>即使<code>await</code>右边跟着一个立即可用的值，函数也会暂停，且其余部分会被<strong>异步求值</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; async只是标识符\nasync function foo() {\n  console.log(2)\n}\nconsole.log(1)\nfoo()\nconsole.log(3)\n&#x2F;* \n  1\n  2\n  3\n*&#x2F;\n\n&#x2F;&#x2F; 遇到await -&gt; 记录暂停 -&gt; await右边的值可用 -&gt; 恢复执行异步函数\nasync function foo() {\n  console.log(2)\n  await null &#x2F;&#x2F; 暂停，且后续操作变为异步\n  &#x2F;&#x2F; 为立即可用的值null向消息队列中添加一个任务\n  console.log(4)\n}\nconsole.log(1)\nfoo()\nconsole.log(3)\n&#x2F;* \n  1\n  2\n  3\n  4\n*&#x2F;\n</code></pre><ul>\n<li>如果<code>await</code>后面是一个期约，则<strong>会有两个任务被添加到消息队列</strong>并被<strong>异步求值</strong>\n<ul>\n<li><strong>第一个任务</strong>是等待期约的返回值，<strong>第二个任务</strong>是拿到返回值后执行进程</li>\n<li>tc39 对<code>await</code>后面是期约的情况做过 1 次修改，<code>await Promise.resolve()</code>不再生成 2 个异步任务，而只是 1 个</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  console.log(2)\n  console.log(await Promise.resolve(8))\n  console.log(9)\n}\n\nasync function bar2() {\n  console.log(4)\n  console.log(await 6)\n  console.log(7)\n}\n\nconsole.log(1)\nfoo()\nconsole.log(3)\nbar2()\nconsole.log(5)\n&#x2F;*\n  书本顺序：1 2 3 4 5 6 7 8 9\n  浏览器顺序：1 2 3 4 5 8 9 6 7（tc39做过1次修改）\n*&#x2F;\n</code></pre><h2>异步函数策略</h2>\n<h3>实现 sleep()</h3>\n<ul>\n<li>可以利用异步函数实现类似<code>JAVA</code>中<code>Thread.sleep()</code>的函数，在程序中加入<strong>非阻塞的暂停</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function sleep(delay) {\n  return new Promise((resolve) =&gt; setTimeout(resolve, delay)) &#x2F;&#x2F; 设定延迟，延迟后返回一个解决的期约\n}\nasync function foo() {\n  const t0 = Date.now()\n  await sleep(1500) &#x2F;&#x2F; 暂停约1500毫秒\n  console.log(Date.now() - t0)\n}\nfoo() &#x2F;&#x2F; 1507\n</code></pre><h3>利用平行执行</h3>\n<ul>\n<li><strong>按顺序</strong>等待 5 个随机的超时</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function randomDelay(id) {\n  const delay = Math.random() * 1000 &#x2F;&#x2F; 随机延迟0-1000毫秒\n  return new Promise((resolve) =&gt;\n    setTimeout(() =&gt; {\n      console.log(&#96;${id} finished&#96;)\n      resolve()\n    }, delay)\n  )\n}\n\nasync function foo() {\n  const t0 = Date.now()\n  await randomDelay(0)\n  await randomDelay(1)\n  await randomDelay(2)\n  await randomDelay(3)\n  await randomDelay(4)\n  console.log(&#96;${Date.now() - t0} ms elapsed&#96;)\n}\nfoo()\n&#x2F;* \n  0 finished\n  1 finished\n  2 finished\n  3 finished\n  4 finished\n  3279 ms elapsed\n*&#x2F;\n\n&#x2F;&#x2F; 用for循环重写\nasync function foo() {\n  const t0 = Date.now()\n  for (let i = 0; i &lt; 5; i++) {\n    await randomDelay(i)\n  }\n  console.log(&#96;${Date.now() - t0} ms elapsed&#96;)\n}\nfoo()\n&#x2F;* \n  0 finished\n  1 finished\n  2 finished\n  3 finished\n  4 finished\n  3314 ms elapsed\n*&#x2F;\n</code></pre><ul>\n<li><strong>不考虑顺序</strong>时，可以先一次性初始化所有期约，分别等待结果（获得平行加速）</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  const t0 = Date.now()\n\n  &#x2F;&#x2F; 一次性初始化所有期约\n  const p0 = randomDelay(0)\n  const p1 = randomDelay(1)\n  const p2 = randomDelay(2)\n  const p3 = randomDelay(3)\n  const p4 = randomDelay(4)\n\n  &#x2F;&#x2F; 分别等待结果，延迟各不相同\n  await p0\n  await p1\n  await p2\n  await p3\n  await p4\n\n  console.log(&#96;${Date.now() - t0} ms elapsed&#96;)\n}\nfoo()\n&#x2F;* \n  4 finished\n  3 finished\n  1 finished\n  0 finished\n  2 finished\n  870 ms elapsed，大幅度降低总耗时\n*&#x2F;\n\n&#x2F;&#x2F; 用数组和for循环再次包装\nasync function foo() {\n  const t0 = Date.now()\n  const promises = Array(5)\n    .fill(null)\n    .map((item, i) =&gt; randomDelay(i))\n\n  for (const p of promises) {\n    await p\n  }\n  console.log(&#96;${Date.now() - t0} ms elapsed&#96;)\n}\nfoo()\n&#x2F;* \n  1 finished\n  3 finished\n  0 finished\n  4 finished\n  2 finished\n  806 ms elapsed\n*&#x2F;\n</code></pre><ul>\n<li>尽管期约未按顺序执行，但<code>await</code><strong>按顺序</strong>收到每个期约的值</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function randomDelay(id) {\n  const delay = Math.random() * 1000 &#x2F;&#x2F; 随机延迟0-1000毫秒\n  return new Promise((resolve) =&gt;\n    setTimeout(() =&gt; {\n      console.log(&#96;${id} finished&#96;)\n      resolve(id)\n    }, delay)\n  )\n}\nasync function foo() {\n  const t0 = Date.now()\n  const promises = Array(5)\n    .fill(null)\n    .map((item, i) =&gt; randomDelay(i))\n\n  for (const p of promises) {\n    console.log(&#96;awaited ${await p}&#96;)\n  }\n  console.log(&#96;${Date.now() - t0} ms elapsed&#96;)\n}\nfoo()\n&#x2F;* \n  1 finished\n  4 finished\n  0 finished\n  awaited 0\n  awaited 1\n  2 finished\n  awaited 2\n  3 finished\n  awaited 3\n  awaited 4\n  833 ms elapsed\n*&#x2F;\n</code></pre><h3>串行执行期约</h3>\n<ul>\n<li>使用<code>async/await</code>做<strong>期约连锁</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function addTwo(x) {\n  return x + 2\n}\nfunction addThree(x) {\n  return x + 3\n}\nfunction addFive(x) {\n  return x + 5\n}\nasync function addTen(x) {\n  for (const fn of [addTwo, addThree, addFive]) {\n    x = await fn(x)\n  }\n  return x\n}\naddTen(9).then((res) =&gt; console.log(res)) &#x2F;&#x2F; 19\n</code></pre><ul>\n<li>将函数改成异步函数，返回期约</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function addTwo(x) {\n  return x + 2\n}\nasync function addThree(x) {\n  return x + 3\n}\nasync function addFive(x) {\n  return x + 5\n}\naddTen(9).then((res) =&gt; console.log(res)) &#x2F;&#x2F; 19\n</code></pre><h3>栈追踪与内存管理</h3>\n<ul>\n<li>在<strong>超时处理执行</strong>和<strong>拒绝期约</strong>时，错误信息包含<strong>嵌套函数的标识符</strong>（被调用以创建最初期约实例的函数）栈追踪信息中不应该看到这些<strong>已经返回</strong>的函数\n<ul>\n<li>JS 引擎会在创建期约时，<strong>尽可能保留完整的调用栈</strong>，抛出错误时栈追踪信息会占用内存，带来一些计算和存储成本</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function fooPromiseExecutor(resolve, reject) {\n  setTimeout(reject, 1000, &#x27;bar&#x27;)\n}\nfunction foo() {\n  new Promise(fooPromiseExecutor)\n}\nfoo()\n&#x2F;* \n  Uncaught (in promise) bar\n  setTimeout (async) &#x2F;&#x2F; 错误信息包含嵌套函数的标识符\n  fooPromiseExecutor &#x2F;&#x2F; fooPromiseExecutor函数已返回，不应该在栈追踪信息中看到\n  foo\n*&#x2F;\n</code></pre><ul>\n<li>换成异步函数，已经<strong>返回的函数不会出现在错误信息中</strong>，嵌套函数（在内存）中存储指向包含函数的指针，不会带来额外的消耗</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function foo() {\n  await new Promise(fooPromiseExecutor)\n}\nfoo()\n&#x2F;* \n  Uncaught (in promise) bar\n  foo\n  async function (async)\n  foo\n*&#x2F;\n</code></pre><h2>总结 &amp; 问点</h2>\n<ul>\n<li>async 关键字的用法是什么？根据函数内返回值的不同，异步函数的返回值有哪些情况？</li>\n<li>await 关键字的用法是什么？根据等待值的不同，调用异步函数有哪些情况？其使用有哪些限制？</li>\n<li>JS 运行时遇到 await 关键字会怎样？函数的其余部分会在何时恢复执行？</li>\n<li>写一段代码，用异步函数实现在程序中加入非阻塞的暂停</li>\n<li>写一段代码，用异步函数平行执行多个期约，随机设定这些期约的延迟，并计算期约全部完成后的使用的时间</li>\n<li>写一段代码，用异步函数做期约连锁</li>\n</ul>\n</div>",
      "title": "《javascript高级程序设计》学习笔记 | 11.3.异步函数",
      "author": {
        "loginname": "simon9124",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 105,
      "country": "Eurozone"
    },
    {
      "id": "6152c2b3fe0c51a1d8aec0ad",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://markdowner.net/article/230097384443973633\">程序员SEO指南：Twitter Cards制作</a><br>\n<a href=\"https://markdowner.net/article/230671551153278977\">程序员SEO指南：Open Graph协议解读</a></p>\n</div>",
      "title": "准备写一系列 SEO 相关的文章，先放几篇各位瞧瞧",
      "author": {
        "loginname": "mi6-m",
        "avatar_url": "https://avatars.githubusercontent.com/u/80660078?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 106,
      "country": "China"
    },
    {
      "id": "6152a163fe0c5187cdaec027",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://blog.csdn.net/csdn372301467/article/details/120523916\">原文</a></p>\n<p>面试时，经常有这个问题：</p>\n<blockquote>\n<p>如何理解原型链</p>\n</blockquote>\n<h1>原型与原型链</h1>\n<p>先看这样一段代码：</p>\n<pre class=\"prettyprint language-js\"><code>let obj = {}\nobj.__proto__.haha = &#x27;gogo&#x27;\nconsole.log(obj.haha) &#x2F;&#x2F; &quot;gogo&quot;\n</code></pre><p>运行一下上面的代码，输出结果为 <code>gogo</code></p>\n<p>有几个疑问：</p>\n<ul>\n<li>obj 哪来的 <code>__proto__</code>属性？</li>\n<li>为什么添加到 <code>__proto__</code>上的属性，可以直接通过 obj 拿到？</li>\n</ul>\n<h5>第一个问题</h5>\n<p>js 中每个对象都有一个“原型”<br>\n原型<strong>一般</strong>可以通过 <code>__proto__</code>访问到</p>\n<pre class=\"prettyprint language-js\"><code>let obj = {}\nconsole.log(obj.__proto__)\n</code></pre><p>原型，也是一个对象<br>\n就像每个“人”都有一个“爸爸”，但“爸爸”也是一个“人”<br>\n“爸爸”除了是某个人的爸爸外，与其他人并没有本质的区别<br>\n爸爸，也是普通人<br>\n类似的，“原型”是一个普通的对象<br>\n爸爸也有他的爸爸，原型也有它的原型</p>\n<h5>第二个问题</h5>\n<p>不同的是，人不可以随便拿爸爸的东西，而对象可以随便拿原型里的东西（很多人并不懂这个，我说的是前半句）</p>\n<p>比如，当你向一个对象，索要一个属性时<br>\n如果这个对象没有你要的属性，它就会让它的原型（爸爸）给你<br>\n如果它爸也没有，那它爸就会找它爸的爸：</p>\n<pre class=\"prettyprint language-js\"><code>let obj = {\n  __proto__: {\n    __proto__: {\n      haha: &#x27;gogo&#x27;\n    }\n  }\n}\nconsole.log(obj.haha) &#x2F;&#x2F; &quot;gogo&quot;\n</code></pre><p>如果这样写：</p>\n<pre class=\"prettyprint language-js\"><code>let 爷爷 = {\n  haha: &#x27;gogo&#x27;\n}\nlet 爸爸 = {\n  __proto__: 爷爷\n}\nlet obj = {\n  __proto__: 爸爸\n}\nconsole.log(obj.haha) &#x2F;&#x2F; &quot;gogo&quot;\n</code></pre><p><code>obj -&gt; 爸爸 -&gt; 爷爷</code>像不像一条链子呢？<br>\n这就是原型链</p>\n<blockquote>\n<p>以下内容，需要先了解 js 中的类，本文不详细介绍</p>\n</blockquote>\n<h1>prototype</h1>\n<p>有这样一句话：</p>\n<blockquote>\n<p>类是对象的模板</p>\n</blockquote>\n<p>你与我，都是人，“人”是类，是模板<br>\n你与我，都属于“人”类，有很多共性：</p>\n<ul>\n<li>有一张嘴</li>\n<li>有两条腿</li>\n<li>会吃饭</li>\n<li>会睡觉</li>\n</ul>\n<p>这些共性是人类共有的</p>\n<p>也有差异，比如我的名字叫 X，你的名字叫 Y\n这些不同点，是对象“私有”的</p>\n<p>看一段 js 创建对象的代码（注意注释部分）：</p>\n<pre class=\"prettyprint language-js\"><code>function Person(name) {\n  this.name = name\n}\nPerson.prototype.吃饭 = function() {\n  console.log(&#x27;吃吃吃&#x27;)\n}\nPerson.prototype.睡觉 = function() {\n  console.log(&#x27;睡睡睡&#x27;)\n}\n\nlet 我 = new Person(&#x27;我&#x27;)\n我.吃饭() &#x2F;&#x2F; &quot;吃吃吃&quot;\nconsole.log(Person.prototype == 我.__proto__)\n&#x2F;&#x2F; 可以看出，在实例化的过程中，类的 prototype 成为对象的原型  \n\nlet 你 = new Person(&#x27;你&#x27;)\n你.睡觉() &#x2F;&#x2F; &quot;睡睡睡&quot;\nconsole.log(我.__proto__ == 你.__proto__)\n&#x2F;&#x2F; 同一类的多个实例（对象），共享一个原型？\n\n我.__proto__.吃饭 = function() {\n  console.log(&#x27;再吃一点&#x27;)\n}\nconsole.log(我.吃饭 == 你.吃饭) &#x2F;&#x2F; true\n你.吃饭() &#x2F;&#x2F; &quot;再吃一点&quot;\n&#x2F;&#x2F; 没错，同一类的多个实例，共享一个原型\n</code></pre><p>类比于人类社会，就是：<br>\n你的兄弟姐妹和你“共享”一个爸爸<br>\n当你的爸爸烫了个头时，你弟弟的爸爸也烫头。这个过程中，不是两个爸爸同时烫头，而是本来就一个爸爸</p>\n<p>重要结论：</p>\n<ul>\n<li>实例化的过程中（也就是“当 new 一个对象的时候”），<strong>类的 prototype 成为对象的原型</strong></li>\n<li>同一个类的多个实例（也就是“对象”），共享一个原型</li>\n</ul>\n<h1>学以致用</h1>\n<p>原型是 js 底层的东西<br>\n不懂原型，几乎不影响工作</p>\n<p>类似“原型有什么用”的问题，就像“砖块（或水泥）对盖楼有什么用”<br>\n其实在写代码的过程中，几乎不会用到原型的知识<br>\n但是如果遇到了问题、出现了 bug、性能优化时<br>\n底层的知识是肯定有大用途的</p>\n</div>",
      "title": "关于 js 的原型链",
      "author": {
        "loginname": "daGaiGuanYu",
        "avatar_url": "https://avatars.githubusercontent.com/u/27003009?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 107,
      "country": "Eurozone"
    },
    {
      "id": "6152bd38fe0c51d7d3aec07e",
      "content": "<div class=\"markdown-text\"><p>环境: Ubuntu 16.04</p>\n<p>下面两个方案都是采用异部方式进行目录创建，同步方式同理。</p>\n<h3>方式一、</h3>\n<pre class=\"prettyprint\"><code>import {promises as fs} from &quot;fs&quot;;\nimport * as path from &#x27;path&#x27;;\n\n&#x2F;**\n * 读取路径信息\n * @param {string} path 路径\n *&#x2F;\n async function getStat(dir) {\n   try {\n    const stat = await fs.stat(dir);\n    return stat;\n   } catch (error) {\n    return false;\n   }\n}\n\n&#x2F;**\n  * 创建路径\n  * @param {string} dir 路径\n  *&#x2F;\nfunction mkdir(dir) {\n  return new Promise((resolve, reject) =&gt; {\n    fs.mkdir(dir).then(function(){\n      console.log(&#x27;Directory created successfully:&#x27;, dir);\n      resolve(true)\n    }).catch(function(){\n      console.log(&#x27;failed to create directory&#x27;);\n      resolve(false)\n    })\n  })\n}\n\n&#x2F;**\n  * 路径是否存在，不存在则创建\n  * @param {string} dir 路径\n  *&#x2F;\n export async function mkdirRecursions(dir) {\n  let isExists = await getStat(dir);\n\n  &#x2F;&#x2F;如果该路径且不是文件，返回true\n  if (isExists &amp;&amp; isExists.isDirectory()) {\n    return true;\n  } \n  else if(isExists){\n    return false;\n  }\n  &#x2F;&#x2F;如果该路径不存在，拿到上级路径\n  let tempDir = path.parse(dir).dir;\n  &#x2F;&#x2F;递归判断，如果上级目录也不存在，则会代码会在此处继续循环执行，直到目录存在\n  let status = await mkdirRecursions(tempDir);\n  let mkdirStatus;\n  if (status) {\n    mkdirStatus = await mkdir(dir);\n  }\n  return mkdirStatus;\n}\n\n&#x2F;&#x2F; example1\n&#x2F;&#x2F;mkdirRecursions(&#x27;.&#x2F;2019&#x2F;1&#x2F;2&#x2F;3&#x27;);\n</code></pre><h3>方式二</h3>\n<pre class=\"prettyprint\"><code>fs.mkdir(&#x27;.&#x2F;2019&#x2F;1&#x2F;2&#x2F;3&#x27;, { recursive: true }).then(function(data){\n  console.log(data)\n}).catch(function(){\n})\n</code></pre><h3>总结:</h3>\n<p>方式二是 v10.0.0 版本以后出现的，如果你版本&gt;=v10.0.0,请使用官方的递归版本，否则使用方式一。</p>\n<blockquote>\n<p>方式一从网上找来然后添加的自己项目，有部分修改。 网上版本是转载的，不知道出处是哪里，所以就没有标注。</p>\n</blockquote>\n</div>",
      "title": "[NodeJS]创建多级目录 - mkdir",
      "author": {
        "loginname": "gocpplua",
        "avatar_url": "https://avatars.githubusercontent.com/u/46804866?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 108,
      "country": "Japan"
    },
    {
      "id": "60fcd66ee3e671acb558f58f",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fk_pD39ZUydXqajy415-hXOoeDfA\" alt=\"444444444.png\">\n<img src=\"//static.cnodejs.org/FodavimNjSw_jIIxUHEOmZGZFrdl\" alt=\"33333333333333.png\">\n刚刚才开始学，想搭个路由，通过浏览器访问http://localhost/home 报404，请问老师这是什么原因呢。</p>\n</div>",
      "title": "求问：匹配路由不能访问locahost。",
      "author": {
        "loginname": "Hit1me",
        "avatar_url": "https://avatars.githubusercontent.com/u/30171759?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 109,
      "country": "Japan"
    },
    {
      "id": "614d379ffe0c514d36aeb23d",
      "content": "<div class=\"markdown-text\"><p>rt.</p>\n</div>",
      "title": "刚刚感觉鞋里有东西，想拿出来，结果摸了一下，可能是一只虫子（硬壳的），倒也倒不出来，现在在办公室，我不敢穿鞋了，可咋整啊……",
      "author": {
        "loginname": "daGaiGuanYu",
        "avatar_url": "https://avatars.githubusercontent.com/u/27003009?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 110,
      "country": "USA"
    },
    {
      "id": "61510fa5fe0c516982aebd7b",
      "content": "<div class=\"markdown-text\"><p>目前项目有个需求，在已知公交gps坐标点信息(经纬度，角度)，及线路上所有站台的坐标点经纬度后，如何计算这个车辆上下行及当前车辆行驶在哪个区间的问题\n各位大佬有没有做过相关的需求\n谢谢</p>\n</div>",
      "title": "关于公交区间计算",
      "author": {
        "loginname": "337840787",
        "avatar_url": "https://avatars.githubusercontent.com/u/12134136?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 111,
      "country": "Japan"
    },
    {
      "id": "614d7ae8fe0c516885aeb42d",
      "content": "<div class=\"markdown-text\"><p>vue是不是前端界的thinkphp？</p>\n</div>",
      "title": "如何看待vue开源但不许搬运文档？",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 112,
      "country": "China"
    },
    {
      "id": "614c2737fe0c51813aaeb075",
      "content": "<div class=\"markdown-text\"><p>基于BoardOS，新上线了**【原型库】**应用，现在可以愉快的设计产品原型了😋，期待大家的建议。</p>\n<h3>预览</h3>\n<p><img src=\"//static.cnodejs.org/FpwSFdstw4IaSoxGOuoVanMrTtnx\" alt=\"10071632375604_.pic_hd.jpg\"></p>\n<h3>应用地址</h3>\n<p><a href=\"https://boardos.online\">https://boardos.online</a>\nps: 第三方登录直接体验，也可以用邮箱注册，但需要邀请码（可以网站上发消息找我要😄）。</p>\n</div>",
      "title": "BoardOS - 原型库，免费的可多人实时协作的产品原型设计工具",
      "author": {
        "loginname": "superliwei",
        "avatar_url": "https://avatars.githubusercontent.com/u/709088?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 113,
      "country": "Japan"
    },
    {
      "content": "<div class=\"markdown-text\"><p>优惠码：u6SUw1t8 小册地址：<a href=\"https://juejin.cn/book/6930553086918262798\">https://juejin.cn/book/6930553086918262798</a></p></div>",
      "title": "送50个掘金可视化搭建小册6折码！",
      "author": {
        "loginname": "muwoo",
        "avatar_url": "https://avatars.githubusercontent.com/u/21073039?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "id": "615028bafe0c511efeaebb4e",
      "num": 114,
      "country": "Japan"
    },
    {
      "id": "609a4acc4d20cbd87e69261b",
      "content": "<div class=\"markdown-text\"><h3>示例</h3>\n<p><strong>有如下代码：</strong>\n<img src=\"//static.cnodejs.org/FiROU7lIkRgJvxV_laejKRg-jw-A\" alt=\"1.png\"></p>\n<p><strong>分别导入了以下本地模块</strong></p>\n<pre class=\"prettyprint language-typescript\"><code>import InstanceCommand from &quot;.&#x2F;commands&#x2F;command&quot;;\nimport DataStructure from &quot;.&#x2F;structure&quot;;\nimport globalConfig from &quot;.&#x2F;config&quot;;\nimport as path from &quot;path&quot;;\n</code></pre><h3>需求</h3>\n<p><strong>需求是</strong>将这些分散的模块文件最终统一合并到一个 ts或js 文件中****（<strong>不需要包括依赖库</strong>），并且能够正常运行，合并后也许可以通过 Typescript 的命名空间来实现命名冲突之类的情况。</p>\n<p>简而言之的话，就是希望将后端的 Typescript 打包到一个文件，但是不需要包含依赖库（依赖库的import语句应该继续存在）。</p>\n<p>Typescript 的官方文档中有写不支持 CommonJS 规范下的输出到一个文件，尝试过 Webpack 打包，效果不佳，无法正常运行并且似乎会将依赖库的代码一并合并，导致文件异常巨大。也有可能是对此操作失误。</p>\n<p>不知道有无相关工具能够实现此需求？还望指教！</p>\n</div>",
      "title": "在 Typescript 中如何将 CommonJS 规范的代码合并到一个文件中？",
      "author": {
        "loginname": "Suwings",
        "avatar_url": "https://avatars.githubusercontent.com/u/18360009?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 115,
      "country": "Japan"
    },
    {
      "id": "614aa601fe0c519620aeac5a",
      "content": "<div class=\"markdown-text\"><p>###各位大神好\n新人初来乍到，产品经理学习node，希望能完成独立的简单系统开发。希望能向大家学习，共同成长！！！</p>\n</div>",
      "title": "新人打招呼",
      "author": {
        "loginname": "546566696",
        "avatar_url": "https://avatars.githubusercontent.com/u/11720024?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 116,
      "country": "USA"
    },
    {
      "id": "614e6e60fe0c5146dcaeb5a7",
      "content": "<div class=\"markdown-text\"><p>2018年5599买的，几个月前发现电池开始怀孕了，现在连后盖都顶起来了，虽然我是米粉，但是这次不得不让我黑它一次\n对比手上两个功能手机的电池，一个是金立的手机2009年产的电池至今一点鼓包的迹象都没有\n另一个是杂牌机，2015年产的电池，至今也是一点鼓包迹象都没有\n原本我以为所有软包电池都会鼓包，中秋节的时候收到群友捐赠的用于研究的金立手机我真的是很震惊，十多年了的电池一点鼓包都没有，小米连这点都做不好，该严厉批评</p>\n</div>",
      "title": "小米笔记本pro电池怀孕了",
      "author": {
        "loginname": "zengming00",
        "avatar_url": "https://avatars.githubusercontent.com/u/5255081?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 117,
      "country": "Eurozone"
    },
    {
      "id": "614c3be3fe0c516944aeb0ec",
      "content": "<div class=\"markdown-text\"><p>我用lerna对多个模块进行管理，模块之间存在依赖关系。当我把模块上传到npm后，再用lerna进行包依赖添加时:lerna add xxx --scope xxx，引用 的又是npm上的包，有什么办法能让本地调试时用本地的模块，发布后就用线上的模块</p>\n</div>",
      "title": "如何用lerna对本地module进行联调",
      "author": {
        "loginname": "hetchzhao",
        "avatar_url": "https://avatars.githubusercontent.com/u/6813909?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 118,
      "country": "Japan"
    },
    {
      "id": "614d3dd1fe0c514500aeb27e",
      "content": "<div class=\"markdown-text\"><p>背景：有个朋友是搞上位机，写C++的，我们用的是基于Qt的JS引擎。\n问题：他问我在JavsScript里，require一个模块之后，为什么不能直接用里面的方法。\n我的回答：\n其实一开始我其实没get到他的意思，讲export，然后又拿死月大佬的《来一打C++扩展》翻了翻，半天鸡同鸭讲。\n后来我是这么回答的，在某个模块 require了另个模m块，直接用a() ，其实是用当前模块.prototype.a() 而不是m.a()，JS中的OOP并非是传统的OOP。\n想请教一下社区里的各位大佬，node里面的require、import 和C++中的import的区别</p>\n</div>",
      "title": "关于import的一个疑问",
      "author": {
        "loginname": "ScarletMoki",
        "avatar_url": "https://avatars.githubusercontent.com/u/48669229?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 119,
      "country": "Eurozone"
    },
    {
      "id": "614ca90cfe0c5129c6aeb1a3",
      "content": "<div class=\"markdown-text\"><p>我使用 <code>npm i ws</code> 安装ws库\n淘宝源会自动安装peerDependencies里的<code>bufferutil</code>和<code>utf-8-validate</code>模块\n由于是addon模块，有些环境下会直接导致安装失败。\n换成官方源就正常，不会自动安装这两个模块。</p>\n<p>按理说只是换个源，不应该出现行为不一致。\n一头雾水。（npm版本是7.22.0）</p>\n</div>",
      "title": "npm淘宝源对于peerDependencies的异常行为",
      "author": {
        "loginname": "takayama-lily",
        "avatar_url": "https://avatars.githubusercontent.com/u/12014361?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 120,
      "country": "Eurozone"
    },
    {
      "id": "614c3f0bfe0c51369baeb100",
      "content": "<div class=\"markdown-text\"><p>本地调试Cli，用的webpack，webpack-chain，progress-webpack-plugin实现展示webpack打包进度的功能。通过npm link执行时，正常显示；从npm安装打包上传的cli执行时，报错：ValidationError: Progress Plugin Invalid Options，有人遇到过这个问题么。</p>\n</div>",
      "title": "npm link后的包与打包上传后的包运行情况不一致",
      "author": {
        "loginname": "hetchzhao",
        "avatar_url": "https://avatars.githubusercontent.com/u/6813909?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 121,
      "country": "China"
    },
    {
      "id": "6139cac1fe0c5105afae9667",
      "content": "<div class=\"markdown-text\"><h1>一、<a href=\"https://github.com/digitalinfinity/generator-napi-module\">使用yeoman 生成器  创建下一代 Node 原生模块的 N-API</a></h1>\n<h4>1. 安装 Yeoman 和 generator-napi-module (我们假设已经预装了node.js)</h4>\n<pre class=\"prettyprint\"><code>npm install -g yo\nnpm install -g generator-napi-module\n</code></pre><h5>2. 创建工程目录</h5>\n<pre class=\"prettyprint\"><code>$ mkdir -p evpp_module &amp;&amp; cd evpp_module\n</code></pre><h5>3. 创建工程(yo napi-module)</h5>\n<p>生成ts版本的: Would you like to generate TypeScript wrappers for your module? Yes</p>\n<pre class=\"prettyprint\"><code>evpp_module$ yo napi-module\n\n     _-----_     ╭──────────────────────────╮\n    |       |    │      Welcome to the      │\n    |--(o)--|    │  bedazzling N-API module │\n   &#96;---------´   │        generator!        │\n    ( _´U&#96;_ )    ╰──────────────────────────╯\n    &#x2F;___A___\\   &#x2F;\n     |  ~  |     \n   __&#x27;.___.&#x27;__   \n ´   &#96;  |° ´ Y &#96; \n\npackage name: (evpp_module) \nversion: (1.0.0) \ndescription: evpp module\ngit repository: \nkeywords: \nauthor: \nlicense: (ISC) \nAbout to write to &#x2F;data&#x2F;gocpplua&#x2F;gocpplua_node&#x2F;mylearn&#x2F;proj&#x2F;napi_demo_evpp&#x2F;evpp_module&#x2F;package.json:\n\n{\n  &quot;main&quot;: &quot;lib&#x2F;binding.js&quot;,\n  &quot;dependencies&quot;: {\n    &quot;node-addon-api&quot;: &quot;^1.1.0&quot;\n  },\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;node --napi-modules .&#x2F;test&#x2F;test_binding.js&quot;\n  },\n  &quot;gypfile&quot;: true,\n  &quot;name&quot;: &quot;evpp_module&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;evpp module&quot;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n}\n\n\nIs this OK? (yes) yes\n? Choose a template Object Wrap\n? Would you like to generate TypeScript wrappers for your module? Yes\nUpdated package.json to support TypeScript\n   create binding.gyp\n   create lib&#x2F;binding.ts\n   create src&#x2F;evpp_module.cc\n   create src&#x2F;evpp_module.h\n   create test&#x2F;test_binding.js\n   create tsconfig.json\n\n&gt; evpp_module@1.0.0 install &#x2F;data&#x2F;gocpplua&#x2F;gocpplua_node&#x2F;mylearn&#x2F;proj&#x2F;napi_demo_evpp&#x2F;evpp_module\n&gt; node-gyp rebuild\n\nmake: Entering directory &#x27;&#x2F;data&#x2F;gocpplua&#x2F;gocpplua_node&#x2F;mylearn&#x2F;proj&#x2F;napi_demo_evpp&#x2F;evpp_module&#x2F;build&#x27;\n  CC(target) Release&#x2F;obj.target&#x2F;nothing&#x2F;node_modules&#x2F;node-addon-api&#x2F;src&#x2F;nothing.o\n  AR(target) Release&#x2F;obj.target&#x2F;node_modules&#x2F;node-addon-api&#x2F;src&#x2F;nothing.a\n  COPY Release&#x2F;nothing.a\n  CXX(target) Release&#x2F;obj.target&#x2F;evpp_module-native&#x2F;src&#x2F;evpp_module.o\n  SOLINK_MODULE(target) Release&#x2F;obj.target&#x2F;evpp_module-native.node\n  COPY Release&#x2F;evpp_module-native.node\nmake: Leaving directory &#x27;&#x2F;data&#x2F;gocpplua&#x2F;gocpplua_node&#x2F;mylearn&#x2F;proj&#x2F;napi_demo_evpp&#x2F;evpp_module&#x2F;build&#x27;\nnpm notice created a lockfile as package-lock.json. You should commit this file.\nnpm WARN evpp_module@1.0.0 No repository field.\n\nadded 3 packages from 54 contributors in 2.242s\n</code></pre><h5>4. 生成后的目录结构</h5>\n<pre class=\"prettyprint\"><code>.\n├── binding.gyp\n├── build &#x2F;&#x2F; 通过 node-gyp configure 自动生成，可删\n│   ├── binding.Makefile\n│   ├── config.gypi\n│   ├── evpp_module-native.target.mk\n│   ├── Makefile\n│   ├── node_modules\n│   └── Release\n├── lib\n│   └── binding.ts\n├── node_modules  &#x2F;&#x2F; 通过npm install 自动生成，可删\n│   ├── node-addon-api\n│   ├── @types\n│   └── typescript\n├── package.json\n├── package-lock.json\n├── src\n│   ├── evpp_module.cc\n│   └── evpp_module.h\n├── test\n│   └── test_binding.js\n└── tsconfig.json\n</code></pre><h1>二、构建基础项目</h1>\n<pre class=\"prettyprint\"><code>$ npm test\n\n&gt; evpp_module@1.0.0 pretest &#x2F;data&#x2F;gocpplua&#x2F;gocpplua_node&#x2F;mylearn&#x2F;proj&#x2F;napi_demo_evpp&#x2F;evpp_module\n&gt; tsc\n\nnode_modules&#x2F;@types&#x2F;node&#x2F;index.d.ts:20:1 - error TS1084: Invalid &#x27;reference&#x27; directive syntax.\n\n20 &#x2F;&#x2F;&#x2F; &lt;reference lib=&quot;es2016&quot; &#x2F;&gt;\n   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nnpm ERR! Test failed.  See above for more details.\n</code></pre><p>虽然出现error，但是不影响。　还是会生成 dist/binding.js。</p>\n<p>如果想要修改，那么删除 node_modules，然后package.json中，将typescript修改如下后，再安装依赖包npm install:</p>\n<pre class=\"prettyprint\"><code>&quot;typescript&quot;: &quot;^4.3.5&quot;\n</code></pre><h1>三、　运行</h1>\n<pre class=\"prettyprint\"><code>$ node test&#x2F;test_binding.js \nHello kermit\nI am mr-yeoman\nTests passed- everything looks OK!\n</code></pre><h1>四、引入evpp(提前是已经编译好evpp,查看/usr/local/lib/libevpp.so)</h1>\n<h3>1.　修改 <code>evpp_module.cc</code></h3>\n<ul>\n<li>1.1 添加:</li>\n</ul>\n<pre class=\"prettyprint\"><code>#include &lt;evpp&#x2F;event_loop.h&gt;\n\nvoid Print(){\n    evpp::EventLoop loop;\n    std::cout &lt;&lt; &quot;evpp&quot; &lt;&lt; std::endl;\n}\n\n</code></pre><ul>\n<li>1.2 EvppModule::Greet 中调用</li>\n</ul>\n<pre class=\"prettyprint\"><code>    printf(&quot;Hello %s\\n&quot;, name.Utf8Value().c_str());\n    printf(&quot;I am %s\\n&quot;, this-&gt;_greeterName.c_str());\n    Print();  &#x2F;&#x2F; 加入的是这行\n    return Napi::String::New(env, this-&gt;_greeterName);\n</code></pre><h3>２．修改 binding.gyp( 如下注释点1,2,3 )</h3>\n<pre class=\"prettyprint\"><code>{\n  &#x27;targets&#x27;: [\n    {\n      &#x27;target_name&#x27;: &#x27;evpp_module-native&#x27;,\n      &#x27;sources&#x27;: [ &#x27;src&#x2F;evpp_module.cc&#x27; ],\n      &#x27;include_dirs&#x27;: [&quot;&lt;!@(node -p \\&quot;require(&#x27;node-addon-api&#x27;).include\\&quot;)&quot;],\n      &#x27;dependencies&#x27;: [&quot;&lt;!(node -p \\&quot;require(&#x27;node-addon-api&#x27;).gyp\\&quot;)&quot;],\n      &#x27;link_settings&#x27;: {    # 1. 添加evpp动态库引用\n        &#x27;library_dirs&#x27;: [&quot;&#x2F;usr&#x2F;local&#x2F;lib&quot;],\n        &#x27;libraries&#x27;: [&#x27;-levpp&#x27;],\n      },\n      &#x27;cflags!&#x27;: [ &#x27;-fno-exceptions&#x27;, &#x27;-fno-rtti&#x27; ], # 2. 添加:&#x27;-fno-rtti&#x27;, 解决cannot use typeid with -fno-rtti\n      &#x27;cflags_cc!&#x27;: [ &#x27;-fno-exceptions&#x27;, &#x27;-fno-rtti&#x27; ], # 3. 添加:&#x27;-fno-rtti&#x27;, 解决cannot use typeid with -fno-rtti\n      &#x27;xcode_settings&#x27;: {\n        &#x27;GCC_ENABLE_CPP_EXCEPTIONS&#x27;: &#x27;YES&#x27;,\n        &#x27;CLANG_CXX_LIBRARY&#x27;: &#x27;libc++&#x27;,\n        &#x27;MACOSX_DEPLOYMENT_TARGET&#x27;: &#x27;10.7&#x27;\n      },\n      &#x27;msvs_settings&#x27;: {\n        &#x27;VCCLCompilerTool&#x27;: { &#x27;ExceptionHandling&#x27;: 1 },\n      }\n    }\n  ]\n}\n</code></pre><h3>3. 编译</h3>\n<pre class=\"prettyprint\"><code>$ node-gyp build\ngyp info it worked if it ends with ok\ngyp info using node-gyp@3.0.3\ngyp info using node@4.2.6 | linux | x64\ngyp info spawn make\ngyp info spawn args [ &#x27;BUILDTYPE=Release&#x27;, &#x27;-C&#x27;, &#x27;build&#x27; ]\nmake: Entering directory &#x27;&#x2F;data&#x2F;gocpplua&#x2F;gocpplua_node&#x2F;mylearn&#x2F;proj&#x2F;napi_demo_evpp&#x2F;evpp_module&#x2F;build&#x27;\n  ACTION Regenerating Makefile\nmake: Nothing to be done for &#x27;all&#x27;.\nmake: Leaving directory &#x27;&#x2F;data&#x2F;gocpplua&#x2F;gocpplua_node&#x2F;mylearn&#x2F;proj&#x2F;napi_demo_evpp&#x2F;evpp_module&#x2F;build&#x27;\ngyp info ok \n</code></pre><h3>4. 运行</h3>\n<p>可以看到打印了我们加入的代码:evpp</p>\n<pre class=\"prettyprint\"><code>$ node test&#x2F;test_binding.js \nWARNING: Logging before InitGoogleLogging() is written to STDERR\nI0909 16:19:23.865659  3207 inner_pre.cc:27] ignore SIGPIPE\nHello kermit\nI am mr-yeoman\nI0909 16:19:23.867280  3207 event_loop.cc:11] evpp::EventLoop::EventLoop() this=0x7ffe46556ca0 \nI0909 16:19:23.867475  3207 event_loop.cc:56] void evpp::EventLoop::Init() this=0x7ffe46556ca0 \nevpp    &lt;-------  这个就是我加入的代码\nI0909 16:19:23.867569  3207 event_loop.cc:43] evpp::EventLoop::~EventLoop() this=0x7ffe46556ca0 \nTests passed- everything looks OK!\n</code></pre><h3>5. 在test_binding.js中添加定时器，脚本不退出:</h3>\n<pre class=\"prettyprint\"><code>setInterval(()=&gt;{\n    const instance = new EvppModule(&quot;cc&quot;);\n    instance.greet(&quot;qqqqq&quot;)  &#x2F;&#x2F; 每个一段时间就打印\n}, 5000)\n</code></pre><h1>五、源码</h1>\n<p><a href=\"https://github.com/gocpplua/node.git\">github</a> -&gt; mylearn/proj/napi_demo_evpp</p>\n</div>",
      "title": "evpp接入到nodejs",
      "author": {
        "loginname": "gocpplua",
        "avatar_url": "https://avatars.githubusercontent.com/u/46804866?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 122,
      "country": "China"
    },
    {
      "id": "6125a77ffe0c515cb1ae7002",
      "content": "<div class=\"markdown-text\"><p>首先上链接</p>\n<ul>\n<li><a href=\"https://github.com/huaize2020/awesome-nodejs\">https://github.com/huaize2020/awesome-nodejs</a></li>\n<li><a href>https://github.com/huaize2020/awesome-koa</a></li>\n<li><a href=\"https://github.com/huaize2020/awesome-egg\">https://github.com/huaize2020/awesome-egg</a></li>\n</ul>\n<h3>做这个仓库的目的</h3>\n<p>接触nodejs蛮长时间，但一直对Node.js路径很迷茫，熟悉了koa/express/egg/nest这些web框架是不是就可以了，熟悉了构建工具链是不是就可以了，还需要熟悉什么？没有项目没法成长怎么办？</p>\n<p>然后去搜了一下nodejs的资源，大部分都是基于41k star的翻译，部分2020年就没有更新跟进，对国内的很多库也不是友好；分类体系也不够细；</p>\n<p>因为上面这些原因萌生了自己动手整理awesome-nodejs的想法；</p>\n<h3>发这个贴的目的</h3>\n<p>经过近4个月几乎每天的更新，基本出来一个雏形；但鉴于自己node.js经验并不是很丰富，会缺失很多，希望可以社区一起维护这个库，欢迎一起贡献啊。</p>\n<p>希望可以帮助更多同学，成为一个查询的百宝箱。</p>\n<h3>未来的规划</h3>\n<p>方便开发者选库是目标之一，但是自己在使用过程中发现光是把库枚举列举出来并没有什么用。所以未来会按照类别，收集一些关于库对比的一些优质文章供参考；</p>\n<p>更详细的细分，做着做着发现光是枚举node相关的库不够，细分领域很多；可能涉及到awesome-koa balabala；本着不重复造的目的，如果该细分有高质，不再建设；如果没有就会自己更详细的整理。</p>\n<h3>最后</h3>\n<p>欢迎大家一起维护，欢迎PR</p>\n</div>",
      "title": "分享一些awesome-nodejs仓库",
      "author": {
        "loginname": "colorful-pang",
        "avatar_url": "https://avatars.githubusercontent.com/u/89496555?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 123,
      "country": "Japan"
    },
    {
      "id": "613208ebfe0c5164c8ae8971",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-js\"><code>fs.writeFile(&#x27;01.doc&#x27;, &#x27;001&#x27;, {flag: &#x27;a&#x27;}, (err) =&gt; {\n    if (err) {\n        console.log(&#x27;error&#x27;, err)\n    }\n    console.log(&#x27;success&#x27;)\n})\n</code></pre><p>这是我写的代码 ，用这种方式创建文件创建了以后，手动打开文件后，修改了内容就无法保存。提示 文件可能与 纯文本 格式不兼容。  请问各位这个怎么办？</p>\n<p><strong>谢谢</strong></p>\n</div>",
      "title": "fs 模块创建word 的doc文件，写入后不能保存的问题????",
      "author": {
        "loginname": "Joshua-leyer",
        "avatar_url": "https://avatars.githubusercontent.com/u/40789418?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 124,
      "country": "USA"
    },
    {
      "id": "6148a66efe0c51a586aeab22",
      "content": "<div class=\"markdown-text\"><p>有一个主项目 前端后端在一起。 react 服务端渲染，部署在根目录，egg 作为后端，开启了 csrf。</p>\n<p>最近又写了一个 admin 项目，用的是 antd pro 那一套，纯前端项目，部署在 /admin/ 目录下。</p>\n<p>admin 纯前端项目， 接口就写在了主项目里面。</p>\n<p>域名是同一个 , 主项目地址是 <a href=\"http://abc.com/xxx\">abc.com/xxx</a> ，admin 项目是 <a href=\"http://abc.com/admin/xxx\">abc.com/admin/xxx</a> ， 由于 admin 主要是内部使用，访问过主项目 cookie 就种上了。但是 还是会报 csrf token 错误， 想请教一下这个是什么原因</p>\n</div>",
      "title": "egg csrf token 问题请教",
      "author": {
        "loginname": "PeakFish",
        "avatar_url": "https://avatars2.githubusercontent.com/u/4606475?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 125,
      "country": "Japan"
    },
    {
      "id": "614aa092fe0c5180c8aeac46",
      "content": "<div class=\"markdown-text\"><p>主题：民生香港卡团办-周五（9月24号）\n门槛：5万存款/3个月\n地点：北京-中关村-海淀黄庄\n材料：护照 + 签证（淘宝购买尼泊尔签证）+ 身份证\n报名：填写问卷后，联系西门先生微信</p>\n<p>填写报名表：民生香港卡-团办报名\n<a href=\"https://docs.qq.com/form/page/DRFFUQmhzYXFEZkFJ?_w_tencentdocx_form=1\">https://docs.qq.com/form/page/DRFFUQmhzYXFEZkFJ?_w_tencentdocx_form=1</a></p>\n</div>",
      "title": "程序员低门槛民生香港卡团办-周五（9月24号）",
      "author": {
        "loginname": "lvgithub",
        "avatar_url": "https://avatars.githubusercontent.com/u/16065346?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 126,
      "country": "USA"
    },
    {
      "id": "61473514fe0c51f047aeaa92",
      "content": "<div class=\"markdown-text\"><p>上代码，下面的 id 字段 和 status 字段，如果前端没有传过来这个字段，那就 去掉筛选 或 者查询全部。这块应该怎么写？</p>\n<pre class=\"prettyprint language-js\"><code>const findList = await userModel\n  &#x2F;&#x2F; mongoose 的查找方法\n  .find({\n    nickname: { $regex: nicknameReg },\n    _id: id ? ObjectId(id) : &#x27;查询字段的所有状态 或者 不查询这个字段， 这块需要怎么写？&#x27;,\n    status: status ? status : &#x27;查询字段的所有状态 或者 不查询这个字段， 这块需要怎么写？&#x27;\n  })\n</code></pre></div>",
      "title": "node mongoose 查找 find ，当前端没有传过来筛选参数的时候 ，查找条件这块应该怎么写？",
      "author": {
        "loginname": "PeakFish",
        "avatar_url": "https://avatars2.githubusercontent.com/u/4606475?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 127,
      "country": "Eurozone"
    },
    {
      "id": "6145cf1efe0c516ed4aea9b1",
      "content": "<div class=\"markdown-text\"><p>按这篇文章的说法 <a href=\"https://linux.cn/article-13780-1.html\">https://linux.cn/article-13780-1.html</a>  是因为改界面\n<img src=\"//static.cnodejs.org/FlKv9bdofLmzNNmK_kEmq0hARSAi\" alt=\"out.jpg\">\n原来是地址栏在上面 标签在下面\n两个换个位置就流失5亿用户\n改界面真的会丧失用户吗?</p>\n</div>",
      "title": "是什么原因导致firefox 丢失用户市场?",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 128,
      "country": "USA"
    },
    {
      "id": "60e669d4ba74606a00862e23",
      "content": "<div class=\"markdown-text\"><p>原文:<a href=\"https://javascript.plainenglish.io/creating-a-rest-api-with-jwt-authentication-and-role-based-authorization-using-typescript-fbfa3cab22a4\">TypeScript Rest API with Express.js, JWT, Authorization Roles and TypeORM</a></p>\n<blockquote>\n<p>带有 Express.js、JWT、授权角色和 TypeORM 的 TypeScript Rest API</p>\n</blockquote>\n<p>今天，我们将使用 TypeScript Express.js 和 TypeORM 创建具有 JWT 身份验证和基于角色的授权的企业级 Rest API。 目标是创建一个存储库，您可以将其用作现实生活项目的基础。</p>\n<p>在我们开始之前，建议您熟悉以下主题。 你不需要成为专家，但如果你从未听说过其中一个，我选择了一个介绍性阅读：</p>\n<h4>什么是 Rest API 和基础 http 响应代码</h4>\n<ul>\n<li><a href=\"https://medium.com/@parastripathi/what-is-rest-api-a-beginners-guide-700e4931e67c\">什么是 REST API：初学者指南</a></li>\n</ul>\n<h4>什么是 JWT 以及为什么我们使用它来进行无状态身份验证</h4>\n<ul>\n<li><a href=\"https://morioh.com/p/63009714b79a\">通过 5 个简单步骤了解 JSON Web 令牌 (JWT)</a></li>\n</ul>\n<h4>什么是 ORM（对象-关系-映射器）</h4>\n<ul>\n<li><a href=\"https://blog.bitsrc.io/what-is-an-orm-and-why-you-should-use-it-b2b6f75f5e2a\">什么是 ORM 以及为什么要使用它</a></li>\n<li></li>\n</ul>\n<h4>为什么是 TypeORM？</h4>\n<p>TypeORM 允许您只编写一个 TypeScript 类，并且使用同步工具，它会自动为您的实体生成所有 SQL 结构。 使用 class-validator 包，我们可以使用相同的模型类进行验证。</p>\n<p>它与 MySQL / MariaDB / Postgres / SQLite / Microsoft SQL Server / Oracle / sql.js / MongoDB 兼容。 您可以在这些数据库之间切换，而无需重写代码。</p>\n<p>我们将使用 SQLite 开始这个项目。 我不建议保留它用于生产。 但是，因为我不知道您将使用什么 DB，它允许我们制作一个通用项目，您只需“npm install”即可运行该项目，而无需设置数据库服务器。</p>\n<h3>开始吧</h3>\n<p>TypeORM 有一个 CLI 工具，允许我们生成一个已经在 TypeScript 中的基本应用程序。 要使用这个工具，我们首先需要安装 typeORM 作为全局依赖：</p>\n<pre class=\"prettyprint\"><code>npm install -g typeorm\n</code></pre><p>现在我们可以设置我们的应用程序：</p>\n<pre class=\"prettyprint\"><code>typeorm init --name jwt-express-typeorm --database sqlite --express\n</code></pre><p>它将使用 TypeORM 和 body-parser 在 TypeScript 中创建一个示例 express 应用程序。 让我们安装这些依赖项：</p>\n<pre class=\"prettyprint\"><code>npm install\n</code></pre><p>现在，我们将安装一些额外的依赖项:</p>\n<pre class=\"prettyprint\"><code>npm install -s helmet cors jsonwebtoken bcryptjs class-validator ts-node-dev\n</code></pre><p>之后，我们将拥有以下依赖项:</p>\n<ul>\n<li>helmet:通过设置各种 HTTP 标头帮助我们保护我们的应用程序</li>\n<li>cors:启用跨域请求</li>\n<li>body-parser:将客户端的请求从 json 解析为 javascript 对象</li>\n<li>jsonwebtoken:将为我们处理 jwt 操作</li>\n<li>bcryptjs: 帮助我们散列用户密码</li>\n<li>typeorm:我们将用于操作数据库的 ORM</li>\n<li>reflect-metadata:允许一些与 TypeORM 一起使用的注释功能</li>\n<li>class-validator:一个非常适合 TypeORM 的验证包</li>\n<li>sqlite3:我们将使用 sqlite 作为开发数据库</li>\n<li>ts-node-dev:当我们更改任何文件时自动重新启动服务器</li>\n</ul>\n<h4>安装类型检查依赖项</h4>\n<p>由于我们正在使用 TypeScript，因此为我们的依赖项安装 <a href=\"/user/types\">@types</a> 是个好主意。</p>\n<pre class=\"prettyprint\"><code>npm install -s [@types](&#x2F;user&#x2F;types)&#x2F;bcryptjs [@types](&#x2F;user&#x2F;types)&#x2F;body-parser [@types](&#x2F;user&#x2F;types)&#x2F;cors [@types](&#x2F;user&#x2F;types)&#x2F;helmet [@types](&#x2F;user&#x2F;types)&#x2F;jsonwebtoken\n</code></pre><p>之后，即使使用 JavaScript 包，您也可以使用自动完成和类型检查。</p>\n<h4>源文件夹</h4>\n<p>TypeORM CLI 创建了一个包含所有typescript文件的 src 文件夹。 现在我们将修改这些文件以创建我们的 API。\n<img src=\"https://miro.medium.com/max/671/1*ctZ7uPNEt8Xmknjb2OH8eA.png\" alt=\"image\"></p>\n<h4>Index</h4>\n<p>CLI 已经创建了一个 index.ts 文件作为应用程序的入口点。 让我们重写以更好地满足我们的目的。</p>\n<pre class=\"prettyprint\"><code>import &quot;reflect-metadata&quot;;\nimport { createConnection } from &quot;typeorm&quot;;\nimport * as express from &quot;express&quot;;\nimport * as bodyParser from &quot;body-parser&quot;;\nimport * as helmet from &quot;helmet&quot;;\nimport * as cors from &quot;cors&quot;;\nimport routes from &quot;.&#x2F;routes&quot;;\n\n&#x2F;&#x2F;Connects to the Database -&gt; then starts the express\ncreateConnection()\n  .then(async connection =&gt; {\n    &#x2F;&#x2F; Create a new express application instance\n    const app = express();\n\n    &#x2F;&#x2F; Call midlewares\n    app.use(cors());\n    app.use(helmet());\n    app.use(bodyParser.json());\n\n    &#x2F;&#x2F;Set all routes from routes folder\n    app.use(&quot;&#x2F;&quot;, routes);\n\n    app.listen(3000, () =&gt; {\n      console.log(&quot;Server started on port 3000!&quot;);\n    });\n  })\n  .catch(error =&gt; console.log(error));\n</code></pre><h4>The routes</h4>\n<p>CLI 还创建了一个 routes.ts 文件。 在大型项目中，将所有路由放在同一个文件中可能不是一个好主意。 我们将创建一个路由/文件夹，其中包含一个 routes/index.ts 聚合来自其他文件的路由。</p>\n<ul>\n<li>routes/auth.ts</li>\n</ul>\n<pre class=\"prettyprint\"><code>import { Router } from &quot;express&quot;;\nimport AuthController from &quot;..&#x2F;controllers&#x2F;AuthController&quot;;\nimport { checkJwt } from &quot;..&#x2F;middlewares&#x2F;checkJwt&quot;;\n\nconst router = Router();\n&#x2F;&#x2F;Login route\nrouter.post(&quot;&#x2F;login&quot;, AuthController.login);\n\n&#x2F;&#x2F;Change my password\nrouter.post(&quot;&#x2F;change-password&quot;, [checkJwt], AuthController.changePassword);\n\nexport default router;\n</code></pre><ul>\n<li>routes/user.ts</li>\n</ul>\n<pre class=\"prettyprint\"><code>  import { Router } from &quot;express&quot;;\n  import UserController from &quot;..&#x2F;controllers&#x2F;UserController&quot;;\n  import { checkJwt } from &quot;..&#x2F;middlewares&#x2F;checkJwt&quot;;\n  import { checkRole } from &quot;..&#x2F;middlewares&#x2F;checkRole&quot;;\n\n  const router = Router();\n\n  &#x2F;&#x2F;Get all users\n  router.get(&quot;&#x2F;&quot;, [checkJwt, checkRole([&quot;ADMIN&quot;])], UserController.listAll);\n\n  &#x2F;&#x2F; Get one user\n  router.get(\n    &quot;&#x2F;:id([0-9]+)&quot;,\n    [checkJwt, checkRole([&quot;ADMIN&quot;])],\n    UserController.getOneById\n  );\n\n  &#x2F;&#x2F;Create a new user\n  router.post(&quot;&#x2F;&quot;, [checkJwt, checkRole([&quot;ADMIN&quot;])], UserController.newUser);\n\n  &#x2F;&#x2F;Edit one user\n  router.patch(\n    &quot;&#x2F;:id([0-9]+)&quot;,\n    [checkJwt, checkRole([&quot;ADMIN&quot;])],\n    UserController.editUser\n  );\n\n  &#x2F;&#x2F;Delete one user\n  router.delete(\n    &quot;&#x2F;:id([0-9]+)&quot;,\n    [checkJwt, checkRole([&quot;ADMIN&quot;])],\n    UserController.deleteUser\n  );\n\n  export default router;\n</code></pre><ul>\n<li>routes/index.ts</li>\n</ul>\n<pre class=\"prettyprint\"><code>import { Router, Request, Response } from &quot;express&quot;;\nimport auth from &quot;.&#x2F;auth&quot;;\nimport user from &quot;.&#x2F;user&quot;;\n\nconst routes = Router();\n\nroutes.use(&quot;&#x2F;auth&quot;, auth);\nroutes.use(&quot;&#x2F;user&quot;, user);\n\nexport default routes;\n</code></pre><p>例如，要访问登录路由，您将调用：</p>\n<pre class=\"prettyprint\"><code>http:&#x2F;&#x2F;localhost:3000&#x2F;auth&#x2F;login\n</code></pre><h4>Middleware</h4>\n<p>如您所见，路由在调用控制器之前调用了一些中间件。 中间件实际上只是一个操作您的请求并调用下一个中间件的函数。 最好的理解方法是创建您的第一个中间件。</p>\n<ul>\n<li>middlewares/checkJwt.ts\n这个中间件将在每条需要登录用户的路由上调用。 它将检查我们在请求标头上是否有有效的 JWT。 如果令牌有效，它将调用由控制器处理的下一个函数。 否则，它将发送带有 401（未授权）状态代码的响应。</li>\n</ul>\n<pre class=\"prettyprint\"><code>import { Request, Response, NextFunction } from &quot;express&quot;;\nimport * as jwt from &quot;jsonwebtoken&quot;;\nimport config from &quot;..&#x2F;config&#x2F;config&quot;;\n\nexport const checkJwt = (req: Request, res: Response, next: NextFunction) =&gt; {\n  &#x2F;&#x2F;Get the jwt token from the head\n  const token = &lt;string&gt;req.headers[&quot;auth&quot;];\n  let jwtPayload;\n  \n  &#x2F;&#x2F;Try to validate the token and get data\n  try {\n    jwtPayload = &lt;any&gt;jwt.verify(token, config.jwtSecret);\n    res.locals.jwtPayload = jwtPayload;\n  } catch (error) {\n    &#x2F;&#x2F;If token is not valid, respond with 401 (unauthorized)\n    res.status(401).send();\n    return;\n  }\n\n  &#x2F;&#x2F;The token is valid for 1 hour\n  &#x2F;&#x2F;We want to send a new token on every request\n  const { userId, username } = jwtPayload;\n  const newToken = jwt.sign({ userId, username }, config.jwtSecret, {\n    expiresIn: &quot;1h&quot;\n  });\n  res.setHeader(&quot;token&quot;, newToken);\n\n  &#x2F;&#x2F;Call the next middleware or controller\n  next();\n};\n</code></pre><ul>\n<li>middlewares/checkRole.ts</li>\n<li>即使用户有效登录，他也可能尝试访问他可能没有角色授权访问的路由。 该中间件将检查登录用户是否真的具有访问此路由所需的角色。 如果没有，请回复 401（未授权）状态代码。 请注意，我们将角色设置为字符串数组。 这是因为您将来可能需要多个角色来访问同一路由。</li>\n</ul>\n<pre class=\"prettyprint\"><code>import { Request, Response, NextFunction } from &quot;express&quot;;\nimport { getRepository } from &quot;typeorm&quot;;\n\nimport { User } from &quot;..&#x2F;entity&#x2F;User&quot;;\n\nexport const checkRole = (roles: Array&lt;string&gt;) =&gt; {\n  return async (req: Request, res: Response, next: NextFunction) =&gt; {\n    &#x2F;&#x2F;Get the user ID from previous midleware\n    const id = res.locals.jwtPayload.userId;\n\n    &#x2F;&#x2F;Get user role from the database\n    const userRepository = getRepository(User);\n    let user: User;\n    try {\n      user = await userRepository.findOneOrFail(id);\n    } catch (id) {\n      res.status(401).send();\n    }\n\n    &#x2F;&#x2F;Check if array of authorized roles includes the user&#x27;s role\n    if (roles.indexOf(user.role) &gt; -1) next();\n    else res.status(401).send();\n  };\n};\n</code></pre><h4>The config file</h4>\n<p>要生成和验证 jwt 令牌，我们需要一个密钥。 我们将把它存储在一个配置文件中。 您可以将 jwtSecret 更改为您想要的任何字符串。</p>\n<ul>\n<li>config/config.ts</li>\n</ul>\n<pre class=\"prettyprint\"><code>export default {\n  jwtSecret: &quot;@QEGTUI&quot;\n};\n</code></pre><h4>The User entity</h4>\n<p>CLI 已经创建了一个“entity/User.ts”文件。 但是我们想要更改字段，添加验证并创建散列密码的方法。 所以我们需要重写这个类。</p>\n<ul>\n<li>entity/User.ts</li>\n</ul>\n<pre class=\"prettyprint\"><code>import {\n  Entity,\n  PrimaryGeneratedColumn,\n  Column,\n  Unique,\n  CreateDateColumn,\n  UpdateDateColumn\n} from &quot;typeorm&quot;;\nimport { Length, IsNotEmpty } from &quot;class-validator&quot;;\nimport * as bcrypt from &quot;bcryptjs&quot;;\n\n@Entity()\n@Unique([&quot;username&quot;])\nexport class User {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  @Length(4, 20)\n  username: string;\n\n  @Column()\n  @Length(4, 100)\n  password: string;\n\n  @Column()\n  @IsNotEmpty()\n  role: string;\n\n  @Column()\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @Column()\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  hashPassword() {\n    this.password = bcrypt.hashSync(this.password, 8);\n  }\n\n  checkIfUnencryptedPasswordIsValid(unencryptedPassword: string) {\n    return bcrypt.compareSync(unencryptedPassword, this.password);\n  }\n}\n</code></pre><h4>The Controllers</h4>\n<p>CLI 还创建了一个名为 controller 的文件夹。 您可以删除它，并创建另一个命名控制器（复数）。 然后我们将创建身份验证和用户控制器。</p>\n<ul>\n<li>controllers/AuthController.ts</li>\n</ul>\n<pre class=\"prettyprint\"><code>import { Request, Response } from &quot;express&quot;;\nimport * as jwt from &quot;jsonwebtoken&quot;;\nimport { getRepository } from &quot;typeorm&quot;;\nimport { validate } from &quot;class-validator&quot;;\n\nimport { User } from &quot;..&#x2F;entity&#x2F;User&quot;;\nimport config from &quot;..&#x2F;config&#x2F;config&quot;;\n\nclass AuthController {\n  static login = async (req: Request, res: Response) =&gt; {\n    &#x2F;&#x2F;Check if username and password are set\n    let { username, password } = req.body;\n    if (!(username &amp;&amp; password)) {\n      res.status(400).send();\n    }\n\n    &#x2F;&#x2F;Get user from database\n    const userRepository = getRepository(User);\n    let user: User;\n    try {\n      user = await userRepository.findOneOrFail({ where: { username } });\n    } catch (error) {\n      res.status(401).send();\n    }\n\n    &#x2F;&#x2F;Check if encrypted password match\n    if (!user.checkIfUnencryptedPasswordIsValid(password)) {\n      res.status(401).send();\n      return;\n    }\n\n    &#x2F;&#x2F;Sing JWT, valid for 1 hour\n    const token = jwt.sign(\n      { userId: user.id, username: user.username },\n      config.jwtSecret,\n      { expiresIn: &quot;1h&quot; }\n    );\n\n    &#x2F;&#x2F;Send the jwt in the response\n    res.send(token);\n  };\n\n  static changePassword = async (req: Request, res: Response) =&gt; {\n    &#x2F;&#x2F;Get ID from JWT\n    const id = res.locals.jwtPayload.userId;\n\n    &#x2F;&#x2F;Get parameters from the body\n    const { oldPassword, newPassword } = req.body;\n    if (!(oldPassword &amp;&amp; newPassword)) {\n      res.status(400).send();\n    }\n\n    &#x2F;&#x2F;Get user from the database\n    const userRepository = getRepository(User);\n    let user: User;\n    try {\n      user = await userRepository.findOneOrFail(id);\n    } catch (id) {\n      res.status(401).send();\n    }\n\n    &#x2F;&#x2F;Check if old password matchs\n    if (!user.checkIfUnencryptedPasswordIsValid(oldPassword)) {\n      res.status(401).send();\n      return;\n    }\n\n    &#x2F;&#x2F;Validate de model (password lenght)\n    user.password = newPassword;\n    const errors = await validate(user);\n    if (errors.length &gt; 0) {\n      res.status(400).send(errors);\n      return;\n    }\n    &#x2F;&#x2F;Hash the new password and save\n    user.hashPassword();\n    userRepository.save(user);\n\n    res.status(204).send();\n  };\n}\nexport default AuthController;\n</code></pre><ul>\n<li>controllers/UserController.ts</li>\n</ul>\n<pre class=\"prettyprint\"><code>import { Request, Response } from &quot;express&quot;;\nimport { getRepository } from &quot;typeorm&quot;;\nimport { validate } from &quot;class-validator&quot;;\n\nimport { User } from &quot;..&#x2F;entity&#x2F;User&quot;;\n\nclass UserController{\n\nstatic listAll = async (req: Request, res: Response) =&gt; {\n  &#x2F;&#x2F;Get users from database\n  const userRepository = getRepository(User);\n  const users = await userRepository.find({\n    select: [&quot;id&quot;, &quot;username&quot;, &quot;role&quot;] &#x2F;&#x2F;We dont want to send the passwords on response\n  });\n\n  &#x2F;&#x2F;Send the users object\n  res.send(users);\n};\n\nstatic getOneById = async (req: Request, res: Response) =&gt; {\n  &#x2F;&#x2F;Get the ID from the url\n  const id: number = req.params.id;\n\n  &#x2F;&#x2F;Get the user from database\n  const userRepository = getRepository(User);\n  try {\n    const user = await userRepository.findOneOrFail(id, {\n      select: [&quot;id&quot;, &quot;username&quot;, &quot;role&quot;] &#x2F;&#x2F;We dont want to send the password on response\n    });\n  } catch (error) {\n    res.status(404).send(&quot;User not found&quot;);\n  }\n};\n\nstatic newUser = async (req: Request, res: Response) =&gt; {\n  &#x2F;&#x2F;Get parameters from the body\n  let { username, password, role } = req.body;\n  let user = new User();\n  user.username = username;\n  user.password = password;\n  user.role = role;\n\n  &#x2F;&#x2F;Validade if the parameters are ok\n  const errors = await validate(user);\n  if (errors.length &gt; 0) {\n    res.status(400).send(errors);\n    return;\n  }\n\n  &#x2F;&#x2F;Hash the password, to securely store on DB\n  user.hashPassword();\n\n  &#x2F;&#x2F;Try to save. If fails, the username is already in use\n  const userRepository = getRepository(User);\n  try {\n    await userRepository.save(user);\n  } catch (e) {\n    res.status(409).send(&quot;username already in use&quot;);\n    return;\n  }\n\n  &#x2F;&#x2F;If all ok, send 201 response\n  res.status(201).send(&quot;User created&quot;);\n};\n\nstatic editUser = async (req: Request, res: Response) =&gt; {\n  &#x2F;&#x2F;Get the ID from the url\n  const id = req.params.id;\n\n  &#x2F;&#x2F;Get values from the body\n  const { username, role } = req.body;\n\n  &#x2F;&#x2F;Try to find user on database\n  const userRepository = getRepository(User);\n  let user;\n  try {\n    user = await userRepository.findOneOrFail(id);\n  } catch (error) {\n    &#x2F;&#x2F;If not found, send a 404 response\n    res.status(404).send(&quot;User not found&quot;);\n    return;\n  }\n\n  &#x2F;&#x2F;Validate the new values on model\n  user.username = username;\n  user.role = role;\n  const errors = await validate(user);\n  if (errors.length &gt; 0) {\n    res.status(400).send(errors);\n    return;\n  }\n\n  &#x2F;&#x2F;Try to safe, if fails, that means username already in use\n  try {\n    await userRepository.save(user);\n  } catch (e) {\n    res.status(409).send(&quot;username already in use&quot;);\n    return;\n  }\n  &#x2F;&#x2F;After all send a 204 (no content, but accepted) response\n  res.status(204).send();\n};\n\nstatic deleteUser = async (req: Request, res: Response) =&gt; {\n  &#x2F;&#x2F;Get the ID from the url\n  const id = req.params.id;\n\n  const userRepository = getRepository(User);\n  let user: User;\n  try {\n    user = await userRepository.findOneOrFail(id);\n  } catch (error) {\n    res.status(404).send(&quot;User not found&quot;);\n    return;\n  }\n  userRepository.delete(id);\n\n  &#x2F;&#x2F;After all send a 204 (no content, but accepted) response\n  res.status(204).send();\n};\n};\n\nexport default UserController;\n</code></pre><h4>通过文件的请求流</h4>\n<p>我们写了很多代码，忘记调用每个文件的顺序是可以的。 出于这个原因，我创建了一个简单的图表，它举例说明了需要检查角色并使用 userController 函数的用户请求的流程。\n<img src=\"https://miro.medium.com/max/700/1*cYneDhjzkAKDJBTEJ4rDog.png\" alt=\"image\"></p>\n<h3>开发和生产脚本</h3>\n<p><img src=\"https://miro.medium.com/max/2428/1*l5Eb6PGvHR0AB2XZsdCLBg.png\" alt=\"image\">\nNode.js 本身无法运行 .ts 文件。 因此，了解以下工具很重要。</p>\n<ul>\n<li>“tsc” — 创建一个 /build 文件夹并将所有 .ts 转换为 .js 文件。.</li>\n<li>“ts-node” — 允许节点运行 .ts 项目。 不推荐用于生产用途.</li>\n<li>“ts-node-dev” — 与上面相同，但允许您每次更改文件时重新启动节点服务器.</li>\n</ul>\n<p>为了更好地设置开发和生产环境，我们将修改 package.json 的脚本会话。</p>\n<pre class=\"prettyprint\"><code> &quot;scripts&quot;: {\n   &quot;tsc&quot;: &quot;tsc&quot;,\n   &quot;start&quot;: &quot;set debug=* &amp;&amp; ts-node-dev --respawn --transpileOnly .&#x2F;src&#x2F;index.ts&quot;,\n   &quot;prod&quot;: &quot;tsc &amp;&amp; node .&#x2F;build&#x2F;app.js&quot;,\n   &quot;migration:run&quot;: &quot;ts-node .&#x2F;node_modules&#x2F;typeorm&#x2F;cli.js migration:run&quot;\n }\n</code></pre><p>最后，我们添加名为 smigration:run 的最后一行。 一些 Windows 用户在尝试从 npm 运行 TypeORM 迁移时遇到错误。 直接从节点模块文件夹运行它可以解决问题。</p>\n<h3>第一个用户呢？</h3>\n<p>如您所见，即使要创建新用户，我们也需要已经拥有 ADMIN。 第一个用户将由迁移过程创建。 迁移对于维护生产数据库也非常重要。 如果您打算在生产中使用 TypeORM，我真的建议您阅读迁移文档：<a href=\"http://typeorm.io/#/migrations\">migrations</a>.</p>\n<p>现在，让我们创建我们的第一个迁移:</p>\n<pre class=\"prettyprint\"><code>typeorm migration:create -n CreateAdminUser\n</code></pre><p>然后，我们将修改生成的文件：</p>\n<pre class=\"prettyprint\"><code>import { MigrationInterface, QueryRunner, getRepository } from &quot;typeorm&quot;;\nimport { User } from &quot;..&#x2F;entity&#x2F;User&quot;;\n\nexport class CreateAdminUser1547919837483 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise&lt;any&gt; {\n    let user = new User();\n    user.username = &quot;admin&quot;;\n    user.password = &quot;admin&quot;;\n    user.hashPassword();\n    user.role = &quot;ADMIN&quot;;\n    const userRepository = getRepository(User);\n    await userRepository.save(user);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise&lt;any&gt; {}\n}\n</code></pre><p>现在我们启动服务器，所以同步工具可以生成我们的数据库表。</p>\n<pre class=\"prettyprint\"><code>npm start\n</code></pre><p>现在我们可以运行迁移，插入第一个管理员用户。</p>\n<pre class=\"prettyprint\"><code>npm run migration:run\n</code></pre><p>最后，您的服务器已准备就绪。 只需获取 Postman 或任何其他工具，然后提出一些请求即可。</p>\n<p>最终的存储库可以在 GitHub 上找到：<a href=\"https://github.com/andregardi/jwt-express-typeorm\">jwt-express-typeorm</a></p>\n</div>",
      "title": "【翻译】TypeScript Rest API with Express.js, JWT, Authorization Roles and TypeORM",
      "author": {
        "loginname": "gocpplua",
        "avatar_url": "https://avatars.githubusercontent.com/u/46804866?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 129,
      "country": "Eurozone"
    },
    {
      "id": "61311467fe0c51332dae8753",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>hi, all 今天来分享一个 nextjs 项目的 debug 过程, 更多可以持续关注 🌟 <a href=\"https://github.com/xiaoxiaojx/blog\">github | blog</a> 🌟</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/23253540/131141575-17cf74cd-403e-4834-802f-c9e298446457.png\" alt=\"image\"></p>\n<h2>热更新失败</h2>\n<p>无意间听到同学 A 说开发项目 B 这么久了, 开发时修改代码后页面内容未进行重新渲染, 甚至页面连刷新也没有 😨, 所以平时是手动刷新了一次浏览器, 惊讶之余就得快速解决这个问题。</p>\n<h2>热更新介绍</h2>\n<p>不同于 nodejs 项目修改代码后 pm2, nodemon, forever 等会对进程进行一下重启生效, 前端代码修改后的热更新流程还是比较长的, 主要为 webpack-dev-server 通过 websocket 去通知到浏览器, 参考图如下</p>\n<p><img src=\"https://user-images.githubusercontent.com/23253540/131143429-a66fb619-7aef-464d-af21-6de6eb7a1aec.png\" alt=\"image\"></p>\n<blockquote>\n<p>图片来自于 <a href=\"https://segmentfault.com/a/1190000020310371\">https://segmentfault.com/a/1190000020310371</a></p>\n</blockquote>\n<p>前端代码热更新除了上图其实还有另一种方式, 即没有使用 webpack-dev-server, 而是自己写的一个 dev-server, 热更新方面集成了 webpack-hot-middleware 实现, 后者通知到浏览器是使用了 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events/Using_server-sent_events\">SSE 服务器推送事件</a>, 因为有 dev-server 去单向通知浏览器就可以了, 不需要双向的 websocket</p>\n<p>本次有问题的项目是一个比较旧的 nextjs 项目, 其采用的就是后者 SSE 的方式, SSE 服务端的核心这里也简单说一下</p>\n<ul>\n<li>主要还是 Content-Type 的设置需要为 text/event-stream</li>\n<li>其次是 X-Accel-Buffering, 通常是不需要的, 主要用于中间还有 nginx 代理的情况, 让 nginx 有数据直接就发送出去, 不需要囤着, 之前做 node 流输出数据时就被坑过</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; SSE 服务端实现\n\nvar headers = {\n  &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;,\n  &#x27;Content-Type&#x27;: &#x27;text&#x2F;event-stream;charset=utf-8&#x27;,\n  &#x27;Cache-Control&#x27;: &#x27;no-cache, no-transform&#x27;,\n  &#x27;X-Accel-Buffering&#x27;: &#x27;no&#x27;,\n};\n\nres.writeHead(200, headers);\nres.write(&#x27;\\n&#x27;);\n</code></pre><p>devtool 中查看如下图示\n<img src=\"https://user-images.githubusercontent.com/23253540/131175957-7f820f04-c1a4-49b2-988e-f8410948495c.png\" alt=\"image\"></p>\n<h2>问题复现</h2>\n<p>启动问题项目, 修改代码后也是在进行正常的重新编译, 编译完成后浏览器也貌似收到了信息, 最后的日志停止在了 [Fast Refresh] done, 就没有下文了, 页面内容没有进行更新, 浏览器也没刷新\n<img src=\"https://user-images.githubusercontent.com/23253540/131147707-9bd3014f-860a-43c0-b872-461309df6c94.png\" alt=\"image\"></p>\n<h2>问题定位</h2>\n<h3>1. 修改后返回的是旧代码 ？</h3>\n<ul>\n<li>分析: 通常修改代码后, <a href=\"https://webpack.js.org/plugins/hot-module-replacement-plugin/\">HotModuleReplacementPlugin</a> 会生成一个 xxx.hot-update.js, 如果它出了故障, 返回的这个 js 有问题的话就能解释热更新失败\n<img src=\"https://user-images.githubusercontent.com/23253540/131149190-295af96c-2a93-466b-a98f-22b512204260.png\" alt=\"image\"></li>\n<li>结论: ❌ 仔细看了 .hot-update.js 内容后, 发现其实是带上了最新改动的内容, 故排除这个可能\n<img src=\"https://user-images.githubusercontent.com/23253540/131171371-fc3193f3-2f74-4dc8-a591-1beae470be33.png\" alt=\"image\"></li>\n</ul>\n<h3>2. 应用新代码的某个流程出错了 ？</h3>\n<p>这里就需要对 nextjs 客户端 SSE 部分的代码从起点开始进行一个 debug</p>\n<ol>\n<li>SSE 客户端的实现文件, 这部分通常是标准的 api 调用不会有什么问题</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; packages&#x2F;next&#x2F;client&#x2F;dev&#x2F;error-overlay&#x2F;eventsource.js\n\nsource = new window.EventSource(options.path)\nsource.onopen = handleOnline\nsource.onerror = handleDisconnect\nsource.onmessage = handleMessage\n</code></pre><ol>\n<li>收到服务器消息增加关键的监听函数, 发现了关键的 ⚠️ [Fast Refresh] done 日志, 继续挖 onRefresh 函数实现</li>\n</ol>\n<pre class=\"prettyprint\"><code>packages&#x2F;next&#x2F;client&#x2F;dev&#x2F;error-overlay&#x2F;hot-dev-client.js\n\nfunction onFastRefresh(hasUpdates) {\n  DevOverlay.onBuildOk()\n  if (hasUpdates) {\n    DevOverlay.onRefresh()\n  }\n\n  console.log(&#x27;[Fast Refresh] done&#x27;)\n}\n</code></pre><ol>\n<li>看样子 nextjs 实现了一个简单的 event, onRefresh 函数的作用为发布 TYPE_REFFRESH 事件</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; packages&#x2F;react-dev-overlay&#x2F;src&#x2F;client.ts\n\nfunction onRefresh() {\n  Bus.emit({ type: Bus.TYPE_REFFRESH })\n}\n</code></pre><ol>\n<li>App 最顶层的 ReactDevOverlay 组件订阅了 TYPE_REFFRESH 事件, 然后 state 状态发生变化, 触发重新渲染</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; packages&#x2F;react-dev-overlay&#x2F;src&#x2F;internal&#x2F;ReactDevOverlay.tsx\n\nconst ReactDevOverlay: React.FunctionComponent = function ReactDevOverlay({\n  children,\n}) {\n  const [state, dispatch] = React.useReducer&lt;\n    React.Reducer&lt;OverlayState, Bus.BusEvent&gt;\n  &gt;(reducer, { nextId: 1, buildError: null, errors: [] })\n\n  React.useEffect(() =&gt; {\n    Bus.on(dispatch)\n    return function () {\n      Bus.off(dispatch)\n    }\n  }, [dispatch])\n\n  const isMounted = hasBuildError || hasRuntimeErrors\n  return (\n    &lt;React.Fragment&gt;\n      &lt;ErrorBoundary onError={onComponentError}&gt;\n        {children ?? null}\n      &lt;&#x2F;ErrorBoundary&gt;\n      {isMounted ? (\n        &lt;ShadowPortal&gt;\n          &lt;CssReset &#x2F;&gt;\n          &lt;Base &#x2F;&gt;\n          &lt;ComponentStyles &#x2F;&gt;\n\n          {hasBuildError ? (\n            &lt;BuildError message={state.buildError!} &#x2F;&gt;\n          ) : hasRuntimeErrors ? (\n            &lt;Errors errors={state.errors} &#x2F;&gt;\n          ) : undefined}\n        &lt;&#x2F;ShadowPortal&gt;\n      ) : undefined}\n    &lt;&#x2F;React.Fragment&gt;\n  )\n}\n</code></pre><ul>\n<li>结论:  ❌ 到第 4 步打个断点发现能够顺利运行, 既然热更新的 xxx.hot-update.js 是最新的, 客户端收到消息后最顶层组件也触发了重新渲染, 那么问题出现在哪了 ?</li>\n</ul>\n<h3>3. nextjs 内部组件出了问题 ?</h3>\n<ul>\n<li>分析: 这个可能性主要由于 nextjs 在用户的组件上包裹了太多层父组件, 如果某个父组件出了问题也是能造成热更新失败</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; packages&#x2F;next&#x2F;next-server&#x2F;server&#x2F;render.tsx\n\nconst AppContainer = ({ children }: any) =&gt; (\n  &lt;RouterContext.Provider value={router}&gt;\n    &lt;AmpStateContext.Provider value={ampState}&gt;\n      &lt;HeadManagerContext.Provider\n        value={{\n          updateHead: (state) =&gt; {\n            head = state\n          },\n          updateScripts: (scripts) =&gt; {\n            scriptLoader = scripts\n          },\n          scripts: {},\n          mountedInstances: new Set(),\n        }}\n      &gt;\n        &lt;LoadableContext.Provider\n          value={(moduleName) =&gt; reactLoadableModules.push(moduleName)}\n        &gt;\n          {children}\n        &lt;&#x2F;LoadableContext.Provider&gt;\n      &lt;&#x2F;HeadManagerContext.Provider&gt;\n    &lt;&#x2F;AmpStateContext.Provider&gt;\n  &lt;&#x2F;RouterContext.Provider&gt;\n)\n</code></pre><p><img src=\"https://user-images.githubusercontent.com/23253540/131155297-f30b39aa-3424-43a7-b8a0-2a67c8868043.png\" alt>\n🐛 debug 问题比较重要的一点是分段排查, 就像网络了出了问题, 专业维修人员总会分段去检查, 直到排查到最近未通的线路</p>\n<p>这里我们把 nextjs 内部的热更新监听的代码给搬移到我们自己的组件中来, 测试我们自己的线路, 然后在 TYPE_REFFRESH 事件后进行一个强制渲染的操作, 看是否能热更新生效</p>\n<pre class=\"prettyprint\"><code>componentDidMount() {\n  if (process.env.NODE_ENV === &quot;development&quot;) {\n    const Bus = require(&quot;@next&#x2F;react-dev-overlay&#x2F;lib&#x2F;internal&#x2F;bus&quot;)\n\n    Bus.on((event: Record&lt;string, string&gt;) =&gt; {\n      if (event.type === Bus.TYPE_REFFRESH) {\n      \tthis.forceUpdate()\n      }\n    })\n  }\n}\n</code></pre><p>❌ 答案是还是未能热更新, 其实到这里需要 🤔 思考一下 <strong><em>热更新的本质</em></strong> ?</p>\n<ul>\n<li>当我们这个组件的子组件代码更新后, 父组件 forceUpdate 为什么没有导致页面重新渲染了</li>\n</ul>\n<p>当客户端收到的 xxx.hot-update.js 代码执行后, 内存里面缓存所有模块的 installedModules 对象如下就会把 key 值为 <a href=\"/user/components\">@components</a>/App 的值给更新了, 但是如果不在热更新的回调中重新 require 一次来取到最新赋的值, 其如果存在父组件等还是<strong><em>引用的是旧的值</em></strong></p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 一个简单的热替换的实现的例子\n\nfunction __enableHotModuleReplacement() {\n    if (module.hot) {\n        if (module.hot._acceptedDependencies[&#x27;[@components](&#x2F;user&#x2F;components)&#x2F;App&#x27;]) {\n            console.warn(&#x27;[${PKG_NAME}]: Hot updates have already been registered&#x27;)\n        } else {\n            module.hot.accept(&#x27;[@components](&#x2F;user&#x2F;components)&#x2F;App&#x27;, () =&gt; {\n                const _App = require(&#x27;[@components](&#x2F;user&#x2F;components)&#x2F;App&#x27;).default\n                if (_App) {\n                  ReactDOM.render(&lt;_App &#x2F;&gt;, document.getElementById(&#x27;root&#x27;))\n                } else {\n                  location.reload()\n                }\n            })\n            console.log(&#x27;[${PKG_NAME}]: Hot Update Registration Successful&#x27;)\n        }\n    }\n  }\n  \n__enableHotModuleReplacement()\n</code></pre><p>通过上面的例子的分析, 我们补丁代码需要下面的改动才能更新成功</p>\n<ul>\n<li>在更新订阅的回调中重新 require 来获取最新的引用值</li>\n<li>通过 setState 去更新渲染最新的子组件 Component</li>\n</ul>\n<pre class=\"prettyprint\"><code>componentDidMount() {\n  if (process.env.NODE_ENV === &quot;development&quot;) {\n    const Bus = require(&quot;@next&#x2F;react-dev-overlay&#x2F;lib&#x2F;internal&#x2F;bus&quot;)\n\n    Bus.on((event: Record&lt;string, string&gt;) =&gt; {\n      if (event.type === Bus.TYPE_REFFRESH) {\n      \tconst NewComponent = require(&#x27;views&#x27;).default\n        this.setState({ Component: NewComponent })\n      }\n    })\n  }\n}\n\nrender() {\n    const { Component } = this.state\n\n    return &lt;Component {...this.props}&#x2F;&gt;\n}\n</code></pre><p>到这里我们在自己的代码中打了一个补丁, 修复了热更新的能力, 不过我们还需要测试一下该组件的孙子组件修改后, 是否也能正常生效 ？</p>\n<p>❌ 答案是否定的, 孙子组件未能生效! 那么结论是 nextjs 内部组件没有出问题, 是谁把这个 installedModules 缓存给破坏了 ？</p>\n<h3>4. react-refresh-webpack-plugin 的问题 ?</h3>\n<ul>\n<li>分析: 当从 NewComponent 起点重新往下执行后, 其 import 的组件引用应该都是最新的才对, 是谁动了 installedModules 的缓存数据 ? 而 react-refresh 为了最小的局部更新, 会在构建时给每个文件的前后加了一些注册代码, 这部分小料如果逻辑不够缜密可能是原因</li>\n<li>结论: ❌ 把 react-refresh-webpack-plugin 升级到小版本最新, 发现并非解决, 该猜想某小版本 bug 大概率不成立</li>\n</ul>\n<p>那么我们把上面的代码补丁继续完善一下, 自己手动清除所有模块缓存解决仅存的问题</p>\n<pre class=\"prettyprint\"><code>componentDidMount() {\n  if (process.env.NODE_ENV === &quot;development&quot;) {\n    const Bus = require(&quot;@next&#x2F;react-dev-overlay&#x2F;lib&#x2F;internal&#x2F;bus&quot;)\n\n    Bus.on((event: Record&lt;string, string&gt;) =&gt; {\n      if (event.type === Bus.TYPE_REFFRESH) {\n      \tObject.keys(require.cache).forEach(key =&gt; {\n      \t  delete require.cache[key]\n       \t})\n      \tconst NewComponent = require(&#x27;views&#x27;).default\n        this.setState({ Component: NewComponent })\n      }\n    })\n  }\n}\n\nrender() {\n    const { Component } = this.state\n\n    return &lt;Component {...this.props}&#x2F;&gt;\n}\n</code></pre><p><img src=\"https://user-images.githubusercontent.com/23253540/131166454-5e6678b4-cd67-436a-951c-bd0e85dee484.png\" alt=\"image\">\n是的, 虽然我们此时还未找到真正的问题, 但是根据问题反映的种种现象使用一个粗糙的补丁给解决了。</p>\n<h3>5. 检查 next.config.js</h3>\n<blockquote>\n<p>到第 4 步, 本已经打算按现有的补丁结案, 不成想因为另一个小问题发现了热更新失败的真正原因</p>\n</blockquote>\n<p>在 next.config.js 中有一个 externals 的配置, 有过了解的同学应该知道配置了 externals 是需要到模版的 html 中手动引入带有 externals 配置包的 cdn js 文件</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; next.config.js\n\nif (!isServer) {\n  const e = {\n    react: &quot;React&quot;,\n    &quot;react-dom&quot;: &quot;ReactDOM&quot;\n  }\n  config.externals.unshift(e)\n}\n</code></pre><p>但是发现 nextjs 代码中尽然写死了 react, react-dom 作为 dll entry, 了解 dll 的同学应该知道, 它会把配置的入口前置构建一次, 且 autodll 插件会把它自动插入到模版 html 文件中\n<img src=\"https://user-images.githubusercontent.com/23253540/131168073-406987e4-6ed7-4e4f-80b2-3b8a5826ad18.png\" alt=\"image\"></p>\n<p>⚠️ 这不就一下有了两份 react, react-dom 了吗 ? 那么我们把 externals 相关的给去掉试试, 使得只有一份 react, react-dom 了?</p>\n<p>✅ 发现去掉补丁后, 热更新也能正常运行了, 问题解决 ～</p>\n<h2>小结</h2>\n<p>老项目虽然有些坑, 尽量要做到通过一些粗糙的补丁基本解决问题, 有些黑盒不可能花过多时间去研究。其次是找异同点, 比如 nextjs 项目, 最大的不同无异于配置文件 next.config.js 与包的版本, 这些关键地方需要重点去排查。</p>\n</div>",
      "title": "nextjs 项目热更新失败排查",
      "author": {
        "loginname": "xiaoxiaojx",
        "avatar_url": "https://avatars.githubusercontent.com/u/23253540?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 130,
      "country": "China"
    },
    {
      "id": "6144a796fe0c51d099aea7f4",
      "content": "<div class=\"markdown-text\"><p>简单明了，只有程序员可以领取的区块链空投 <a href=\"https://hosting.4everland.org/#/?invite=QQHILMG3\">https://hosting.4everland.org/#/?invite=QQHILMG3</a> 空投地址 登录使用 github 授权之后，new project,按照提示成功发布一个 vue.js 项目，就可以领取 1000 个代币和 30G 的云空间。代币的价值未来可期</p>\n</div>",
      "title": "没想到，只有程序员才能领取的区块链福利",
      "author": {
        "loginname": "wocaatm",
        "avatar_url": "https://avatars.githubusercontent.com/u/11764069?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 131,
      "country": "USA"
    },
    {
      "id": "612d9cbdfe0c512e7eae8036",
      "content": "<div class=\"markdown-text\"><p>BoardOS是基于白板的在线实时协作系统，拥有多种扩展应用和插件，适用于团队协作、线上教学、在线会议、头脑风暴、在线设计等众多场景，一切为了高效!</p>\n<h2>功能介绍</h2>\n<h3>实时同步</h3>\n<p><code>团队成员的鼠标、视角以及所有的操作都会实时同步给对方，就象大家坐在一起沟通</code></p>\n<h3>沟通协作</h3>\n<p><code>音视频、批注、文字聊天、举手、庆祝、回应、印章、指针聊天等多种沟通方式，选择你喜欢的，自由表达你的情绪，愉快的协作</code></p>\n<h3>扩展应用与插件</h3>\n<p><code>丰富的扩展应用与插件方便实现各种需求，可以自由的安装、卸载以及调整其在程序坞中的位置，甚至可以开发你自己的应用与插件，有无限扩展的可能</code></p>\n<h2>预览</h2>\n<p><img src=\"//static.cnodejs.org/FrHr1gsIFYhczXkpq0f_whkRfTmf\" alt=\"432cbfdb81064d6e8268f528b288841c.png\"></p>\n<h2>网址</h2>\n<p><a href=\"https://boardos.online\">https://boardos.online</a></p>\n</div>",
      "title": "推荐一款免费的远程实时协作白板：BoardOS",
      "author": {
        "loginname": "superliwei",
        "avatar_url": "https://avatars.githubusercontent.com/u/709088?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 132,
      "country": "China"
    },
    {
      "id": "53cb4bb2c9507b40443238cb",
      "content": "<div class=\"markdown-text\"><p>编写这个服务的初衷是给我女朋友写论文查资料用的。写完后觉得可以开源出来，集结大家的力量继续完善，并且每个人都可以部署到自己的vps上给自己或朋友用，然后就可以有无数的免翻墙使用的谷歌服务造福大众了。</p>\n<p>这是我自己搭建的服务： <a href=\"http://gso.mlongbo.com\">http://gso.mlongbo.com</a>    或  <a href=\"http://gusou.in\">http://gusou.in</a> （不要大量扩散哦，偷偷地告诉身边的朋友就好了~）</p>\n<p>源代码： <a href=\"https://github.com/lenbo-ma/gso.git\">https://github.com/lenbo-ma/gso.git</a></p>\n<p>本人为前端菜鸟，对该项目感兴趣的大神可以将css重构下～</p>\n<p>以后可以考虑增加在线代理功能，代理搜索结果中一些被qiang的技术网站。</p>\n<p>有兴趣的同学也可以 <a href=\"http://jq.qq.com/?_wv=1027&amp;k=PaD5gT\">加入QQ群: 338257594</a> 一起交流~</p>\n</div>",
      "title": "gso，使用nodejs编写的谷歌搜索代理服务(免翻墙)，可以自由部署在自己的国外vps上",
      "author": {
        "loginname": "lenbo",
        "avatar_url": "https://avatars1.githubusercontent.com/u/2613341?v=3&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 133,
      "country": "USA"
    },
    {
      "id": "6142ee9ffe0c518a08aea52c",
      "content": "<div class=\"markdown-text\"><p>关注<a href=\"https://github.com/simon9124/my_demos/blob/master/README.md\">前端小讴</a>，阅读更多原创技术文章</p>\n<h1>期约</h1>\n<ul>\n<li>期约是对尚不存在结果的一个替身，是一种异步程序执行的机制</li>\n</ul>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89/%E7%AC%AC11%E7%AB%A0%20%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/11.2.%E6%9C%9F%E7%BA%A6.js\">相关代码→</a></p>\n<h2>Promises/A+规范</h2>\n<ul>\n<li>ES6 新增了<code>Promise</code>类型，其成为主导性的异步编程机制，所有现代浏览器都支持期约</li>\n</ul>\n<h2>期约基础</h2>\n<ul>\n<li><code>Promise</code>类型通过<code>new</code>操作符实例化，需传入<strong>执行器（executor）函数</strong>作为参数</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; let p = new Promise() &#x2F;&#x2F; TypeError: Promise resolver undefined is not a function，必须提供执行器函数作为参数\nlet p = new Promise(() =&gt; {})\nsetTimeout(console.log, 0, p) &#x2F;&#x2F; Promise { &lt;pending&gt; }\n</code></pre><h3>期约状态机</h3>\n<ul>\n<li>期约是一个有状态的对象：\n<ul>\n<li>待定<code>pending</code>表示<strong>尚未开始或正在执行</strong>。最初始状态，可以落定为兑现或拒绝状态，<strong>兑现后不可逆</strong></li>\n<li>兑现<code>fullfilled</code>（或解决<code>resolved</code>）表示成功完成</li>\n<li>拒绝<code>rejected</code>表示没有成功完成</li>\n</ul>\n</li>\n<li>期约的状态是<strong>私有</strong>的，其将异步行为<strong>封装</strong>起来<strong>隔离</strong>外部代码，<strong>不能</strong>被外部 JS 代码读取或修改</li>\n</ul>\n<h3>解决值、拒绝理由及期约用例</h3>\n<ul>\n<li>期约的状态机可以提供很有用的信息，假设其向服务器发送一个 HTTP 请求：\n<ul>\n<li>返回 200-299 范围内的状态码,可让期约状态变为“兑现”，期约<strong>内部</strong>收到<strong>私有</strong>的<code>JSON</code>字符串，默认值为 undefined</li>\n<li>返回不在 200-299 范围内的状态码，会把期约状态切换为“拒绝”，期约<strong>内部</strong>收到<strong>私有</strong>的<code>Error</code>对象（包含错误消息），默认值为 undefined</li>\n</ul>\n</li>\n</ul>\n<h3>通过执行函数控制期约状态</h3>\n<ul>\n<li>期约的状态是<strong>私有</strong>的，只能在<strong>执行器函数</strong>中完成<strong>内部操作</strong></li>\n<li>执行器函数负责<strong>初始化期约异步行为</strong>和<strong>控制状态转换</strong>：\n<ul>\n<li>通过<code>resolve()</code>和<code>reject()</code>两个函数参数控制状态转换</li>\n<li><code>resolve()</code>会把状态切换为<strong>兑换</strong>，<code>reject()</code>会把状态切换为<strong>拒绝</strong>并<strong>抛出错误</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p1 = new Promise((resolve, reject) =&gt; resolve())\nsetTimeout(console.log, 0, p1) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}\n\nlet p2 = new Promise((resolve, reject) =&gt; reject())\nsetTimeout(console.log, 0, p2) &#x2F;&#x2F; Promise {&lt;rejected&gt;: undefined}\n&#x2F;&#x2F; Uncaught (in promise)\n</code></pre><ul>\n<li>执行器函数是期约的初始化程序，其是<strong>同步</strong>执行的</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>new Promise(() =&gt; setTimeout(console.log, 0, &#x27;executor&#x27;))\nsetTimeout(console.log, 0, &#x27;promise initialized&#x27;)\n&#x2F;* \n  &#x27;executor&#x27;，先打印\n  &#x27;promise initialized&#x27;，后打印\n*&#x2F;\n</code></pre><ul>\n<li>可添加<code>setTimeout</code>推迟执行器函数的切换状态</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p3 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 1000)\n})\nsetTimeout(console.log, 0, p3) &#x2F;&#x2F; Promise { &lt;pending&gt; }，打印实例p3时，还不会执行内部回调\n</code></pre><ul>\n<li><code>resolve()</code>和<code>reject()</code>无论哪个被调用，状态转换都<strong>不可撤销</strong>，继续修改状态会<strong>静默失败</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p4 = new Promise((resolve, reject) =&gt; {\n  resolve()\n  reject() &#x2F;&#x2F; 静默失败\n})\nsetTimeout(console.log, 0, p4) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}\n</code></pre><ul>\n<li>为避免期约卡在待定状态，可<strong>添加定时退出</strong>功能，设置若干时长后无论如何都拒绝期约的回调</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p5 = new Promise((resolve, reject) =&gt; {\n  setTimeout(reject, 10000) &#x2F;&#x2F; 10秒后调用reject()\n})\nsetTimeout(console.log, 0, p5) &#x2F;&#x2F; Promise { &lt;pending&gt; }，10秒内，不调用resolve()\nsetTimeout(console.log, 11000, p5) &#x2F;&#x2F; Promise {&lt;rejected&gt;: undefined}，10秒外，调用reject()\n&#x2F;&#x2F; Uncaught (in promise)\n</code></pre><h3>Promise.resolve()</h3>\n<ul>\n<li>调用<code>Promise.resolve()</code>方法，可以<strong>实例化</strong>一个<strong>解决的</strong>期约</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p6 = new Promise((resolve, reject) =&gt; {\n  resolve()\n})\nconsole.log(p6) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}\nlet p7 = Promise.resolve()\nconsole.log(p7) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}\n</code></pre><ul>\n<li>传给<code>Promise.resolve()</code>的<strong>第一个参数</strong>为解决的期约的值</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>setTimeout(console.log, 0, Promise.resolve()) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}\nsetTimeout(console.log, 0, Promise.resolve(3)) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: 3}\nsetTimeout(console.log, 0, Promise.resolve(4, 5, 6)) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: 4}，只取首个参数\n</code></pre><ul>\n<li><code>Promise.resolve()</code>是一个<strong>幂等</strong>方法，如果传入的<strong>参数是一个期约</strong>，其行为类似于一个<strong>空包装</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p8 = Promise.resolve(7)\nsetTimeout(console.log, 0, Promise.resolve(p8)) &#x2F;&#x2F; Promise { 7 }\nsetTimeout(console.log, 0, p8 === Promise.resolve(p8)) &#x2F;&#x2F; true\nsetTimeout(console.log, 0, p8 === Promise.resolve(Promise.resolve(p8))) &#x2F;&#x2F; true\n</code></pre><ul>\n<li>该幂等性会<strong>保留</strong>传入期约的<strong>状态</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p9 = new Promise(() =&gt; {}) &#x2F;&#x2F; 待定状态\nsetTimeout(console.log, 0, p9) &#x2F;&#x2F; Promise { &lt;pending&gt; }\nsetTimeout(console.log, 0, Promise.resolve(p9)) &#x2F;&#x2F; Promise { &lt;pending&gt; }\nsetTimeout(console.log, 0, Promise.resolve(Promise.resolve(p9))) &#x2F;&#x2F; Promise { &lt;pending&gt; }\n</code></pre><ul>\n<li>该方法能够包装<strong>任何非期约值</strong>（包括错误对象），并将其<strong>转换为解决的期约</strong>，因此可能导致不符合预期的行为</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p10 = Promise.resolve(new Error(&#x27;foo&#x27;))\nsetTimeout(console.log, 0, p10) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: Error: foo\n</code></pre><h3>Promise.reject()</h3>\n<ul>\n<li>与<code>Promise.resolve()</code>相似，<code>Promise.reject()</code>可以<strong>实例化</strong>一个<strong>拒绝的</strong>期约并<strong>抛出一个异步错误</strong>\n<ul>\n<li>该错误<strong>不能</strong>通过<code>try/catch</code>捕获，只能通过拒绝处理程序捕获</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p11 = new Promise((resolve, reject) =&gt; {\n  reject()\n})\nconsole.log(p11) &#x2F;&#x2F; Promise {&lt;rejected&gt;: undefined}\n&#x2F;&#x2F; Uncaught (in promise)\n\nlet p12 = Promise.reject()\nconsole.log(p12) &#x2F;&#x2F; Promise {&lt;rejected&gt;: undefined}\n&#x2F;&#x2F; Uncaught (in promise)\n</code></pre><ul>\n<li>传给<code>Promise.resolve()</code>的<strong>第一个参数</strong>为拒绝的期约的理由，该参数也会<strong>传给后续的拒绝处理程序</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p13 = Promise.reject(3)\nsetTimeout(console.log, 0, p13) &#x2F;&#x2F; Promise { &lt;rejected&gt; 3 }\np13.then(null, (err) =&gt; setTimeout(console.log, 0, err)) &#x2F;&#x2F; 3，参数传给后续拒绝处理程序\n</code></pre><ul>\n<li><code>Promise.reject()</code>不是幂等的（与<code>Promise.resolve()</code>不同），如果参数为期约对象，则该期约会成为返回的拒绝理由</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>setTimeout(console.log, 0, Promise.reject(Promise.resolve())) &#x2F;&#x2F; Promise {&lt;rejected&gt;: Promise}\n</code></pre><h3>同步/异步执行的二元性</h3>\n<ul>\n<li>由于期约的<strong>异步特性</strong>，其虽然是同步对象（可在同步执行模式中使用），但也是异步执行模式的媒介\n<ul>\n<li><strong>同步线程的代码无法捕获拒绝的期约</strong>，拒绝期约的错误会通过<strong>浏览器异步消息队列</strong>来处理</li>\n<li>代码一旦开始以异步模式执行，唯一与之交互的方式就是<strong>使用异步结构</strong>，即期约</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>try {\n  throw new Error(&#x27;foo&#x27;) &#x2F;&#x2F; 同步线程抛出错误\n} catch (error) {\n  console.log(error + &#x27;1&#x27;) &#x2F;&#x2F; Error: foo1，同步线程捕获错误\n}\n\ntry {\n  Promise.reject(&#x27;bar&#x27;) &#x2F;&#x2F; 同步线程使用期约\n} catch (error) {\n  console.log(error + &#x27;2&#x27;) &#x2F;&#x2F; 同步线程捕获不到拒绝的期约\n}\n&#x2F;&#x2F; Promise {&lt;rejected&gt;: &quot;bar&quot;}，浏览器异步消息队列捕获到拒绝的期约\n&#x2F;&#x2F; Uncaught (in promise) bar\n</code></pre><h2>期约的实例方法</h2>\n<ul>\n<li>这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果</li>\n</ul>\n<h3>实现 Thenable 接口</h3>\n<ul>\n<li>ECMAScript 暴露的异步结构中，任何对象都有一个<code>then()</code>方法，该方法被认为实现了<code>thenable</code>接口</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>class MyThenable {\n  &#x2F;&#x2F; 实现Thenable接口的最简单的类\n  then() {}\n}\n</code></pre><h3>Promise.prototype.then()</h3>\n<ul>\n<li><code>Promise.prototype.then()</code>为期约<strong>添加处理程序</strong>，接收<strong>2 个可选的处理程序参数</strong><code>onResolved</code>和<code>onRejected</code>\n<ul>\n<li><code>onResolved</code>会在期约进入<strong>兑现</strong>状态时执行</li>\n<li><code>onRejected</code>会在期约进入<strong>拒绝</strong>状态时执行</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function onResolved(id) {\n  setTimeout(console.log, 0, id, &#x27;resolved&#x27;)\n}\nfunction onRejected(id) {\n  setTimeout(console.log, 0, id, &#x27;rejected&#x27;)\n}\nlet p14 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 3000)\n})\nlet p15 = new Promise((resolve, reject) =&gt; {\n  setTimeout(reject, 3000)\n})\n\np14.then(\n  () =&gt; {\n    onResolved(&#x27;p14&#x27;) &#x2F;&#x2F; &#x27;p14 resolved&#x27;（3秒后）\n  },\n  () =&gt; {\n    onRejected(&#x27;p14&#x27;)\n  }\n)\np15.then(\n  () =&gt; {\n    onResolved(&#x27;p15&#x27;)\n  },\n  () =&gt; {\n    onRejected(&#x27;p15&#x27;) &#x2F;&#x2F; &#x27;p15 rejected&#x27;（3秒后）\n  }\n)\n</code></pre><ul>\n<li>传给<code>then()</code>的任何非函数类型的参数都会被静默忽略（不推荐），如果只提供<code>onResolved</code>或<code>onRejected</code>，一般在另一个参数位置上传入<code>null</code>或<code>undefined</code></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>p14.then(&#x27;gobbeltygook&#x27;) &#x2F;&#x2F; 参数不是对象，静默忽略\np14.then(() =&gt; onResolved(&#x27;p14&#x27;)) &#x2F;&#x2F; &#x27;p14 resolved&#x27;（3秒后），不传onRejected\np15.then(null, () =&gt; onRejected(&#x27;p15&#x27;)) &#x2F;&#x2F; &#x27;p15 rejected&#x27;（3秒后），不传onResolved\n</code></pre><ul>\n<li><code>Promise.prototype.then()</code>返回一个<strong>新的期约实例</strong>，该实例基于<code>onResolved</code>处理程序（<code>Promise.resolved()</code>包装）的返回值构建\n<ul>\n<li>若<strong>没有提供这个处理程序</strong>，则包装<strong>上一个</strong>期约解决之后的值（父期约的传递）</li>\n<li>若提供了处理程序，但<strong>没有显示的返回语句</strong>，则包装默认的返回值 <code>undefined</code></li>\n<li>若提供了处理程序，且<strong>有显示的返回值</strong>，则包装<strong>这个值</strong></li>\n<li>若提供了处理程序，且<strong>返回期约</strong>，则包装<strong>返回的期约</strong></li>\n<li>若提供了处理程序，且<strong>抛出异常</strong>，则包装<strong>拒绝的期约</strong></li>\n<li>若提供了处理程序，且<strong>返回错误值</strong>，则把<strong>错误对象</strong>包装在一个<strong>解决的期约</strong>中（而非拒绝的期约）</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p16 = Promise.resolve(&#x27;foo&#x27;)\n\nlet result1 = p16.then() &#x2F;&#x2F; 没有提供处理程序\nsetTimeout(console.log, 0, result1) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;foo&#x27;}，包装上一个期约解决后的值\n\nlet result2 = p16.then(() =&gt; undefined) &#x2F;&#x2F; 处理程序没有显示的返回语句\nlet result3 = p16.then(() =&gt; {}) &#x2F;&#x2F; 处理程序没有显示的返回语句\nlet result4 = p16.then(() =&gt; Promise.resolve()) &#x2F;&#x2F; 处理程序没有显示的返回语句\nsetTimeout(console.log, 0, result2) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}，包装默认返回值undefined\nsetTimeout(console.log, 0, result3) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}，包装默认返回值undefined\nsetTimeout(console.log, 0, result4) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}，包装默认返回值undefined\n\nlet result5 = p16.then(() =&gt; &#x27;bar&#x27;) &#x2F;&#x2F; 处理程序有显示的返回值\nlet result6 = p16.then(() =&gt; Promise.resolve(&#x27;bar&#x27;)) &#x2F;&#x2F; 处理程序有显示的返回值\nsetTimeout(console.log, 0, result5) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;bar&#x27;}，包装这个值\nsetTimeout(console.log, 0, result6) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;bar&#x27;}，包装这个值\n\nlet result7 = p16.then(() =&gt; new Promise(() =&gt; {})) &#x2F;&#x2F; 处理程序返回一个待定的期约\nlet result8 = p16.then(() =&gt; Promise.reject(&#x27;bar&#x27;)) &#x2F;&#x2F; 处理程序返回一个拒绝的期约\n&#x2F;&#x2F; Uncaught (in promise) bar\nsetTimeout(console.log, 0, result7) &#x2F;&#x2F; Promise {&lt;pending&gt;}，包装返回的期约\nsetTimeout(console.log, 0, result8) &#x2F;&#x2F; Promise {&lt;rejected&gt;: &#x27;bar&#x27;}，包装返回的期约\n\nlet result9 = p16.then(() =&gt; {\n  throw &#x27;baz&#x27; &#x2F;&#x2F; 处理程序抛出异常\n})\n&#x2F;&#x2F; Uncaught (in promise) baz\nsetTimeout(console.log, 0, result9) &#x2F;&#x2F; Promise {&lt;rejected&gt;: &#x27;baz&#x27;}，包装拒绝的期约\n\nlet result10 = p16.then(() =&gt; Error(&#x27;qux&#x27;)) &#x2F;&#x2F; 处理程序返回错误值\nsetTimeout(console.log, 0, result10) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: Error: qux}，把错误对象包装在一个解决的期约中\n</code></pre><ul>\n<li>与<code>onResolved</code>相同，<code>onRejected</code>处理程序作为参数时，其返回的值也被<code>Promise.resolve()</code>包装，返回<strong>新的期约实例</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p17 = Promise.reject(&#x27;foo&#x27;)\n\nlet result11 = p17.then() &#x2F;&#x2F; 没有提供处理程序\n&#x2F;&#x2F; Uncaught (in promise) foo\nsetTimeout(console.log, 0, result11) &#x2F;&#x2F; Promise {&lt;rejected&gt;: &#x27;foo&#x27;}，包装上一个期约解决后的值\n\nlet result12 = p17.then(null, () =&gt; undefined) &#x2F;&#x2F; 处理程序没有显示的返回语句\nlet result13 = p17.then(null, () =&gt; {}) &#x2F;&#x2F; 处理程序没有显示的返回语句\nlet result14 = p17.then(null, () =&gt; Promise.resolve()) &#x2F;&#x2F; 处理程序没有显示的返回语句\nsetTimeout(console.log, 0, result12) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}，包装默认返回值undefined\nsetTimeout(console.log, 0, result13) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}，包装默认返回值undefined\nsetTimeout(console.log, 0, result14) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: undefined}，包装默认返回值undefined\n\nlet result15 = p17.then(null, () =&gt; &#x27;bar&#x27;) &#x2F;&#x2F; 处理程序有显示的返回值\nlet result16 = p17.then(null, () =&gt; Promise.resolve(&#x27;bar&#x27;)) &#x2F;&#x2F; 处理程序有显示的返回值\nsetTimeout(console.log, 0, result15) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;bar&#x27;}，包装这个值\nsetTimeout(console.log, 0, result16) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;bar&#x27;}，包装这个值\n\nlet result17 = p17.then(null, () =&gt; new Promise(() =&gt; {})) &#x2F;&#x2F; 处理程序返回一个待定的期约\nlet result18 = p17.then(null, () =&gt; Promise.reject(&#x27;bar&#x27;)) &#x2F;&#x2F; 处理程序返回一个拒绝的期约\n&#x2F;&#x2F; Uncaught (in promise) bar\nsetTimeout(console.log, 0, result17) &#x2F;&#x2F; Promise {&lt;pending&gt;}，包装返回的期约\nsetTimeout(console.log, 0, result18) &#x2F;&#x2F; Promise {&lt;rejected&gt;: &#x27;bar&#x27;}，包装返回的期约\n\nlet result19 = p17.then(null, () =&gt; {\n  throw &#x27;baz&#x27; &#x2F;&#x2F; 处理程序抛出异常\n})\n&#x2F;&#x2F; Uncaught (in promise) baz\nsetTimeout(console.log, 0, result19) &#x2F;&#x2F; Promise {&lt;rejected&gt;: &#x27;baz&#x27;}，包装拒绝的期约\n\nlet result20 = p17.then(null, () =&gt; Error(&#x27;qux&#x27;)) &#x2F;&#x2F; 处理程序返回错误值\nsetTimeout(console.log, 0, result20) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: Error: qux}，把错误对象包装在一个解决的期约中\n</code></pre><h3>Promise.prototype.catch()</h3>\n<ul>\n<li><code>Promise.prototype.catch()</code>为期约<strong>添加拒绝处理程序</strong>，接收<strong>1 个可选的处理程序参数</strong><code>onRejected</code>\n<ul>\n<li>该方法相当于调用<code>Promise.prototypr.then(null, onRejected)</code></li>\n<li>该方法方法也返回<strong>新的期约实例</strong>，其行为与<code>Promise.prototype.then()</code>的<code>onRejeted</code>处理程序一样</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p18 = Promise.reject()\nlet onRejected2 = function () {\n  setTimeout(console.log, 0, &#x27;reject&#x27;)\n}\np18.then(null, onRejected2) &#x2F;&#x2F; &#x27;reject&#x27;\np18.catch(onRejected2) &#x2F;&#x2F; &#x27;reject&#x27;，两种添加拒绝处理程序的方式是一样的\n</code></pre><h3>Promise.prototype.finally()</h3>\n<ul>\n<li><code>Promise.prototype.finally()</code>为期约<strong>添加 onFinally 处理程序</strong>，接收<strong>1 个可选的处理程序参数</strong><code>onFinally</code>\n<ul>\n<li>无论期约转换为<strong>解决</strong>还是<strong>拒绝</strong>状态，<code>onFinally</code>处理程序<strong>都会执行</strong>，但其无法知道期约的状态</li>\n<li>该方法主要用于<strong>添加清理代码</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p19 = Promise.resolve()\nlet p20 = Promise.reject()\nlet onFinally = function () {\n  setTimeout(console.log, 0, &#x27;Finally&#x27;)\n}\np19.finally(onFinally) &#x2F;&#x2F; &#x27;Finally&#x27;\np20.finally(onFinally) &#x2F;&#x2F; &#x27;Finally&#x27;\n</code></pre><ul>\n<li><code>Promise.prototype.finally()</code>返回一个<strong>新的期约实例</strong>，其以下情况均包装<strong>父期约的传递</strong>\n<ul>\n<li>未提供处理程序</li>\n<li>提供了处理程序，但没有显示的返回语句</li>\n<li>提供了处理程序，且有显示的返回值</li>\n<li>处理程序返回一个解决的期约</li>\n<li>处理程序返回错误值</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p21 = Promise.resolve(&#x27;foo&#x27;)\n\nlet result23 = p21.finally() &#x2F;&#x2F; 未提供处理程序\nlet result24 = p21.finally(() =&gt; undefined) &#x2F;&#x2F; 提供了处理程序，但没有显示的返回语句\nlet result25 = p21.finally(() =&gt; {}) &#x2F;&#x2F; 提供了处理程序，但没有显示的返回语句\nlet result26 = p21.finally(() =&gt; Promise.resolve()) &#x2F;&#x2F; 提供了处理程序，但没有显示的返回语句\nlet result27 = p21.finally(() =&gt; &#x27;bar&#x27;) &#x2F;&#x2F; 提供了处理程序，且有显示的返回值\nlet result28 = p21.finally(() =&gt; Promise.resolve(&#x27;bar&#x27;)) &#x2F;&#x2F; 处理程序返回一个解决的期约\nlet result29 = p21.finally(() =&gt; Error(&#x27;qux&#x27;)) &#x2F;&#x2F; 处理程序返回错误值\nsetTimeout(console.log, 0, result23) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;foo&#x27;}，包装父期约的传递\nsetTimeout(console.log, 0, result24) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;foo&#x27;}，包装父期约的传递\nsetTimeout(console.log, 0, result25) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;foo&#x27;}，包装父期约的传递\nsetTimeout(console.log, 0, result26) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;foo&#x27;}，包装父期约的传递\nsetTimeout(console.log, 0, result27) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;foo&#x27;}，包装父期约的传递\nsetTimeout(console.log, 0, result28) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;foo&#x27;}，包装父期约的传递\nsetTimeout(console.log, 0, result29) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;foo&#x27;}，包装父期约的传递\n</code></pre><ul>\n<li>若<code>onFinally</code>处理程序返回<strong>待定或拒绝的期约</strong>或<strong>抛出错误</strong>，则返回值包装<strong>相应的期约</strong>（抛出错误包装拒绝的期约）</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let result30 = p21.finally(() =&gt; new Promise(() =&gt; {})) &#x2F;&#x2F; 处理程序返回一个待定的期约\nlet result31 = p21.finally(() =&gt; Promise.reject()) &#x2F;&#x2F; 处理程序返回一个拒绝的期约\n&#x2F;&#x2F; Uncaught (in promise) undefined\nlet result32 = p21.finally(() =&gt; {\n  throw &#x27;baz&#x27; &#x2F;&#x2F; 处理程序抛出错误\n})\n&#x2F;&#x2F; Uncaught (in promise) baz\nsetTimeout(console.log, 0, result30) &#x2F;&#x2F; Promise {&lt;pending&gt;}，返回相应的期约\nsetTimeout(console.log, 0, result31) &#x2F;&#x2F; Promise {&lt;rejected&gt;: undefined}，返回相应的期约\nsetTimeout(console.log, 0, result32) &#x2F;&#x2F; Promise {&lt;rejected&gt;: &#x27;baz&#x27;}，返回相应的期约\n</code></pre><ul>\n<li><code>onFinally</code>处理程序返回<strong>待定的期约解决后</strong>，新期约实例仍后传初始的期约</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p22 = Promise.resolve(&#x27;foo&#x27;)\nlet p23 = p22.finally(\n  () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(&#x27;bar&#x27;), 100)) &#x2F;&#x2F; 处理程序返回一个待定的期约（100毫秒后解决）\n)\nsetTimeout(console.log, 0, p23) &#x2F;&#x2F; Promise {&lt;pending&gt;}，返回相应的期约\nsetTimeout(() =&gt; setTimeout(console.log, 0, p23), 200) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &quot;foo&quot;}，（200毫秒后）待定的期约已解决\n</code></pre><h3>非重入期约方法</h3>\n<ul>\n<li>期约进入<strong>落定（解决/拒绝）<strong>状态时，与该状态相关的</strong>处理程序不会立即执行</strong>，处理程序后的<strong>同步代码</strong>会在其之前<strong>先执行</strong>，该特性称为<strong>非重入</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p24 = Promise.resolve() &#x2F;&#x2F; 解决的期约，已落定\np24.then(() =&gt; console.log(&#x27;onResolved handler&#x27;)) &#x2F;&#x2F; 与期约状态相关的onResolved处理程序\nconsole.log(&#x27;then() returns&#x27;) &#x2F;&#x2F; 处理程序之后的同步代码\n&#x2F;* \n  &#x27;then() returns&#x27;，处理程序之后的同步代码先执行\n  &#x27;onResolved handler&#x27;\n*&#x2F;\n</code></pre><ul>\n<li>即使期约在<strong>处理程序之后</strong>才<strong>改变状态（解决/拒绝）</strong>，处理程序仍表现<strong>非重入</strong>特性</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let synchronousResolve &#x2F;&#x2F; 全局方法：期约状态状态\nlet p25 = new Promise((resolve) =&gt; {\n  synchronousResolve = function () {\n    console.log(&#x27;1: invoking resolve()&#x27;)\n    resolve() &#x2F;&#x2F; 期约状态改变\n    console.log(&#x27;2: resolve() returns&#x27;)\n  }\n})\np25.then(() =&gt; console.log(&#x27;4: then() handler executes&#x27;)) &#x2F;&#x2F; 与期约状态相关的onResolved处理程序\nsynchronousResolve() &#x2F;&#x2F; 处理程序之后的同步代码：期约状态改变\nconsole.log(&#x27;3: synchronousResolve() returns&#x27;) &#x2F;&#x2F; 处理程序之后的同步代码\n&#x2F;* \n  &#x27;1: invoking resolve()&#x27;\n  &#x27;2: resolve() returns&#x27;\n  &#x27;3: synchronousResolve() returns&#x27;\n  &#x27;4: then() handler executes&#x27;\n*&#x2F;\n</code></pre><ul>\n<li>非重入特性适用于<code>onResolved</code>、<code>onRejected</code>、<code>catch()</code>、<code>finally()</code>处理程序</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p26 = Promise.resolve()\np26.then(() =&gt; console.log(&#x27;p26.then() onResolved&#x27;))\nconsole.log(&#x27;p26.then() returns&#x27;)\n\nlet p27 = Promise.reject()\np27.then(null, () =&gt; console.log(&#x27;p27.then() onRejected&#x27;))\nconsole.log(&#x27;p27.then() returns&#x27;)\n\nlet p28 = Promise.reject()\np28.catch(() =&gt; console.log(&#x27;p28.catch() onRejected&#x27;))\nconsole.log(&#x27;p28.catch() returns&#x27;)\n\nlet p29 = Promise.resolve()\np26.finally(() =&gt; console.log(&#x27;p29.finally() onFinally&#x27;))\nconsole.log(&#x27;p29.finally() returns&#x27;)\n&#x2F;* \n  &#x27;p26.then() returns&#x27;\n  &#x27;p27.then() returns&#x27;\n  &#x27;p28.catch() returns&#x27;\n  &#x27;p29.finally() returns&#x27;\n  &#x27;p26.then() onResolved&#x27;\n  &#x27;p27.then() onRejected&#x27;\n  &#x27;p28.catch() onRejected&#x27;\n  &#x27;p29.finally() onFinally&#x27;\n*&#x2F;\n</code></pre><h3>邻近处理程序的执行顺序</h3>\n<ul>\n<li>若期约添加了<strong>多个处理程序</strong>，当期约状态变化时，处理程序按<strong>添加顺序</strong>依次执行\n<ul>\n<li><code>then()</code>、<code>catch()</code>、<code>finally()</code>添加的处理程序均如此</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p30 = Promise.resolve()\nlet p31 = Promise.reject()\n\np30.then(() =&gt; setTimeout(console.log, 0, 1))\np30.then(() =&gt; setTimeout(console.log, 0, 2))\n\np31.then(null, () =&gt; setTimeout(console.log, 0, 3))\np31.then(null, () =&gt; setTimeout(console.log, 0, 4))\n\np31.catch(() =&gt; setTimeout(console.log, 0, 5))\np31.catch(() =&gt; setTimeout(console.log, 0, 6))\n\np30.finally(() =&gt; setTimeout(console.log, 0, 7))\np30.finally(() =&gt; setTimeout(console.log, 0, 8))\n&#x2F;* \n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n*&#x2F;\n</code></pre><h3>传递解决值和拒绝理由</h3>\n<ul>\n<li>期约进入<strong>落定（解决/拒绝）<strong>状态后，会给处理程序提供</strong>解决值（兑现）<strong>或</strong>拒绝理由（拒绝）</strong>\n<ul>\n<li>在<strong>执行函数</strong>中，解决值和拒绝理由分别作为<code>resolve()</code>和<code>reject()</code>的<strong>首个参数</strong>，传给<code>onResolved</code>和<code>onRejected</code>处理程序（作为其<strong>唯一参数</strong>）</li>\n<li>在<code>Promise.resolve()</code>和<code>Promise.reject()</code>被调用时，接收到的解决值和拒绝理由同样向后传递给处理程序（作为其<strong>唯一参数</strong>）</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p32 = new Promise((resolve, reject) =&gt; resolve(&#x27;foo&#x27;)) &#x2F;&#x2F; 执行函数中\np32.then((value) =&gt; console.log(value)) &#x2F;&#x2F; &#x27;foo&#x27;\nlet p33 = new Promise((resolve, reject) =&gt; reject(&#x27;bar&#x27;)) &#x2F;&#x2F; 执行函数中\np33.catch((reason) =&gt; console.log(reason)) &#x2F;&#x2F; &#x27;bar&#x27;\n\nlet p34 = Promise.resolve(&#x27;foo&#x27;) &#x2F;&#x2F; Promise.resolve()中\np34.then((value) =&gt; console.log(value)) &#x2F;&#x2F; &#x27;foo&#x27;\nlet p35 = Promise.reject(&#x27;bar&#x27;) &#x2F;&#x2F; Promise.reject()中\np35.catch((reason) =&gt; console.log(reason)) &#x2F;&#x2F; &#x27;bar&#x27;\n</code></pre><h3>拒绝期约与拒绝错误处理</h3>\n<ul>\n<li>在期约的<strong>执行函数</strong>或<strong>处理程序</strong>中抛出错误会导致拒绝，<strong>错误对象</strong>成为<strong>拒绝理由</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p36 = new Promise((resolve, reject) =&gt; reject(Error(&#x27;foo&#x27;))) &#x2F;&#x2F; 在执行函数中抛出错误\nlet p37 = new Promise((resolve, reject) =&gt; {\n  throw Error(&#x27;foo&#x27;) &#x2F;&#x2F; 在执行函数中抛出错误\n})\nlet p38 = Promise.resolve().then(() =&gt; {\n  throw Error(&#x27;foo&#x27;) &#x2F;&#x2F; 在处理程序中抛出错误\n})\nlet p39 = Promise.reject(Error(&#x27;foo&#x27;)) &#x2F;&#x2F; 在拒绝的期约中抛出错误\nsetTimeout(console.log, 0, p36) &#x2F;&#x2F; Promise {&lt;rejected&gt;: Error: foo\nsetTimeout(console.log, 0, p37) &#x2F;&#x2F; Promise {&lt;rejected&gt;: Error: foo\nsetTimeout(console.log, 0, p38) &#x2F;&#x2F; Promise {&lt;rejected&gt;: Error: foo\nsetTimeout(console.log, 0, p39) &#x2F;&#x2F; Promise {&lt;rejected&gt;: Error: foo\n</code></pre><ul>\n<li>可以以<strong>任何理由</strong>拒绝，包括<code>undefined</code>，但最好<strong>统一使用错误对象</strong>，错误对象可以让浏览器捕获其中的<strong>栈追踪信息</strong></li>\n<li>如上述拒绝期约，会在浏览器抛出 4 个未捕获错误：\n<ul>\n<li><code>Promise.resolve().then()</code>的错误最后才出现，因为需要在运行时<strong>添加处理程序</strong>（即未捕获前创建另一个新期约）</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>&#x2F;* 上述拒绝期约会抛出4个未捕获错误：栈追踪信息\n  Uncaught (in promise) Error: foo\n  at &lt;anonymous&gt;:1:51\n  at new Promise (&lt;anonymous&gt;)\n  at &lt;anonymous&gt;:1:11\n  (anonymous)\t@\tVM1402:1\n  (anonymous)\t@\tVM1402:1\n\n  Uncaught (in promise) Error: foo\n  at &lt;anonymous&gt;:3:9\n  at new Promise (&lt;anonymous&gt;)\n  at &lt;anonymous&gt;:2:11\n  (anonymous)\t@\tVM1402:3\n  (anonymous)\t@\tVM1402:2\n\n  Uncaught (in promise) Error: foo\n  at &lt;anonymous&gt;:8:26\n  (anonymous)\t@\tVM1402:8\n\n  Uncaught (in promise) Error: foo\n  at &lt;anonymous&gt;:6:9\n  (anonymous)\t@\tVM1402:6\n  Promise.then (async)\t\t\n  (anonymous)\t@\tVM1402:5\n*&#x2F;\n</code></pre><ul>\n<li><strong>异步错误</strong>的机制与同步是不同的：\n<ul>\n<li>同步代码通过<code>throw()</code>关键字抛出错误时，会停止执行后续任何命令</li>\n<li>在期约中抛出错误时，不会阻止同步指令，其<strong>错误</strong>也只能通过异步的<code>onRejected</code>处理程序<strong>捕获</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>throw Error(&#x27;foo&#x27;) &#x2F;&#x2F; 同步代码抛出错误（try&#x2F;catch中能捕获）\nconsole.log(&#x27;bar&#x27;) &#x2F;&#x2F; 后续任何指令不再执行\n&#x2F;&#x2F; Uncaught Error: foo，浏览器消息队列\n\nPromise.reject(Error(&#x27;foo&#x27;)) &#x2F;&#x2F; 期约中抛出错误（try&#x2F;catch中捕获不到）\nconsole.log(&#x27;bar&#x27;) &#x2F;&#x2F; &#x27;bar&#x27;，同步指令继续执行\n&#x2F;&#x2F; Uncaught (in promise) Error: foo，浏览器消息队列\n\nPromise.reject(Error(&#x27;foo&#x27;)).catch((e) =&gt; {\n  console.log(e) &#x2F;&#x2F; &#x27;Error: foo&#x27;，在期约中捕获\n})\n</code></pre><ul>\n<li><strong>执行函数</strong>中的错误，在<strong>解决或拒绝期约之前</strong>，仍可用<code>try/catch</code>捕获</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p40 = new Promise((resolve, reject) =&gt; {\n  try {\n    throw Error(&#x27;foo&#x27;)\n  } catch (error) {}\n  resolve(&#x27;bar&#x27;)\n})\nsetTimeout(console.log, 0, p40) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: &#x27;bar&#x27;}\n</code></pre><ul>\n<li><code>then()</code>和<code>catch()</code>的<code>onRejected</code>处理程序在语义上与<code>try/catch</code>相同（捕获错误后将其隔离，不影响正常逻辑），因此<code>onReject</code>处理程序在捕获异步错误后<strong>返回一个解决的期约</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>console.log(&#x27;begin synchronous execution&#x27;)\ntry {\n  throw Error(&#x27;foo&#x27;) &#x2F;&#x2F; 抛出同步错误\n} catch (error) {\n  console.log(&#x27;caught error&#x27;, error) &#x2F;&#x2F; 捕获同步错误\n}\nconsole.log(&#x27;continue synchronous execution&#x27;)\n&#x2F;*\n  &#x27;begin synchronous execution&#x27;\n  &#x27;caught error Error: foo&#x27;\n  &#x27;continue synchronous execution&#x27;\n*&#x2F;\n\nnew Promise((resolve, reject) =&gt; {\n  console.log(&#x27;begin synchronous execution&#x27;)\n  reject(Error(&#x27;bar&#x27;)) &#x2F;&#x2F; 抛出异步错误\n})\n  .catch((e) =&gt; {\n    console.log(&#x27;caught error&#x27;, e) &#x2F;&#x2F; 捕获异步错误\n  })\n  .then(() =&gt; {\n    console.log(&#x27;continue synchronous execution&#x27;)\n  })\n&#x2F;*\n</code></pre><h2>期约连锁与期约合成</h2>\n<ul>\n<li>多个期约在一起可以构成强大的代码逻辑：<strong>期约连锁（拼接）<strong>与</strong>期约合成（组合）</strong></li>\n</ul>\n<h3>期约连锁</h3>\n<ul>\n<li>每个期约的实例方法（<code>then()</code>、<code>catch()</code>、<code>finally()</code>）都返回新的期约实例，多个期约可连缀调用形成<strong>期约连锁</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p41 = new Promise((resolve, reject) =&gt; {\n  console.log(&#x27;first&#x27;)\n  resolve()\n})\np41\n  .then(() =&gt; console.log(&#x27;second&#x27;))\n  .then(() =&gt; console.log(&#x27;third&#x27;))\n  .then(() =&gt; console.log(&#x27;fourth&#x27;))\n&#x2F;* \n  &#x27;first&#x27;\n  &#x27;second&#x27;\n  &#x27;third&#x27;\n  &#x27;fourth&#x27;\n*&#x2F;\n</code></pre><ul>\n<li>若想<strong>串行化异步任务</strong>，需让<strong>每个执行器都返回期约实例</strong>，</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p42 = new Promise((resolve, reject) =&gt; {\n  console.log(&#x27;p42 first&#x27;)\n  setTimeout(resolve, 1000)\n})\np42\n  .then(\n    () =&gt;\n      &#x2F;&#x2F; 执行器返回期约实例\n      new Promise((resolve, reject) =&gt; {\n        console.log(&#x27;p42 second&#x27;)\n        setTimeout(resolve, 1000)\n      })\n  )\n  .then(\n    () =&gt;\n      &#x2F;&#x2F; 执行器返回期约实例\n      new Promise((resolve, reject) =&gt; {\n        console.log(&#x27;p42 third&#x27;)\n        setTimeout(resolve, 1000)\n      })\n  )\n  .then(\n    () =&gt;\n      &#x2F;&#x2F; 执行器返回期约实例\n      new Promise((resolve, reject) =&gt; {\n        console.log(&#x27;p42 fourth&#x27;)\n        setTimeout(resolve, 1000)\n      })\n  )\n&#x2F;* \n  &#x27;p42 first&#x27;（1秒后）\n  &#x27;p42 second&#x27;（2秒后）\n  &#x27;p42 third&#x27;（3秒后）\n  &#x27;p42 fourth&#x27;（4秒后）\n*&#x2F;\n</code></pre><ul>\n<li>可把生成期约的同样的代码<strong>封装</strong>到一个工厂函数中</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function delayedResolve(str) {\n  return new Promise((resolve, reject) =&gt; {\n    console.log(str)\n    setTimeout(resolve, 1000)\n  })\n}\ndelayedResolve(&#x27;p42 first&#x27;)\n  .then(() =&gt; delayedResolve(&#x27;p42 second&#x27;))\n  .then(() =&gt; delayedResolve(&#x27;p42 third&#x27;))\n  .then(() =&gt; delayedResolve(&#x27;p42 fourth&#x27;))\n&#x2F;* \n  &#x27;p42 first&#x27;（1秒后）\n  &#x27;p42 second&#x27;（2秒后）\n  &#x27;p42 third&#x27;（3秒后）\n  &#x27;p42 fourth&#x27;（4秒后）\n*&#x2F;\n</code></pre><ul>\n<li>期约连锁能有效<strong>解决回调地狱</strong>问题，上述代码如不用期约的情况如下</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function delayedNotPromise(str, callback = null) {\n  setTimeout(() =&gt; {\n    console.log(str)\n    callback &amp;&amp; callback()\n  }, 1000)\n}\ndelayedNotPromise(&#x27;p42 first&#x27;, () =&gt; {\n  delayedNotPromise(&#x27;p42 second&#x27;, () =&gt; {\n    delayedNotPromise(&#x27;p42 third&#x27;, () =&gt; {\n      delayedNotPromise(&#x27;p42 fourth&#x27;, () =&gt; {})\n    })\n  })\n})\n&#x2F;* \n  &#x27;p42 first&#x27;（1秒后）\n  &#x27;p42 second&#x27;（2秒后）\n  &#x27;p42 third&#x27;（3秒后）\n  &#x27;p42 fourth&#x27;（4秒后）\n*&#x2F;\n</code></pre><ul>\n<li><code>then()</code>、<code>catch()</code>、<code>finally()</code>都返回新的期约实例，可任意进行期约连锁</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p43 = new Promise((resolve, reject) =&gt; {\n  console.log(&#x27;p43&#x27;)\n  reject()\n})\np43\n  .catch(() =&gt; console.log(&#x27;p43 catch&#x27;))\n  .then(() =&gt; console.log(&#x27;p43 then&#x27;))\n  .finally(() =&gt; console.log(&#x27;p43 finally&#x27;))\n&#x2F;* \n  &#x27;p43&#x27;\n  &#x27;p43 catch&#x27;\n  &#x27;p43 then&#x27;\n  &#x27;p43 finally&#x27;\n*&#x2F;\n</code></pre><h3>期约图</h3>\n<ul>\n<li>一个期约可以有任意多个处理程序，期约连锁可以构建<strong>有向非循环图</strong></li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>- A\n  - B\n    - D\n    - E\n  - C\n    - F\n    - G\n</code></pre><pre class=\"prettyprint language-js\"><code>let A = new Promise((resolve, reject) =&gt; {\n  console.log(&#x27;A&#x27;)\n  resolve()\n})\nlet B = A.then(() =&gt; console.log(&#x27;B&#x27;))\nlet C = A.then(() =&gt; console.log(&#x27;C&#x27;))\nB.then(() =&gt; console.log(&#x27;D&#x27;))\nB.then(() =&gt; console.log(&#x27;E&#x27;))\nC.then(() =&gt; console.log(&#x27;F&#x27;))\nC.then(() =&gt; console.log(&#x27;F&#x27;))\n&#x2F;* \n  &#x27;A&#x27;\n  &#x27;B&#x27;\n  &#x27;C&#x27;\n  &#x27;D&#x27;\n  &#x27;E&#x27;\n  &#x27;F&#x27;\n*&#x2F;\n</code></pre><h3>Promise.all()和 Promise.race()</h3>\n<ul>\n<li><code>Promise.all()</code>接收一个<strong>可迭代对象</strong>（必传），返回一个<strong>新期约</strong>，其创建的期约会在<strong>一组期约全部解决之后</strong>再解决\n<ul>\n<li>可迭代对象中的元素通过<code>Promise.resolve()</code>转换为期约</li>\n<li>空迭代对象等价于<code>Promise.resolve()</code></li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>Promise.all([Promise.resolve(), Promise.resolve()]) &#x2F;&#x2F; 接收1组可迭代对象\nPromise.all([3, 4]) &#x2F;&#x2F; 可迭代对象中的元素通过Promise.resolve()转换为期约\nPromise.all([]) &#x2F;&#x2F; 空迭代对象等价于Promise.resolve()\nPromise.all() &#x2F;&#x2F; TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))，参数必填\n</code></pre><ul>\n<li><code>Promise.all()</code>合成的期约只会在<strong>每个包含期约都解决后</strong>才解决</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p44 = Promise.all([\n  Promise.resolve(),\n  new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)),\n])\np44.then(() =&gt; setTimeout(console.log, 0, &#x27;all() resolved!&#x27;)) &#x2F;&#x2F; &#x27;all() resolved!&#x27;（1秒后，非0秒，需等包含的期约先解决）\n</code></pre><ul>\n<li>若有 1 个包含的期约待定，则合成待定的期约，拒绝也同理（拒绝优先于待定）</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p45 = Promise.all([new Promise(() =&gt; {}), Promise.resolve()]) &#x2F;&#x2F; 包含的期约有待定的\nsetTimeout(console.log, 0, p45) &#x2F;&#x2F; Promise {&lt;pending&gt;}，合成待定的期约\nlet p46 = Promise.all([new Promise(() =&gt; {}), Promise.reject()]) &#x2F;&#x2F; 包含的期约有拒绝的（也有待定的）\n&#x2F;&#x2F; Uncaught (in promise) undefined\nsetTimeout(console.log, 0, p46) &#x2F;&#x2F; Promise {&lt;rejected&gt;: undefined}，合成拒绝的期约\n</code></pre><ul>\n<li>若包含的所有期约都成功解决，则合成解决的期约，解决值是所有包含期约的解决值的数组（按迭代器顺序）</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p47 = Promise.all([\n  Promise.resolve(1),\n  Promise.resolve(),\n  Promise.resolve(3),\n]) &#x2F;&#x2F; 包含的所有期约都解决\nsetTimeout(console.log, 0, p47) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: [1, undefined, 3]}\n</code></pre><ul>\n<li>若有期约拒绝，<strong>第一个</strong>拒绝的期约会将自己的理由作为<strong>合成期约的拒绝理由</strong>（后续理由不再影响合成期约的拒绝理由），但<strong>不影响</strong>后续期约的拒绝操作</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let p48 = Promise.all([\n  Promise.reject(3), &#x2F;&#x2F; 第一个拒绝的期约，拒绝理由为3\n  new Promise((resolve, reject) =&gt; setTimeout(reject, 1000, 4)), &#x2F;&#x2F; 第二个拒绝的期约，拒绝理由为4\n])\n&#x2F;&#x2F; Uncaught (in promise) 3\nsetTimeout(console.log, 0, p48) &#x2F;&#x2F; Promise {&lt;rejected&gt;: 3}，第一个拒绝理由作为合成期约的拒绝理由\np48.catch((reason) =&gt; setTimeout(console.log, 2000, reason)) &#x2F;&#x2F; 3，第一个拒绝理由作为合成期约的拒绝理由，但浏览器不会显示未处理的错误（Uncaught (in promise) 3）\n</code></pre><ul>\n<li><code>Promise.race()</code>与<code>Promise.all()</code>类似，接收一个<strong>可迭代对象</strong>（必传），包装集合中<strong>最先落定（解决或拒绝）<strong>期约解决值或拒绝理由并返回</strong>新期约</strong>\n<ul>\n<li>可迭代对象中的元素通过<code>Promise.resolve()</code>转换为期约</li>\n<li>空迭代对象等价于<code>Promise.resolve()</code></li>\n<li>迭代顺序决定落定顺序</li>\n<li><strong>第一个拒绝的期约会将自己的理由作为</strong>合成期约的拒绝理由**，但**不影响** 后续期约的拒绝操作</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>Promise.race([Promise.resolve(), Promise.resolve()]) &#x2F;&#x2F; 接收1组可迭代对象\nPromise.race([3, 4]) &#x2F;&#x2F; 可迭代对象中的元素通过Promise.resolve()转换为期约\nPromise.race([]) &#x2F;&#x2F; 空迭代对象等价于Promise.resolve()\n&#x2F;&#x2F; Promise.all() &#x2F;&#x2F; TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))，参数必填\n\nlet p49 = Promise.race([\n  Promise.resolve(3),\n  new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)),\n])\nsetTimeout(console.log, 0, p49) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: 3}，解决先发生，超时后的拒绝被忽略\n\nlet p50 = Promise.race([\n  Promise.reject(4),\n  new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)),\n])\n&#x2F;&#x2F; Uncaught (in promise) 4\nsetTimeout(console.log, 0, p50) &#x2F;&#x2F; Promise {&lt;rejected&gt;: 4}，拒绝先发生，超时后的解决被忽略\n\nlet p51 = Promise.race([\n  Promise.resolve(1),\n  Promise.resolve(),\n  Promise.resolve(3),\n])\nsetTimeout(console.log, 0, p51) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: 1}，迭代顺序决定落定顺序\n\nlet p52 = Promise.race([\n  Promise.reject(3), &#x2F;&#x2F; 第一个拒绝的期约，拒绝理由为3\n  new Promise((resolve, reject) =&gt; setTimeout(reject, 1000, 4)), &#x2F;&#x2F; 第二个拒绝的期约，拒绝理由为4\n])\n&#x2F;&#x2F; Uncaught (in promise) 3\nsetTimeout(console.log, 0, p52) &#x2F;&#x2F; Promise {&lt;rejected&gt;: 3}，第一个拒绝理由作为合成期约的拒绝理由\np52.catch((reason) =&gt; setTimeout(console.log, 2000, reason)) &#x2F;&#x2F; 3，第一个拒绝理由作为合成期约的拒绝理由，但浏览器不会显示未处理的错误（Uncaught (in promise) 3）\n</code></pre><h3>串行期约合成</h3>\n<ul>\n<li>多个函数可以合成为一个函数</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function addTwo(x) {\n  return x + 2\n}\nfunction addThree(x) {\n  return x + 3\n}\nfunction addFive(x) {\n  return x + 5\n}\n\nfunction addTen(x) {\n  return addFive(addThree(addTwo(x)))\n}\nconsole.log(addTen(7)) &#x2F;&#x2F; 17\n</code></pre><ul>\n<li>与函数合成类似，期约可以<strong>异步产生值</strong>并将其<strong>传给处理程序</strong>，后续期约可用<strong>之前期约的返回值</strong>来串联期约</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function addTen(x) {\n  return Promise.resolve(x).then(addTwo).then(addThree).then(addFive)\n}\nsetTimeout(console.log, 0, addTen(8)) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: 18}\naddTen(8).then((result) =&gt; console.log(result)) &#x2F;&#x2F; 18\n</code></pre><ul>\n<li>可使用<code>Array.prototype.reduce()</code>简写上述期约串联</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function addTen(x) {\n  return [addTwo, addThree, addFive].reduce((pre, cur) =&gt; {\n    return pre.then(cur)\n  }, Promise.resolve(x)) &#x2F;&#x2F; 归并起点值（归并函数第1个参数）为Promise.resolve(x)，第2个参数为数组第1项addTwo\n}\nsetTimeout(console.log, 0, addTen(9)) &#x2F;&#x2F; Promise {&lt;fulfilled&gt;: 19}\naddTen(9).then((result) =&gt; console.log(result)) &#x2F;&#x2F; 19\n</code></pre><ul>\n<li>可将其最终<strong>封装</strong>成一个<strong>通用方法</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function compose(...fns) {\n  return (x) =&gt;\n    fns.reduce((pre, cur) =&gt; {\n      return pre.then(cur)\n    }, Promise.resolve(x))\n}\naddTen = compose(addTwo, addThree, addFive)\naddTen(10).then((result) =&gt; console.log(result)) &#x2F;&#x2F; 20\n</code></pre><h2>期约扩展</h2>\n<ul>\n<li>期约有其不足之处，ECMAScript 未涉及的两个特性<strong>期约取消</strong>和<strong>进度追踪</strong>在很多第三方期约库中已实现</li>\n</ul>\n<h3>期约取消</h3>\n<ul>\n<li>可以提供一种临时性的<strong>封装</strong>，以实现<strong>取消期约</strong>的功能</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>const startButton = document.querySelector(&#x27;#start&#x27;) &#x2F;&#x2F; 开始按钮\nconst cancelButton = document.querySelector(&#x27;#cancel&#x27;) &#x2F;&#x2F; 结束按钮\nlet cancelBtnHasClickEvent = false &#x2F;&#x2F; 结束按钮是否已添加点击事件\n&#x2F;* \n  书中案例每次点击“开始”按钮，都会重新实例化CancelToken实例，给cancelToken追加一个点击事件，打印的&#x27;delay cancelled&#x27;会随之越来越多\n  这里追加一个全局变量cancelBtnHasClickEvent，确保只在首次点击“开始”按钮时，给cancelToken只追加一次点击事件\n*&#x2F;\n\n&#x2F;&#x2F; CancelToken类，包装一个期约，把解决方法暴露给cancelFn参数\nclass CancelToken {\n  constructor(cancelFn) {\n    this.promise = new Promise((resolve, reject) =&gt; {\n      cancelFn(() =&gt; {\n        setTimeout(console.log, 0, &#x27;delay cancelled&#x27;) &#x2F;&#x2F; 取消计时\n        resolve() &#x2F;&#x2F; 期约解决\n      })\n    })\n  }\n}\n\n&#x2F;&#x2F; 点击事件：开始计时、实例化新的CancelToken实例\nfunction cancellabelDelayedResolve(delay) {\n  setTimeout(console.log, 0, &#x27;set delay&#x27;) &#x2F;&#x2F; 开始计时\n  return new Promise((resolve, reject) =&gt; {\n    const id = setTimeout(() =&gt; {\n      setTimeout(console.log, 0, &#x27;delay resolve&#x27;) &#x2F;&#x2F; 经延时后触发\n      resolve()\n    }, delay)\n    &#x2F;&#x2F; 实例化新的CancelToken实例\n    const cancelToken = new CancelToken((cancelCallback) =&gt; {\n      cancelBtnHasClickEvent === false &amp;&amp;\n        cancelButton.addEventListener(&#x27;click&#x27;, cancelCallback) &#x2F;&#x2F; 结束按钮添加点击事件\n      cancelBtnHasClickEvent = true &#x2F;&#x2F; 结束按钮已添加点击事件\n    })\n    cancelToken.promise.then(() =&gt; clearTimeout(id)) &#x2F;&#x2F; 触发令牌实例中的期约解决\n  })\n}\n\nstartButton.addEventListener(&#x27;click&#x27;, () =&gt; cancellabelDelayedResolve(1000)) &#x2F;&#x2F; 开始按钮添加点击事件\n</code></pre><p>&lt;a href=“<a href=\"https://github.com/simon9124/my_demos/blob/master/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89/%E7%AC%AC11%E7%AB%A0%20%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/button.html\">https://github.com/simon9124/my_demos/blob/master/javascript高级程序设计（第四版）/第11章 期约与异步函数/button.html</a>” target=&quot;_blank&quot;&gt;完整文件 →&lt;/a&gt;</p>\n<h3>期约进度通知</h3>\n<ul>\n<li>ES6 不支持监控期约的执行进度，可通过扩展来实现</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 子类TrackablePromise，继承父类Promise\nclass TrackablePromise extends Promise {\n  &#x2F;&#x2F; 子类构造函数，接收1个参数（executor函数）\n  constructor(executor) {\n    const notifyHandlers = []\n    &#x2F;&#x2F; super()调用父类构造函数constructor()，传入参数（执行器函数）\n    super((resolve, reject) =&gt; {\n      &#x2F;&#x2F; 执行executor()函数，参数为传给TrackablePromise子类的参数，返回执行的结果\n      return executor(resolve, reject, (status) =&gt; {\n        console.log(status)\n        &#x2F;* \n          &#x27;80% remaining&#x27;（约1秒后）\n          &#x27;60% remaining&#x27;（约2秒后）\n          &#x27;remaining&#x27;（约3秒后）\n          &#x27;remaining&#x27;（约4秒后）\n        *&#x2F;\n        notifyHandlers.map((handler) =&gt; {\n          return handler(status)\n        })\n      })\n    })\n    this.notifyHandlers = notifyHandlers\n  }\n  &#x2F;&#x2F; 添加notify方法，接收1个参数（notifyhandler函数）\n  notify(notifyHandler) {\n    this.notifyHandlers.push(notifyHandler)\n    return this\n  }\n}\n\n&#x2F;&#x2F; 创建子类实例，传入参数（executor函数）\nlet p53 = new TrackablePromise((resolve, reject, notify) =&gt; {\n  function countdown(x) {\n    if (x &gt; 0) {\n      notify(&#96;${20 * x}% remaining&#96;)\n      setTimeout(() =&gt; countdown(x - 1), 1000)\n    } else {\n      resolve()\n    }\n  }\n  countdown(5)\n})\nconsole.log(p53) &#x2F;&#x2F; Promise {&lt;pending&gt;, notifyHandlers: Array(0)}，TrackablePromise实例（子类期约）\n\np53.notify((x) =&gt; setTimeout(console.log, 0, &#x27;progress:&#x27;, x)) &#x2F;&#x2F; 调用期约实例的notify()方法，传入参数（notifyhandler函数）\np53.then(() =&gt; setTimeout(console.log, 0, &#x27;completed&#x27;)) &#x2F;&#x2F; 调用期约实例的then()方法，传入参数（onResolved处理程序）\n&#x2F;* \n  &#x27;progress: 80% remaining&#x27;（约1秒后）\n  &#x27;progress: 60% remaining&#x27;（约2秒后）\n  &#x27;progress: 40% remaining&#x27;（约3秒后）\n  &#x27;progress: 20% remaining&#x27;（约4秒后）\n  &#x27;completed&#x27;（约5秒后）\n*&#x2F;\n\np53\n  .notify((x) =&gt; setTimeout(console.log, 0, &#x27;a:&#x27;, x))\n  .notify((x) =&gt; setTimeout(console.log, 0, &#x27;b:&#x27;, x)) &#x2F;&#x2F; notice()返回期约，连缀调用\np53.then(() =&gt; setTimeout(console.log, 0, &#x27;completed&#x27;))\n&#x2F;* \n  &#x27;a: 80% remaining&#x27;（约1秒后）\n  &#x27;b: 80% remaining&#x27;（约1秒后）\n  &#x27;a: 60% remaining&#x27;（约2秒后）\n  &#x27;b: 60% remaining&#x27;（约2秒后）\n  &#x27;a: 40% remaining&#x27;（约3秒后）\n  &#x27;b: 40% remaining&#x27;（约3秒后）\n  &#x27;a: 20% remaining&#x27;（约4秒后）\n  &#x27;b: 20% remaining&#x27;（约4秒后）\n  &#x27;completed&#x27;（约5秒后）\n*&#x2F;\n</code></pre><h2>总结 &amp; 问点</h2>\n<ul>\n<li>什么是 Promise 类型？如何创建？其不同状态分别表示什么？</li>\n<li>执行器函数负责的作用是什么？如何推迟其切换状态？如何避免期约卡在待定状态？</li>\n<li>如何实例化一个解决的期约？其值是什么？若传入的参数也是期约结果会怎样？</li>\n<li>如何实例化一个拒绝的期约？其拒绝理由是什么？若传入的参数也是期约结果会怎样？</li>\n<li>Promise.prototype.then()、Promise.prototype.catch()、Promise.prototype.finally()的含义分别是什么？分别接收哪些参数？根据参数的不同，其返回值分别有哪些情况？</li>\n<li>如何理解期约的“非重入”？其适用于哪些处理程序？</li>\n<li>若同一个期约添加了多个处理程序，当其状态变化时处理程序按怎样的顺序执行？如何把期约的解决值和拒绝理由传递给处理程序？</li>\n<li>如何传递解决值和拒绝理由？如何在抛出错误时捕获错误对象？为什么拒绝理由最好统一使用错误对象？</li>\n<li>写一段代码，分别在【try/catch 和期约】中捕获【同步和异步】的错误，且不影响正常的其他（后续）代码逻辑</li>\n<li>写一段代码，完成多个异步任务的串行：① 不用期约，形成“回调地狱” ② 用期约连锁解决这个问题</li>\n<li>Promise.all()和 Promise.race()的含义是什么？其在不同情况下分别返回怎样的期约？</li>\n<li>写一段代码，串联多个期约，再用 reduce()简化其代码，最后将其封装成一个通用方法</li>\n<li>写一段代码实现以下功能：页面有 2 个按钮【开始】和【结束】，单击【开始】实例化一个新期约并打印“开始”，1 秒后期约兑现并打印“成功”，单击【结束】取消该期约并打印“结束”</li>\n</ul>\n</div>",
      "title": "《javascript高级程序设计》学习笔记 | 11.2.期约",
      "author": {
        "loginname": "simon9124",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 134,
      "country": "USA"
    },
    {
      "id": "574e4f4679caf4c12f99e9de",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/yinghuocho/firefly-proxy\">firefly</a>\n还有windows版本和OSX版本</p>\n</div>",
      "title": "linux翻-墙软件firefly",
      "author": {
        "loginname": "yuedun",
        "avatar_url": "https://avatars.githubusercontent.com/u/7362116?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 135,
      "country": "China"
    },
    {
      "id": "5db00477865a9844a301d40f",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FucvSLnOyFR2FB3b3F85CJ5cR8NN\" alt=\"over.png\">\n海外华人，住，学习，工作或旅游去的，如果想看中国电视剧或想听中国音乐他们会看不到。因为由于中国的地理限制。在那里生活的中国人必须找到一种解决<a href=\"https://www.vpnranks.com/zh-hans/blog/vpn%e5%9c%a8%e4%b8%ad%e5%9b%bd/\">翻墙回国</a>。如果您不在中国，则需要在大陆上提供带有VPN服务器的提供商。\nVPN用于在两个实际的独立网络之间创建虚拟网络。该技术可帮助消费者将笔记本电脑桥接到办公室或家庭网络，以便他们可以随时随地轻松访问文件。\n<strong>为什么要翻墙回国？</strong>\n一般中国人在国外不习惯住，因为文化和习惯差异。许多海外学生或华人发现，某些外国娱乐文化甚至笑声根本没有引起人们的兴趣，网络电缆可能是您唯一的娱乐方式。甚至有线电视或互联网也向您展示西方文化。那么我相信，如果您没有自己喜欢的东西，甚至无法观看自己喜欢的频道（如您在中国的工作方式），就没有生命。\n但是国内视频网站如优酷、腾讯视频、爱奇艺、哔哩哔哩上有不少只对大陆用户免费开放的影视综艺节目，却严格限制海外（包括港澳台）直接访问，海外IP会显示“该视频仅限中国大陆地区用户观看”。</p>\n<p><strong>结论</strong>\n不管你们在国外什么地方，你们想看中国电视剧或要听中国音乐你可以通过 VPN 来翻墙回国。</p>\n</div>",
      "title": "海外华人如何翻墙回国看中国电视视频?",
      "author": {
        "loginname": "jhontcv",
        "avatar_url": "https://avatars1.githubusercontent.com/u/45487716?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 136,
      "country": "Eurozone"
    },
    {
      "id": "61401314fe0c51894dae9f34",
      "content": "<div class=\"markdown-text\"><p>模拟了一个秒杀的场景，发现count为0，但是有多个用户买了，麻烦大佬看看，谢谢！\n代码如下：</p>\n<pre class=\"prettyprint\"><code>  async buy(ctx) {\n    try {\n      await redis.watch(&quot;goods_count&quot;);\n      const count = await redis.get(&quot;goods_count&quot;);\n      if (parseInt(count) &gt; 0) {\n        console.log(count);\n        const time = new Date();\n        const at = Math.round(time &#x2F; 1000);\n        const data = await redis.multi().zadd(&quot;user_goods_list&quot;, at, uuid.v4()).set(&quot;goods_count&quot;, count - 1).exec();\n        console.log(data);\n        ctx.body = {\n          message: &quot;抢到了&quot;\n        }\n      } else {\n        ctx.body = {\n          message: &quot;goods is empty&quot;\n        }\n      }\n    } catch (error) {\n      console.log(error)\n      ctx.body = {\n        message: &quot;fail&quot;\n      }\n    }\n  }\n</code></pre></div>",
      "title": "redis 秒杀问题",
      "author": {
        "loginname": "DWNEWS-weiqingtao",
        "avatar_url": "https://avatars.githubusercontent.com/u/49009350?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 137,
      "country": "USA"
    },
    {
      "id": "6138b59bfe0c51faedae9486",
      "content": "<div class=\"markdown-text\"><ul>\n<li>微信收费\n<a href=\"https://finance.ifeng.com/c/89GZbU9nie4\">https://finance.ifeng.com/c/89GZbU9nie4</a></li>\n<li>自建聊天服务</li>\n</ul>\n<pre class=\"prettyprint\"><code>const app =  require(&#x27;diet&#x27;)();\napp.listen(8000)\nconst io = require(&#x27;socket.io&#x27;)(app.server)\n\nio.on(&#x27;connection&#x27;,  sock =&gt; {\n \tsock.on(&#x27;message&#x27;, msg =&gt;{\n           console.log(msg);\n           io.sockets.emit(&quot;message&quot;,msg);\n\t});\n});\n\napp.get(&#x27;&#x2F;&#x27;, function($){\n    $.header(&#x27;content-type&#x27;, &#x27;text&#x2F;html&#x27;);\n    $.end( &#x27;&lt;!DOCTYPE html&gt;&#x27;\n        + &#x27;&lt;html&gt;&#x27;\n        + &#x27;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text&#x2F;html; charset=utf-8&quot;&gt;&#x27;\n        +     &#x27;&lt;title&gt;Diet + Socket.io&lt;&#x2F;title&gt;&#x27;\n        +     &#x27;&lt;script src=&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot; &gt;&lt;&#x2F;script&gt;&#x27;\n        +     &#x27;&lt;script src=&quot;&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;&#x27;\n        +     &#x27;&lt;script&gt;var socket = io();&lt;&#x2F;script&gt;&#x27;\n        + &#x27;&lt;&#x2F;head&gt;&#x27;\n        + &#x27;&lt;body&gt;&lt;input name=&quot;msg&quot; id=&quot;msg&quot; &gt;&lt;button id=&quot;btn&quot;&gt;send!&lt;&#x2F;button&gt;&lt;ul id=&quot;hist&quot;&gt;&lt;&#x2F;ul&gt;&#x27;\n\t\t+     &#x27;&lt;script&gt;socket.on(&quot;message&quot;,function(msg){$(&quot;#hist&quot;).append(&quot;&lt;li&gt;&quot;+msg);});$(&quot;#btn&quot;).on(&quot;click&quot;,function(){ socket.send($(&quot;#msg&quot;).val());$(&quot;#msg&quot;).val(&quot;&quot;);});&lt;&#x2F;script&gt;&#x27;\n        + &#x27;&lt;&#x2F;body&gt;&#x27;\n        + &#x27;&lt;&#x2F;html&gt;&#x27;);\n});\n \n</code></pre></div>",
      "title": "微信收费了，自建聊天服务器会不会流行起来",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 138,
      "country": "China"
    },
    {
      "id": "613b2386fe0c518473ae98d1",
      "content": "<div class=\"markdown-text\"><p>以职场为副本，独特的描述了关于程序员的感情生活，展现了程序员真实的码农日常，这一部剧算是国内少数以程序员为题材的恋爱戏码。\n明明是谈恋爱花式虐狗，关程序员什么事？毕竟这部剧的主题不是程序与代码，就是一个程序员和霸道总裁谈恋爱啊！\n对此你怎么看\n<img src=\"//static.cnodejs.org/FhPT9RL_voABYbfeZTa8s25pEH_g\" alt=\"WechatIMG44293.png\"></p>\n</div>",
      "title": "如何评价《程序员那么可爱》",
      "author": {
        "loginname": "nodeProgrammer",
        "avatar_url": "https://avatars.githubusercontent.com/u/15918416?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 139,
      "country": "China"
    },
    {
      "id": "613851b2fe0c5120eaae930f",
      "content": "<div class=\"markdown-text\"><h2>楔子</h2>\n<p>突然发现在 Node.js 16.9.0 的官方文档里面，多了个 Experimental 的 <a href=\"https://nodejs.org/dist/latest-v16.x/docs/api/corepack.html\">Corepack</a>：</p>\n<blockquote>\n<p><strong>Corepack is an experimental tool to help with managing versions of your package managers.</strong> It exposes binary proxies for each supported package manager that, when called, will identify whatever package manager is configured for the current project, transparently install it if needed, and finally run it without requiring explicit user interactions.</p>\n</blockquote>\n<p>看完文档一脸懵逼：这是啥？要干掉 NPM？为啥这么突然？</p>\n<p>于是进一步翻了仓库和对应的讨论：</p>\n<blockquote>\n<p>Corepack is a zero-runtime-dependency Node script that acts as a bridge between Node projects and the package managers they are intended to be used with during development. In practical terms, <strong>Corepack will let you use Yarn and pnpm without having to install them</strong> - just like what currently happens with npm, which is shipped by Node by default.</p>\n<p>摘自：<a href=\"https://github.com/nodejs/corepack/blob/main/DESIGN.md\">https://github.com/nodejs/corepack/blob/main/DESIGN.md</a></p>\n</blockquote>\n<p><strong>简单来说，Corepack 会成为 Node.js 官方的内置 CLI，用来管理『包管理工具（npm、yarn、pnpm、cnpm）』，用户无需手动安装，即『包管理器的管理器』。</strong>\n​</p>\n<h2>初体验</h2>\n<p>​</p>\n<p>先安装 Node.16.9.0 版本，然后在 <code>package.json</code> 中声明对应的包管理工具：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; package.json\n{\n  &quot;name&quot;: &quot;corepack-test&quot;,\n  &quot;packageManager&quot;: &quot;yarn@2.0.0&quot;,\n    \n  &#x2F;&#x2F; 未来可能会改为这个\n  &quot;engines&quot;: {\n    &quot;pm&quot;: &quot;yarn@^2.0.0&quot;\n  }\n}\n</code></pre><p>​</p>\n<p>玩起来：</p>\n<pre class=\"prettyprint language-bash\"><code># 单应用激活\n$ corepack enable\n\n# 用声明的包管理器，会自动下载对应的 yarn，然后再执行\n$ yarn install\n\n# 用非声明的包管理器，会自动拦截报错\n$ pnpm install\nUsage Error: This project is configured to use yarn\n</code></pre><p>​</p>\n<p>我嚓，没全局安装 yarn 也能找到命令，怎么搞的？分析了下，非常粗暴。。。</p>\n<pre class=\"prettyprint language-bash\"><code>$ which corepack    \n&#x2F;Users&#x2F;tz&#x2F;.nvs&#x2F;node&#x2F;16.9.0&#x2F;x64&#x2F;bin&#x2F;corepack\n\n$ ll &#x2F;Users&#x2F;tz&#x2F;.nvs&#x2F;node&#x2F;16.9.0&#x2F;x64&#x2F;bin&#x2F;\ncorepack -&gt; ..&#x2F;lib&#x2F;node_modules&#x2F;corepack&#x2F;dist&#x2F;corepack.js\nnpm -&gt; ..&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;bin&#x2F;npm-cli.js\nnpx -&gt; ..&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;bin&#x2F;npx-cli.js\npnpm -&gt; ..&#x2F;lib&#x2F;node_modules&#x2F;corepack&#x2F;dist&#x2F;pnpm.js\npnpx -&gt; ..&#x2F;lib&#x2F;node_modules&#x2F;corepack&#x2F;dist&#x2F;pnpx.js\nyarn -&gt; ..&#x2F;lib&#x2F;node_modules&#x2F;corepack&#x2F;dist&#x2F;yarn.js\nyarnpkg -&gt; ..&#x2F;lib&#x2F;node_modules&#x2F;corepack&#x2F;dist&#x2F;yarnpkg.js\n</code></pre><p>​</p>\n<p>其他用法：</p>\n<pre class=\"prettyprint language-bash\"><code>\n# 全局指令如 npm init 这种，需要设置\n$ corepack prepare yarn@x.y.z --activate\n\n# 也支持代理方式，类似 npx 执行远程包\n$ corepack yarn@2.1.0 install\n</code></pre><p>​</p>\n<p>小结：<strong>对于大部分开发者来说，基本上无感，原来怎么用还怎么用，只是无需特意全局安装对应的包管理器了。</strong></p>\n<ul>\n<li>用户无需手动安装包管理器，有点类似 npx 执行远程包。</li>\n<li>每个应用都可以声明自己的包管理工具以及对应的版本，类似于 cnpm 的 install-node 机制。</li>\n<li>目前还在非常早期阶段，Bug 不少，名字也还不统一，有叫 pmm 也叫 corepack。</li>\n</ul>\n<p>​</p>\n<h2>探究</h2>\n<p>​</p>\n<p>为什么要做这个？\n​</p>\n<blockquote>\n<p>Various problems arise from npm being the only package manager shipped by default:</p>\n<ul>\n<li>Projects using popular package management solutions other than npm (particularly Yarn and pnpm) require additional installation step that must often be repeated when switching between Node versions. This lead to a significant part of the Node userbase effectively being a second-class citizen, which sounds unfortunate.</li>\n<li>Because one package manager currently holds a special treatment, users are more likely to pick it even if they would choose another solution should they have the choice (it really depends on how they balance the tradeoffs, but sometimes they value simplicity over purely technical factors). This artificial barrier hurts our community by making it harder to pick the right tool for the job.</li>\n<li>Having a single official package manager means that all the keys belong to a single player which can do whatever it pleases with it (even the Node project only has a limited influence over it, since removing the unique package manager would be poorly accepted by the community). Spreading these responsibilities over multiple projects gives less power to each, ensuring that everyone behave well.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>摘自：<a href=\"https://github.com/nodejs/corepack/blob/main/DESIGN.md\">https://github.com/nodejs/corepack/blob/main/DESIGN.md</a></p>\n</blockquote>\n<p>​</p>\n<p>简单的说，发起者认为，npm 目前是唯一的包管理工具，导致广大开发者喜爱的 pnpm、yarn 等工具成为二等公民，伤害到用户体验以及社区的良性发展。早在 2017 年就发起的<a href=\"https://github.com/nodejs/node/discussions/15244\">讨论</a>，在<a href=\"https://github.com/nodejs/TSC/issues/1012\">最近的 TSC 表决</a>中通过。\n​</p>\n<p>虽然发起者 arcanis 利益相关，是 yarn 的 Lead maintainer，但只想给它点个赞，并对 npm 说：你也有今天！\n​</p>\n<p><strong>npm 这个阿斗，在 Node.js 起步时起了很大的作用，但它毕竟是个商业公司，而且这么多年来，一直不思进取：</strong></p>\n<ul>\n<li>在 npm 负责人变更后。。。</li>\n<li>在 npm 打败 bower 统一前端包管理并承诺会对前端包有更好的支持后。。。</li>\n<li>在 yarn 这个鲶鱼出现后。。。</li>\n<li>在 GitHub 收购 npm 后。。。</li>\n</ul>\n<p>​</p>\n<p><strong>我们一次一次的重燃希望又一次一次的失望，这废宅只会躺平，三天打鱼两天晒网，直到今天，Node.js 官方决定把他赶出门磨练下。</strong>\n<strong>​</strong></p>\n<p><img src=\"//static.cnodejs.org/Fk_4esBPFatUoJhoqeO9PTWN8W_9\" alt=\"Group2.png\"></p>\n<h2>后续规划</h2>\n<blockquote>\n<p>The full npm package wouldn’t be included out of the box anymore (this might be an incremental move, with first a major version shipping pmm + npm, and the next one discarding npm).</p>\n</blockquote>\n<ul>\n<li>Corepack 从 16.9.0 开始，内置到 Node.js 的安装包中。</li>\n<li><strong>npm 将慢慢从 Node.js 内置包中移除，预计在下一个大版本启动。</strong></li>\n<li>目前仅支持 pnpm 和 yarn，我们的 cnpm 晚点会提 PR 支持下。</li>\n<li>包管理器发布新版本后，需提 PR 到 Corepack 来更新版本。</li>\n<li>未看到切换安装源方面的能力，我们将参与进去，把国内的使用场景同步给社区。</li>\n</ul>\n<p>​</p>\n<h2>相关资料</h2>\n<ul>\n<li>Corepack 官方文档：<a href=\"https://github.com/nodejs/corepack/blob/main/DESIGN.md\">https://github.com/nodejs/corepack/blob/main/DESIGN.md</a></li>\n<li>Node.js 官方文档：<a href=\"https://nodejs.org/dist/latest-v16.x/docs/api/corepack.html\">https://nodejs.org/dist/latest-v16.x/docs/api/corepack.html</a></li>\n<li>Node.js TSC 讨论：<a href=\"https://github.com/nodejs/TSC/issues/1012\">https://github.com/nodejs/TSC/issues/1012</a></li>\n<li>Node.js Issue 讨论：<a href=\"https://github.com/nodejs/node/issues/15244\">https://github.com/nodejs/node/issues/15244</a></li>\n<li>Reddit 讨论：<a href=\"https://www.reddit.com/r/javascript/comments/pjkdms/corepack_experimental_new_nodejs_feature_to/\">https://www.reddit.com/r/javascript/comments/pjkdms/corepack_experimental_new_nodejs_feature_to/</a></li>\n</ul>\n<p>​</p>\n<p>本文同步发布于知乎专栏，<a href=\"https://zhuanlan.zhihu.com/p/408122100\">https://zhuanlan.zhihu.com/p/408122100</a>，求点赞。</p>\n</div>",
      "title": "即将被 Node.js 官方抛弃的废宅阿斗 NPM",
      "author": {
        "loginname": "atian25",
        "avatar_url": "https://avatars.githubusercontent.com/u/227713?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 140,
      "country": "Japan"
    },
    {
      "id": "6135c8b5fe0c517a27ae8cda",
      "content": "<div class=\"markdown-text\"><p>基于 Node.js 的可视化 BFF 解决方案。</p>\n<blockquote>\n<p>BFF —— Backend for frontend，即服务于前端的后端。<br>\n简单来说，BFF就是在传统的前端和基础服务（接口）之间，增加一个适配层，以更好的满足前端的需求。</p>\n</blockquote>\n<p>要快速开始，请进入 <code>node-bff-ui</code> 和 <code>node-bff-service</code> 目录参照说明安装及启动项目。</p>\n<p>核心流程已经开发完毕，但还有部分其它功能待开发，欢迎提交PR。</p>\n<h3>仓库地址</h3>\n<p><a href=\"https://github.com/eshengsky/node-bff\">https://github.com/eshengsky/node-bff</a></p>\n<h3>预览</h3>\n<ul>\n<li>接口列表\n<img src=\"https://raw.githubusercontent.com/eshengsky/node-bff/main/assets/preview-list.png\" alt=\"image\"></li>\n<li>接口详情\n<img src=\"https://raw.githubusercontent.com/eshengsky/node-bff/main/assets/preview-detail.png\" alt=\"image\"></li>\n<li>handler函数编辑\n<img src=\"https://raw.githubusercontent.com/eshengsky/node-bff/main/assets/preview-handler.png\" alt=\"image\"></li>\n<li>接口在线调试\n<img src=\"https://raw.githubusercontent.com/eshengsky/node-bff/main/assets/preview-onlinetest.png\" alt=\"image\"></li>\n</ul>\n<h3>系统概述</h3>\n<ul>\n<li>支持通过可视化、配置化方式，拼装聚合接口，聚合接口底层再去调用基础接口或第三方API。</li>\n<li>可视化指的是以类似流程图的形式展示一个聚合接口的完整的处理流程，清晰直观。</li>\n<li>配置化指的是以无代码或低代码实现一个聚合接口。</li>\n<li>对于不需要做额外逻辑处理的情形，能够在数分钟内以纯配置方式拼装一个聚合接口，而无需编写任何代码。</li>\n<li>对于需要做一些额外逻辑处理的情形，在各个阶段会自动插入函数，提供编写代码进行业务逻辑处理或参数处理的能力。</li>\n<li>对于需要在额外逻辑处理中编写复杂代码的情形，例如需要引入第三方库、需要自定义接口响应头等，该系统不支持，只能和之前的接口组类似，在项目中手动开发一个接口。</li>\n</ul>\n<h3>相关解释</h3>\n<p><strong>context</strong>：该聚合接口的上下文对象，会作为参数传入所有处理函数中，在定义基础接口的入参时也可以访问到。初始的 context 对象包含了3个字段：</p>\n<ul>\n<li><code>$request</code> - 请求对象，包括 query, body, cookies, headers 等</li>\n<li><code>$public</code> - 配置的公共参数</li>\n<li><code>$getValue</code> - 安全地获取字段值的方法</li>\n</ul>\n<p><strong>聚合接口</strong>：在本系统中创建的接口，可以配置内部调用的基础接口，也可以编写任意处理函数。</p>\n<p><strong>基础接口</strong>：后端提供的基于微服务的具备单一职责的接口，在添加一个基础接口到接口组时，必须指定 name，后续流程可以通过 <code>context.${name}</code> 获取到该接口的响应对象。</p>\n<p><strong>API group</strong>：包含1个或多个基础接口，并发调用。只有当接口组中的全部接口都请求完成后，流程才会继续。</p>\n<p><strong>Handler</strong>：处理函数，会在聚合接口的各个阶段自动执行，可以用来编写业务逻辑代码、构建后续接口组需要的参数、直接返回响应等。</p>\n<p><strong>Common handler</strong>：位于 Start 之后或相邻两个 API group 之间的处理函数。默认处理函数内容为空，即不执行任何操作。</p>\n<p><strong>Response handler</strong>：聚合接口结束之前的处理函数，可以在这里组装最终响应结果。必须要有返回值。默认处理函数会返回流程中所有基础接口的聚合响应内容。</p>\n<h3>总体设计</h3>\n<ul>\n<li>\n<p>技术架构\n<img src=\"https://raw.githubusercontent.com/eshengsky/node-bff/main/assets/chart1.jpg\" alt=\"image\"></p>\n</li>\n<li>\n<p>node-bff-ui</p>\n</li>\n</ul>\n<p>这是一个 Web 应用，使用禅道（或Gitlab）账号登录系统，可配置哪些账号具有编辑权限，类似 Node Proxy。大概的功能模块包括：</p>\n<ol>\n<li>查看聚合接口列表</li>\n<li>新增或编辑聚合接口</li>\n<li>查看基础接口列表</li>\n<li>新增或编辑基础接口</li>\n<li>查看公共参数列表</li>\n<li>新增或编辑公共参数</li>\n<li>全局配置项管理</li>\n</ol>\n<p>创建一个新的聚合接口的大概流程如下：</p>\n<ol>\n<li>点击新增聚合接口，输入接口路径和入参，保存后跳转到编辑页；</li>\n<li>初始状态，流程中只包含 Start、1 个 Common handler、Response handler、End 节点；</li>\n<li>可以在新的或当前的 API group 中，通过点击新增基础接口按钮，添加基础接口；</li>\n<li>添加基础接口时可以自行输入接口路径，也支持通过联想从基础接口库中自动读取；</li>\n<li>基础接口的入参可以配置为一个表达式；</li>\n<li>基础接口可以单独配置超时时长；</li>\n<li>基础接口可以单独配置异常（500、超时等）处理方式，是忽略异常还是终止流程；</li>\n<li>基础接口可以单独配置未登录处理方式，是忽略未登录还是终止流程；</li>\n<li>Start 之后、End 之前、相邻 API group 之间会自动生成处理函数，可以通过在线编写处理函数来添加复杂功能，详见处理函数说明；</li>\n<li>处理函数代码字符串会保存到数据库中。</li>\n<li>点击保存，将聚合函数的入参等请求信息、流程中的处理函数和 API Group 序列化为一个 JSON 字符串保存到数据库。大致的数据结构类似这样：</li>\n</ol>\n<pre class=\"prettyprint language-json\"><code>[\n    &quot;export default function() {&#x2F;&#x2F;...}&quot;,\n    [\n        {&quot;url&quot;: &quot;&#x2F;api&#x2F;getData1&quot;, &quot;method&quot;: &quot;get&quot;, &quot;params&quot;: &quot;a=1&amp;b=2&quot;},\n        {&quot;url&quot;: &quot;&#x2F;api&#x2F;getData2&quot;, &quot;method&quot;: &quot;get&quot;, &quot;params&quot;: &quot;a=1&amp;b=2&quot;}\n    ],\n    &quot;export default function() {&#x2F;&#x2F;...}&quot;,\n    [\n        {&quot;url&quot;: &quot;&#x2F;api&#x2F;getData1&quot;, &quot;method&quot;: &quot;get&quot;, &quot;params&quot;: &quot;a=1&amp;b=2&quot;}\n    ],\n    &quot;export default function() {&#x2F;&#x2F;...}&quot;\n]\n</code></pre><ul>\n<li>node-bff-service</li>\n</ul>\n<p>这是一个服务端应用，可以手动开发聚合接口，也可以根据 node-bff-ui 配置的聚合接口规则，自动返回响应。\n处理流程如下：</p>\n<ol>\n<li>服务器接收到聚合接口的请求；</li>\n<li>如果请求命中了手动开发的接口路由，则进入该路由进行处理；</li>\n<li>否则，看 API Factory UI 配置的聚合接口列表中是否能匹配到该请求，匹配到则执行下一步，还是匹配不到则触发异常处理；</li>\n<li>解析匹配到的聚合接口 JSON（如上代码块），应该是一个数组，依次执行每个元素；</li>\n<li>如果当前元素是 handler，则调用 handler 并传入 context，若有返回值则终止响应，若没有返回值则继续执行下个元素；</li>\n<li>如果当前元素是 API group，首先计算入参部分的表达式，然后调用 axios 发起请求。当请求出现异常时会触发异常处理；</li>\n<li>数组各项执行完毕，进行最终的数据处理，返回响应。</li>\n</ol>\n<h3>处理函数说明</h3>\n<ul>\n<li>代码必须是一个模块，必须要有默认导出。</li>\n<li>默认导出要是一个函数。</li>\n<li>函数总是接收一个入参 <code>context</code>，可以通过 <code>context.$request</code> 获取请求对象，通过 <code>context.${apiName}</code> 获取某个基础接口的响应，也可以通过 <code>context.xxx</code> 添加新的数据供后续流程访问。</li>\n<li>如果函数没有返回值（即返回值为 undefined），则执行完函数后继续往下走。</li>\n<li>如果函数有返回值，则将该值作为聚合函数的响应内容，并终止后续流程。</li>\n<li>函数的返回值必须符合 <code>{code: Number, data: any}</code> 格式，否则触发异常处理。</li>\n<li></li>\n<li>函数可以访问 <code>context</code>、当前作用域的局部变量和相关全局变量，但无法访问浏览器特定的全局变量如 <code>window</code>，也无法引入模块。</li>\n<li>不建议在代码中访问 Node.js 特定的全局变量，因为这不利于在浏览器端对聚合接口及单个的处理函数进行在线调试、单元测试等。</li>\n</ul>\n<h3>处理流程示意图</h3>\n<p><img src=\"https://raw.githubusercontent.com/eshengsky/node-bff/main/assets/chart2.jpg\" alt=\"image\"></p>\n<h3>版本管理及回退</h3>\n<p>每次创建或编辑聚合接口，都会在数据库中创建一条新的接口数据，称为一个版本。\n版本之间可以方便地比较差异。\n调用聚合接口时，默认会调用当前版本，也可以传入如 v1.1.0 调用指定版本的接口。\n支持回退到任意版本，即将指定版本设置为当前版本。</p>\n<ol>\n<li>异常处理</li>\n<li>如果找不到聚合接口，返回响应 {code: 404, message: “服务不存在”, debugMsg: “”}。</li>\n<li>如果命中了聚合接口，不论接口执行过程中是否出现异常，聚合接口最终总是返回一个JSON。</li>\n<li>出现服务端代码执行出错或 handler 执行出错（如值不存在），聚合接口返回响应 {code: 500, message: “内部服务器错误”, debugMsg: “xxx is undefined”}。</li>\n<li>处理函数有返回值但数据结构不符合规定（如 {code: Number, data: any}），会终止后续流程，聚合接口返回响应 {code: 500, message: “内部服务器错误”, debugMsg: “数据结构错误”}。</li>\n<li>当基础接口身份验证不通过，由流程图构建时该基础接口的设置决定如何处理异常。若设置为忽略异常，则即使接口报错也继续后续流程，可以在后续处理函数中自行处理；若设置为验证失败终止执行，则自动终止流程，并返回响应 {code: 403, message: “禁止访问”, debugMsg: “”}。</li>\n<li>除身份验证外的基础接口调用异常（如响应码500或接口超时等），由流程图构建时该基础接口的设置决定如何处理异常。若设置为忽略接口异常，则即使接口报错也继续后续流程，可以在后续处理函数中自行处理；若设置为接口异常终止执行，则聚合接口不再往下处理，而是返回响应 {code: 500, message: “网络错误”, debugMsg: “xxx 接口调用失败，error: xxx”}。</li>\n<li>为提高处理函数内代码的容错率，推荐使用 context.$getValue 方法来安全地获取字段。</li>\n</ol>\n<h3>在线测试</h3>\n<p>由于聚合接口的调用方式、传参等是明确的，故支持在线测试接口，方便地观察接口在各种情况下的响应是否符合预期。可以参考 Yapi 或 Postman 的交互。\n由于 handler 是一个纯函数，故支持对每一个 handler 执行在线单元测试，可以提高代码健壮性，更高效地调试及排查问题。\n测试接口时，可以查看流程图中每一个基础接口的调用情况（请求状态、响应码、响应时长等），并可以通过修改版 ServerLog（待开发）查看实时请求日志。</p>\n<h3>日志</h3>\n<p>可以通过查看服务端日志排查线上问题。\n服务端可以通过接入现有日志平台或通过 pm2 查看；\n请求过程中的日志，如 handler 中的 console、基础接口的入参和响应等，可以接入 ServerLog 以方便在 Chrome 扩展程序中查看。</p>\n<h3>持久化及缓存</h3>\n<p>在 API Factory UI 中创建或修改聚合接口后，会将数据持久化到数据库，同时将该条聚合接口的 path 为 key，JSON 为 value 缓存到 Redis 中。\n持久化的数据和缓存的数据会有一些差异，例如：原始的处理函数才会持久化到数据库，而 Babel 编译后的函数才会缓存到 Redis。\n每次请求进来后，根据请求 path 尝试获取 Redis 中的聚合接口详情，如果有匹配则继续后续流程；如果缓存中没有找到，则接着尝试从数据库中找，如果找到了则继续后续流程，并将该条数据缓存到 Redis 中。如果缓存和数据库中都找不到匹配项，则触发异常处理i。\n考虑再加一个内存 LRU 缓存，将 handler 解析后生成的函数对象缓存起来，避免每次都要 eval 计算。\n<img src=\"https://raw.githubusercontent.com/eshengsky/node-bff/main/assets/chart3.jpg\" alt=\"image\"></p>\n<h3>性能</h3>\n<p>无代码配置化的聚合接口，理论上响应时间可能会比前端直接调用基础接口要长，但应该可以控制在可接受范围内。\n在基础功能实现后会进行专门的性能测试和优化。</p>\n<h3>安全性</h3>\n<p>由于在 BFF 之前会有一层 nginx 服务，运维会做一些安全处理；而在 BFF 内部调用基础服务时依然会走现有的 API 网关，故 BFF 层只需要做一些必要的安全建设即可，例如防范 XSS、阻止 Click Jacking 等。</p>\n<h3>监控及报警</h3>\n<p>通过接入适配后的 pm2-server-monitor 模块，实现对 Node 服务的监控，并通过接入飞书 API，在有错误报警时发送及时消息到飞书。</p>\n<h3>统计分析</h3>\n<p>通过记录接口调用，可以对聚合接口及基础接口进行相关数据统计和分析，如：某一接口在一定时间范围内最大、最小及平均响应时长；一定时间范围内调用次数最多的接口等，为后续优化及决策做数据支撑。</p>\n</div>",
      "title": "基于 Node.js 的可视化 BFF 解决方案",
      "author": {
        "loginname": "eshengsky",
        "avatar_url": "https://avatars.githubusercontent.com/u/9640122?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 141,
      "country": "USA"
    },
    {
      "id": "60ebe55be3e67158c358d474",
      "content": "<div class=\"markdown-text\"><p>原文:<a href=\"https://inviqa.com/blog/how-build-basic-api-typescript-koa-and-typeorm\">How to build a basic API with TypeScript, Koa, and TypeORM</a></p>\n<p>本教程探讨如何使用 TypeScript、Koa 和 TypeORM 构建基本 API。 你需要一个支持 await/async 的 Node.js 版本。</p>\n<p>TypeScript 是一种开源编程语言，在软件开发社区中越来越流行。</p>\n<p>由 Microsoft 开发和维护，它减少了像我这样的软件工程师需要编写的测试数量，并通过在您键入时报告错误来加快开发速度，这要归功于快速和智能的 VSCode 集成。</p>\n<p>本教程将通过演示实现和使用 TypeScript 的简单程度，向您展示 TypeScript 的一些优势。 我们还将探索附加功能（例如类装饰器）如何进一步加速您的开发。</p>\n<p>为此，我们将创建一个简单的 API，用于存储电影名称、发行年份和数字评级。 然后，数据将使用 TypeORM（一种 TypeScript 友好的数据映射器）存储在 PostgreSQL 中。</p>\n<p>这篇文章基于 Node.js 10，但 8 就可以了。 您还需要一个可用的 PostgreSQL 安装。 我们将记录如何通过 Docker 启动和运行它，但如果您没有可用的 Docker，您可以尝试在线服务，例如 <a href=\"https://inviqa.com/blog/how-build-basic-api-typescript-koa-and-typeorm\">ElephantSQL</a>。</p>\n<h3>设置项目</h3>\n<h4>Node 基础</h4>\n<p>首先，我们将创建一个基本的 Node.js 项目。 使用以下命令开始：</p>\n<pre class=\"prettyprint\"><code>mkdir -p typescript-koa &amp;&amp; cd typescript-koa\n</code></pre><p>然后我们要创建 Node.js 项目。 我们可以使用速记，因为我们不会创建一个实时项目：</p>\n<pre class=\"prettyprint\"><code>npm init -y\n</code></pre><p>最后，我们将要获取正常的 Node 依赖项：</p>\n<pre class=\"prettyprint language-npm i -D koa koa-{router,bodyparser} http-status-codes typeorm pg reflect-metadata\"><code></code></pre><p>现在我们已准备好设置 TypeScript。</p>\n<h4>TypeScript 设置</h4>\n<p>我们已经安装了基本的 Node 依赖项，理论上我们现在就可以开始了。 但是我们想要 TypeScript，所以让我们配置它。 我们首先需要一些额外的依赖。 不过，这些只是这次的开发依赖项：</p>\n<pre class=\"prettyprint\"><code>npm i -D typescript ts-node tslint tslint-config-airbnb nodemon\n</code></pre><p>这将为我们提供启动和运行所需的大部分环境。 通常，我会建议不要使用 <a href=\"https://github.com/TypeStrong/ts-node\">ts-node</a> 并提倡使用 Docker，但这只是一个简短的概述，我们现在将使用它。</p>\n<p>最后，我们将要添加我们的类型定义。 以前，我们需要为此使用 <a href=\"https://www.npmjs.com/package/typings\">Typings</a>，但现在我们可以从 <a href=\"/user/types\">@types</a> 组织安装。 如果您想了解更多信息，您绝对应该查看<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">绝对类型</a>的 GitHub 存储库和来自 Microsoft 的 <a href=\"https://microsoft.github.io/TypeSearch/\">TypeSearch</a>。</p>\n<pre class=\"prettyprint\"><code>npm i -D [@types](&#x2F;user&#x2F;types)&#x2F;{node,koa,koa-router,http-status-codes,koa-bodyparser}\n</code></pre><p>安装<a href=\"/user/types\">@types</a>/node 将安装最新版本的类型定义。 如果您运行的是 NodeJS 8，那么您需要在安装时指定您的特定版本。</p>\n<p>我们现在已经拥有了开始所需的一切。 接下来我们需要一个配置文件，让 TypeScript 知道如何处理我们的项目。 在您的存储库根目录中创建一个名为 tsconfig.json 的文件并粘贴以下内容：</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;compilerOptions&quot;: {\n    &quot;target&quot;: &quot;ES2017&quot;,\n    &quot;module&quot;: &quot;commonjs&quot;,\n    &quot;lib&quot;: [&quot;es2017&quot;],\n    &quot;outDir&quot;: &quot;dist&quot;,\n    &quot;rootDir&quot;: &quot;src&quot;,\n    &quot;noImplicitAny&quot;: true,\n    &quot;experimentalDecorators&quot;: true,\n    &quot;emitDecoratorMetadata&quot;: true,\n  }\n}\n</code></pre><p>我们不会深入了解每个设置的作用，但是如果您想了解更多信息，可以运行 node_modules/.bin/tsc --init。 这将创建一个新的配置文件，其中列出了所有可用选项，并附有描述其功能的注释。</p>\n<p>最后，我们将设置 TSLint。 这不是必需的，但这是一个很好的实践。 创建一个名为 tslint.json 的文件并粘贴以下内容：</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;extends&quot;: &quot;tslint-config-airbnb&quot;,\n  &quot;rules&quot;: {\n    &quot;import-name&quot;: false\n  }\n}\n</code></pre><p>这包括 <a href=\"https://www.npmjs.com/package/tslint-config-airbnb\">Airbnb 规则</a>的 <a href=\"https://palantir.github.io/tslint/\">TSLint</a> 版本。我们唯一要删除的是导入名称规则，因为它可能非常严格。</p>\n<p>我们快到了…！</p>\n<h3>设置 Nodemon 以实现无缝服务器重启</h3>\n<p>幸运的是，当我们使用 ts-node 时，这并不复杂，因为我们实际上不需要在每次重启之间编译 TypeScript。</p>\n<p>为了在发生更改时重新启动我们的服务器，我们将使用 Nodemon 监视更改。 另一种选择是 PM2，这在 Docker 容器中开发时特别有用，但这是另一个时间的更大主题。</p>\n<p>我的偏好是将其配置保存在一个单独的文件中； 创建一个 nodemon.json 文件并添加以下内容：</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;watch&quot;: [&quot;src&quot;],\n  &quot;exec&quot;: &quot;npm run serve&quot;,\n  &quot;ext&quot;: &quot;ts&quot;\n}\n</code></pre><p>这将监视 src 目录中 .ts 文件的任何更改，然后运行 npm run start。 这意味着我们需要在 package.json 中设置一个启动脚本。 打开你的 package.json 并添加以下脚本：</p>\n<pre class=\"prettyprint\"><code>&quot;scripts&quot;: {\n  &quot;lint&quot;: &quot;tslint --project tsconfig.json --format stylish&quot;,\n  &quot;build&quot;: &quot;tsc&quot;,\n  &quot;serve&quot;: &quot;ts-node src&#x2F;server.ts&quot;,\n  &quot;start&quot;: &quot;nodemon&quot;\n}\n</code></pre><p>在这里，我们向 lint 添加了一个脚本，以防您选择的编辑器没有自动执行（就个人而言，我使用带有 <a href=\"https://marketplace.visualstudio.com/items?itemName=eg2.tslint\">TSLint</a> 扩展的 VSCode）。</p>\n<p>我们还添加了一个通用的 serve 命令来运行服务器。 此命令不会监视更改或重新启动。</p>\n<p>最后，我们使启动脚本直接指向 nodemon。 然后，Nodemon 将在任何更改时依次运行（并重新运行）npm serve。</p>\n<p>如前所述，由于我们使用的是 ts-node，因此我们根本不需要编译。 也就是说，我们已经添加了一个构建命令。 这意味着您的项目可以通过 npm run SCRIPT（即 npm run lint）直接从 npm 运行。 我们也可以跳过启动脚本的运行部分，通过运行 npm start 来启动我们的项目。</p>\n<p>###在 Docker 中设置 PostgreSQL（可选）\n因为我们将使用 PostgreSQL 作为我们 API 的数据库，所以我们需要一个可用的安装。 为此，我们将使用 Docker。 如果你已经在本地安装了 PostgreSQL，或者你已经配置了一个外部服务，那么你可以跳过这一步。</p>\n<p>创建一个 Docker Compose 文件。 在您的项目根目录中创建一个文件名 docker-compose.yml，并添加以下内容：</p>\n<pre class=\"prettyprint\"><code>version: &#x27;3&#x27;\n\nservices:\n\n  database:\n    image: postgres:11-alpine\n    restart: always\n    expose:\n      - &quot;5432&quot;\n    ports:\n      - &quot;5432:5432&quot;\n    environment:\n      POSTGRES_DB: typescript-koa\n\n  adminer:\n    image: adminer:latest\n    restart: always\n    ports:\n      - &quot;8080:8080&quot;\n    environment:\n      ADMINER_DEFAULT_SERVER: database\n      ADMINER_DESIGN: lucas-sandery\n</code></pre><p>这将使 PostgreSQL 在端口 5432 上本地可用，并且 <a href=\"https://www.adminer.org/\">Adminer</a> 管理 GUI 在 <a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a> 上可用，一旦容器启动，我们将在稍后进行。</p>\n<p>现在我们准备好写一些代码了！</p>\n<h3>构建我们的 API</h3>\n<h4>准备好 Koa</h4>\n<p>我们要做的第一件事是运行一个基本的 <a href=\"https://koajs.com/\">Koa</a> 应用程序。 我们将要创建的应用程序将允许我们存储电影名称、发行日期和数字评级。</p>\n<p>运行以下命令以创建应用程序文件：</p>\n<pre class=\"prettyprint\"><code>mkdir -p src&#x2F;app &amp;&amp; touch src&#x2F;app&#x2F;app.ts\n</code></pre><p>这是我们将在其中创建基本应用程序的文件。 在此文件中，添加以下代码：</p>\n<pre class=\"prettyprint\"><code>import * as Koa from &#x27;koa&#x27;;\nimport * as HttpStatus from &#x27;http-status-codes&#x27;;\n\nconst app:Koa = new Koa();\n\n&#x2F;&#x2F; Generic error handling middleware.\napp.use(async (ctx: Koa.Context, next: () =&gt; Promise&lt;any&gt;) =&gt; {\n  try {\n    await next();\n  } catch (error) {\n    ctx.status = error.statusCode || error.status || HttpStatus.INTERNAL_SERVER_ERROR;\n    error.status = ctx.status;\n    ctx.body = { error };\n    ctx.app.emit(&#x27;error&#x27;, error, ctx);\n  }\n});\n\n&#x2F;&#x2F; Initial route\napp.use(async (ctx:Koa.Context) =&gt; {\n  ctx.body = &#x27;Hello world&#x27;;\n});\n\n&#x2F;&#x2F; Application error logging.\napp.on(&#x27;error&#x27;, console.error);\n\nexport default app;\n</code></pre><p>Koa 完全基于中间件。 上面的代码创建了一个 Koa 实例，并添加了一小块自定义中间件来稍微改进我们的错误日志记录。 对于实际应用程序，您可能需要更健壮的东西，但这对我们来说非常有用。</p>\n<p>您会注意到我们也在导出应用程序。 这有两个目的：</p>\n<ol>\n<li>它使我们的应用程序保持模块化，并且不会将我们的应用程序定义与服务器的运行联系起来。</li>\n<li>它使我们能够更轻松地测试应用程序。</li>\n</ol>\n<p>要启动我们的服务器运行，请在 src 目录中创建一个名为 server.ts 的文件：touch src/server.ts。</p>\n<p>在这个文件中，我们将导入我们的应用程序并启动服务器。 为此，我们需要以下代码：</p>\n<pre class=\"prettyprint\"><code>import app from &#x27;.&#x2F;app&#x2F;app&#x27;;\n\n&#x2F;&#x2F; Process.env will always be comprised of strings, so we typecast the port to a\n&#x2F;&#x2F; number.\nconst PORT:number = Number(process.env.PORT) || 3000;\n\napp.listen(PORT);\n</code></pre><p>如果你现在运行 npm start，Nodemon 应该启动我们的服务器监听 3000 端口。如果你访问 127.0.0.1:3000 你应该会看到一个很好的“Hello world”。</p>\n<p>这一切都很好，但是我们将如何创建具有单一端点的movies？</p>\n<h4>Adding our routes</h4>\n<p>要添加我们的路由，我们需要使用 <a href=\"https://www.npmjs.com/package/koa-router\">koa-router</a>。</p>\n<blockquote>\n<p>Koa 不附带开箱即用的路由器，而是让您以比其他框架更加模块化的方式组合应用程序。 – <a href=\"http://Koajs.com\">Koajs.com</a></p>\n</blockquote>\n<p>为了便于使用，我们将在单独的文件中创建我们的路由：</p>\n<pre class=\"prettyprint\"><code>mkdir src&#x2F;movie &amp;&amp; touch src&#x2F;movie&#x2F;movie.controller.ts\n</code></pre><p>打开这个文件，粘贴以下代码：</p>\n<pre class=\"prettyprint\"><code>import * as Koa from &#x27;koa&#x27;;\nimport * as Router from &#x27;koa-router&#x27;;\n\nconst routerOpts: Router.IRouterOptions = {\n  prefix: &#x27;&#x2F;movies&#x27;,\n};\n\nconst router: Router = new Router(routerOpts);\n\nrouter.get(&#x27;&#x2F;&#x27;, async (ctx:Koa.Context) =&gt; {\n  ctx.body = &#x27;GET ALL&#x27;;\n});\n\nrouter.get(&#x27;&#x2F;:movie_id&#x27;, async (ctx:Koa.Context) =&gt; {\n  ctx.body = &#x27;GET SINGLE&#x27;;\n});\n\nrouter.post(&#x27;&#x2F;&#x27;, async (ctx:Koa.Context) =&gt; {\n  ctx.body = &#x27;POST&#x27;;\n});\n\nrouter.delete(&#x27;&#x2F;:movie_id&#x27;, async (ctx:Koa.Context) =&gt; {\n  ctx.body = &#x27;DELETE&#x27;;\n});\n\nrouter.patch(&#x27;&#x2F;:movie_id&#x27;, async (ctx:Koa.Context) =&gt; {\n  ctx.body = &#x27;PATCH&#x27;;\n});\n\nexport default router;\n</code></pre><p>这定义了我们的路线。 你会注意到我们设置了 /movies 的前缀。 这样当我们将路由挂载到应用程序中时，我们根本不需要在应用程序级别添加任何配置。 如果我们想把这个功能拆分成它自己的包，或者移动它，我们可以移动它。</p>\n<p>如果您使用过 Express，您可能能够理解正在发生的事情。 路由器对象上有一些方法代表将用于我们的 API 的 HTTP 动词，然后是回调。 新的可能是回调是异步函数。</p>\n<blockquote>\n<p>通过利用异步函数，Koa 允许您放弃回调并大大增加错误处理。-- <a href=\"http://Koajs.com\">Koajs.com</a></p>\n</blockquote>\n<p>接下来，我们需要让这个控制器对应用程序可用。 在 app.js 的顶部，导入电影控制器：</p>\n<pre class=\"prettyprint\"><code>import movieController from &#x27;..&#x2F;movie&#x2F;movie.controller&#x27;;\n</code></pre><p>然后删除我们默认的“Hello world”端点，并将其替换为以下内容：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; Route middleware.\napp.use(movieController.routes());\napp.use(movieController.allowedMethods());\n</code></pre><p>.routes() 部分将路由中间件添加到应用程序，而 .allowedMethods() 函数将添加另一块中间件，以确保对不允许或未实现的方法给出正确的响应。</p>\n<p>如果您现在使用上述任何 HTTP 动词向我们的 API 发出任何请求，您应该会收到一个响应，其中提到了您发出的请求的类型。</p>\n<p>好东西！ 现在我们需要添加我们的数据库后端。</p>\n<h3>实现我们的持久层</h3>\n<h4>添加数据库连接</h4>\n<p>此部分需要 PostgreSQL 数据库。 如果您已经在上面设置了 dockerfile，那么现在是在新的终端窗口中运行 docker-compose up 的好时机。 如果您在其他地方创建了数据库，请确保您手头有凭据。</p>\n<p>我们需要做的第一件事是建立我们的数据库连接。 运行以下命令以创建我们将在其中存储数据库凭据的文件：</p>\n<pre class=\"prettyprint\"><code>mkdir src&#x2F;database &amp;&amp; touch src&#x2F;database&#x2F;database.connection.ts\n</code></pre><p>打开此文件并粘贴以下内容：</p>\n<pre class=\"prettyprint\"><code>import &#x27;reflect-metadata&#x27;;\nimport { createConnection, Connection, ConnectionOptions } from &#x27;typeorm&#x27;;\nimport { join } from &#x27;path&#x27;;\nconst parentDir = join(__dirname, &#x27;..&#x27;);\n\nconst connectionOpts: ConnectionOptions = {\n  type: &#x27;postgres&#x27;,\n  host: process.env.DB_HOST || &#x27;localhost&#x27;,\n  port: Number(process.env.DB_PORT) || 5432,\n  username: process.env.DB_USERNAME || &#x27;postgres&#x27;,\n  password: process.env.DB_PASSWORD || &#x27;postgres&#x27;,\n  database: process.env.DB_NAME || &#x27;typescript-koa&#x27;,\n  entities: [\n    &#96;${parentDir}&#x2F;**&#x2F;*.entity.ts&#96;,\n  ],\n  synchronize: true,\n};\n\nconst connection:Promise&lt;Connection&gt; = createConnection(connectionOpts);\n\nexport default connection;\n</code></pre><p>这个文件使用 <a href=\"http://typeorm.io/#/\">TypeORM</a> 创建我们的连接。 您可以在<a href=\"http://typeorm.io/#/connection-options\">此处</a>找到所有配置选项的文档。</p>\n<p>我们也导出了这个，所以我们可以把它拉到我们的引导 server.ts 文件中。 如果您正在运行自己的 PostgreSQL 实例，则可以更改上面的默认连接详细信息。</p>\n<p>我们设置它的方式允许环境变量成为默认的真实来源，并且我们有非敏感的本地凭据作为备份。</p>\n<p>附带说明一下，如果您直接通过 NodeJS 运行应用程序，并将 .ts 文件转换为 JavaScript，则需要将 ${parentDir}/*<em>/</em>.entity.js 添加到实体列表中。</p>\n<p>接下来，重新访问 server.ts 并将内容更改为以下内容：</p>\n<pre class=\"prettyprint\"><code>import app from &#x27;.&#x2F;app&#x2F;app&#x27;;\nimport databaseConnection from &#x27;.&#x2F;database&#x2F;database.connection&#x27;;\n\nconst PORT:number = Number(process.env.PORT) || 3000;\n\ndatabaseConnection\n  .then(() =&gt; app.listen(PORT))\n  .catch(console.error);\n</code></pre><p>我们创建的连接返回一个承诺。 由于我们的应用程序依赖于一个数据库，我们可以安全地在数据库连接的成功回调中启动服务器。</p>\n<h4>定义数据模型</h4>\n<p>TypeORM 将其数据模型称为实体。 实体是用 TypeScript 装饰器包装以添加底层功能的类。 它与 [Doctrine](<a href=\"https://www.doctrine-project.org/\">https://www.doctrine-project.org/</a> 在 PHP 中的工作方式非常相似。 我们的演示只需要一个实体，所以我们接下来要创建一个实体类：</p>\n<pre class=\"prettyprint\"><code>touch src&#x2F;movie&#x2F;movie.entity.ts\n</code></pre><p>在此文件中，粘贴以下代码：</p>\n<pre class=\"prettyprint\"><code>import { Entity, PrimaryGeneratedColumn, Column } from &#x27;typeorm&#x27;;\n\n@Entity()\nexport default class Movie {\n\n  @PrimaryGeneratedColumn(&#x27;uuid&#x27;)\n  id: string;\n\n  @Column({ unique: true })\n  name: string;\n\n  @Column({ type: &#x27;int&#x27;, nullable: true, width: 4 })\n  releaseYear: number;\n\n  @Column({ type: &#x27;int&#x27;, nullable: true })\n  rating: number;\n\n}\n</code></pre><p>信不信由你，这是我们能够访问整个持久层所需的唯一数据。 查看<a href=\"http://typeorm.io/#/entities\">官方文档</a>以了解有关创建实体的所有不同选项的更多信息。</p>\n<p>保存完所有内容并重新启动服务器后，您应该注意到我们的数据库中现在有一个电影表！ 这意味着是时候更新我们的路线了。</p>\n<h3>持续更新路由</h3>\n<p>我们需要做的最后一件事是使用持久化、编辑和删除电影实体所需的功能更新我们的路由。</p>\n<p>访问我们的原始 app.ts 文件，并在顶部粘贴以下内容以导入正文解析器：</p>\n<pre class=\"prettyprint\"><code>import * as bodyParser from &#x27;koa-bodyparser&#x27;;\n</code></pre><p>这是 Koa 能够读取请求正文所必需的。 在路由use 调用之前，我们还需要添加以下内容：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; Middleware\napp.use(bodyParser());\n</code></pre><p>再次打开 movie.controller.ts 并将所有内容替换为以下代码（这是一个相当大的片段，因此已添加注释以帮助说明发生了什么）：</p>\n<pre class=\"prettyprint\"><code>import * as Koa from &#x27;koa&#x27;;\nimport * as Router from &#x27;koa-router&#x27;;\nimport { getRepository, Repository } from &#x27;typeorm&#x27;;\nimport movieEntity from &#x27;.&#x2F;movie.entity&#x27;;\nimport * as HttpStatus from &#x27;http-status-codes&#x27;;\n\nconst routerOpts: Router.IRouterOptions = {\n  prefix: &#x27;&#x2F;movies&#x27;,\n};\n\nconst router: Router = new Router(routerOpts);\n\nrouter.get(&#x27;&#x2F;&#x27;, async (ctx:Koa.Context) =&gt; {\n  &#x2F;&#x2F; Get the movie repository from TypeORM.\n  const movieRepo:Repository&lt;movieEntity&gt; = getRepository(movieEntity);\n\n  &#x2F;&#x2F; Find the requested movie.\n  const movies = await movieRepo.find();\n\n  &#x2F;&#x2F; Respond with our movie data.\n  ctx.body = {\n    data: { movies },\n  };\n});\n\nrouter.get(&#x27;&#x2F;:movie_id&#x27;, async (ctx:Koa.Context) =&gt; {\n  &#x2F;&#x2F; Get the movie repository from TypeORM.\n  const movieRepo:Repository&lt;movieEntity&gt; = getRepository(movieEntity);\n\n  &#x2F;&#x2F; Find the requested movie.\n  const movie = await movieRepo.findOne(ctx.params.movie_id);\n\n  &#x2F;&#x2F; If the movie doesn&#x27;t exist, then throw a 404.\n  &#x2F;&#x2F; This will be handled upstream by our custom error middleware.\n  if (!movie) {\n    ctx.throw(HttpStatus.NOT_FOUND);\n  }\n\n  &#x2F;&#x2F; Respond with our movie data.\n  ctx.body = {\n    data: { movie },\n  };\n});\n\nrouter.post(&#x27;&#x2F;&#x27;, async (ctx:Koa.Context) =&gt; {\n  &#x2F;&#x2F; Get the movie repository from TypeORM.\n  const movieRepo:Repository&lt;movieEntity&gt; = getRepository(movieEntity);\n\n  &#x2F;&#x2F; Create our new movie.\n  const movie: movieEntity = movieRepo.create(ctx.request.body);\n\n  &#x2F;&#x2F; Persist it to the database.\n  await movieRepo.save(movie);\n\n  &#x2F;&#x2F; Set the status to 201.\n\n  &#x2F;&#x2F; Respond with our movie data.ctx.status = HttpStatus.CREATED;\n  ctx.body = {\n    data: { movie },\n  };\n});\n\nrouter.delete(&#x27;&#x2F;:movie_id&#x27;, async (ctx:Koa.Context) =&gt; {\n  &#x2F;&#x2F; Get the movie repository from TypeORM.\n  const movieRepo:Repository&lt;movieEntity&gt; = getRepository(movieEntity);\n\n  &#x2F;&#x2F; Find the requested movie.\n  const movie = await movieRepo.findOne(ctx.params.movie_id);\n\n  &#x2F;&#x2F; If the movie doesn&#x27;t exist, then throw a 404.\n  &#x2F;&#x2F; This will be handled upstream by our custom error middleware.\n  if (!movie) {\n    ctx.throw(HttpStatus.NOT_FOUND);\n  }\n\n  &#x2F;&#x2F; Delete our movie.\n  await movieRepo.delete(movie);\n\n  &#x2F;&#x2F; Respond with no data, but make sure we have a 204 response code.\n  ctx.status = HttpStatus.NO_CONTENT;\n});\n\nrouter.patch(&#x27;&#x2F;:movie_id&#x27;, async (ctx:Koa.Context) =&gt; {\n  &#x2F;&#x2F; Get the movie repository from TypeORM.\n  const movieRepo:Repository&lt;movieEntity&gt; = getRepository(movieEntity);\n\n  &#x2F;&#x2F; Find the requested movie.\n  const movie:movieEntity = await movieRepo.findOne(ctx.params.movie_id);\n\n  &#x2F;&#x2F; If the movie doesn&#x27;t exist, then throw a 404.\n  &#x2F;&#x2F; This will be handled upstream by our custom error middleware.\n  if (!movie) {\n    ctx.throw(HttpStatus.NOT_FOUND);\n  }\n\n  &#x2F;&#x2F; Merge the existing movie with the new data.\n  &#x2F;&#x2F; This allows for really simple partial (PATCH).\n  const updatedMovie = await movieRepo.merge(movie, ctx.request.body);\n\n  &#x2F;&#x2F; Save the new data.\n  movieRepo.save(updatedMovie);\n\n\n  &#x2F;&#x2F; Respond with our movie data.&#x2F;&#x2F; Response with the updated content.\n  ctx.body = {\n    data: { movie: updatedMovie },\n  };\n});\n\nexport default router;\n</code></pre><p>以上使 GET、POST、PATCH 和 DELETE 端点能够与我们的电影实体进行交互。</p>\n<p>这应该就是我们需要的一切！</p>\n<p>您可以通过发出 POST 请求来测试我们的新 API。</p>\n<p>使用 Insomnia 或 Postman（或类似工具），使用以下数据构建请求并将其发送到 <a href=\"http://127.0.0.1:3000/movies%EF%BC%9A\">http://127.0.0.1:3000/movies：</a></p>\n<pre class=\"prettyprint\"><code>{\n  &quot;name&quot;: &quot;Main in Manhattan&quot;,\n  &quot;releaseYear&quot;: 2002,\n  &quot;rating&quot;: 10\n}\n</code></pre><p>您应该返回电影实例。 记下 UUID，我们可以使用它来构建对 <a href=\"http://127.0.0.1:3000/movies/%7BUUID%7D\">http://127.0.0.1:3000/movies/{UUID}</a> 的 GET 请求。</p>\n<h3>总结</h3>\n<p>TypeScript 可以大大提高大中型应用程序的生产力。 从我的个人经验的角度来看，它减少了我必须编写的测试数量大约三分之一，并捕获类型错误——实际上是在我输入时，而不是在测试端点时。</p>\n<p>我也是最近才尝试 TypeORM，从 Mongoose 转移过来。 虽然 Mongoose 很有趣并且使用起来相对简单，但是使用 TypeScript 启动和运行（以及一般情况下）需要很多样板。</p>\n<p>TypeORM 是一股清新的空气，它的使用速度快得令人难以置信。 希望本教程有助于证明这一点。</p>\n<p>您可以在<a href=\"https://github.com/Chapabu/typescript-koa-article\">此处</a>找到上述文章的代码。</p>\n</div>",
      "title": "【翻译】How to build a basic API with TypeScript, Koa, and TypeORM",
      "author": {
        "loginname": "gocpplua",
        "avatar_url": "https://avatars.githubusercontent.com/u/46804866?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 142,
      "country": "Japan"
    },
    {
      "id": "58aeee58e418a986315f3882",
      "content": "<div class=\"markdown-text\"><p>大家一起去申诉：\n<a href=\"http://www.chinatcc.gov.cn\">http://www.chinatcc.gov.cn</a></p>\n</div>",
      "title": "听说GitHub被封了？这可咋办呀？",
      "author": {
        "loginname": "zhanzhenzhen",
        "avatar_url": "https://avatars3.githubusercontent.com/u/731796?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 143,
      "country": "Japan"
    },
    {
      "id": "6138ebaafe0c5101e6ae9505",
      "content": "<div class=\"markdown-text\"><h1>download:<a href=\"http://www.97yrbl.com/t-653.html?_dsign=4dacffff\">前端主流布局系统进阶与实战</a></h1>\n<p>实现精美页面是前端工程师的核心能力之一，CSS布局技术是实现精美页面的核心技术，但CSS布局好入门，难精通。本课将围绕前端4大主流布局，通过大量的实际案例，带你边学习，边实操，让你系统掌握CSS布局进阶技术，轻松解决各种精美页面布局难题。</p>\n<p>适合人群\n懂一些HTML、CSS基础的前端小白\n刚毕业找工作的学生\n需要大量布局工作的前端或后端开发\n技术储备\nHTML基础\nCSS基础</p>\n</div>",
      "title": "前端主流布局系统进阶与实战",
      "author": {
        "loginname": "woaimizainali",
        "avatar_url": "https://avatars.githubusercontent.com/u/89630901?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 144,
      "country": "Japan"
    },
    {
      "id": "613875abfe0c51b20dae93bc",
      "content": "<div class=\"markdown-text\"><p>「快写鸭」是一款专为开发者开发的一站式写作、管理、发布的更简单且下载即用的效率工具，去除繁琐配置但又极具丰富且自定义性质等功能。</p>\n<h2>💡效率更高效</h2>\n<blockquote>\n<p>程序员和技术人员常常会写「技术文章」和「博客」，用作「技术分享」、「产品分享」或「提供咨询」等等。</p>\n</blockquote>\n<ul>\n<li>技术博主通常需要在多个媒体渠道发布文章，诸如「掘金」、「SegmentFault」、「CSDN」、「知乎」、「简书」、「微信公众号」等等，以求最大的关注度。但是，发布文章到这么多平台费时费神，需要不断地复制粘贴和修改排版；同时，作者想查看阅读数时还需要来回切换各个网站来进行「统计」(To be continue…)。这非常不方便。「快写鸭」主要就是为了来解决上述这些问题的。</li>\n<li>一方面，市面上已经存在「一文多发」平台了，例如 「OpenWrite」，为何还要搞这个软件呢？或许其他一文多发平台也是一个替代方案，但它们要求用户将自己的账户信息例如 「Cookie」 或「账号密码」上传到对方服务器，这很不安全，一旦平台发生问题，自己的账户信息会遭到泄漏。虽然我相信一般平台不会恶意操作用户的账户，但如果出现误操作，您的账户「隐私」将遭到「泄漏」，平台上的财产也可能遭到损坏，有这样的风险需要考虑。「快写鸭」不提供任何接口保存用户账号信息，所有账户信息全部保存在用户自己的本地数据库里，因此规避了这个安全风险。</li>\n<li>另一方面，相对还有其他的一文多发平台，都存在一个问题就是「安装繁琐」，或者「占用内存大」，无法立即使用发布功能，因此「快写鸭」就诞生了。</li>\n</ul>\n<h2>发布原理</h2>\n<p>通过 「 Electron 」 和 「 Puppeteer 」的通信，编写「自动化脚本」来进行一键发布。</p>\n<h2>🦆功能介绍</h2>\n<p>快写鸭正在快速地开发中，如果你有好的建议可以随时找我哦~</p>\n<h3><a href=\"https://www.yuque.com/daolong/kxy/bhsrz1\">管理渠道</a></h3>\n<p><a href=\"https://imgtu.com/i/h7enVH\"><img src=\"https://z3.ax1x.com/2021/09/08/h7enVH.png\" alt=\"管理渠道.png\"></a></p>\n<h3><a href=\"https://www.yuque.com/daolong/kxy/qeq3lw\">管理文章</a></h3>\n<p><a href=\"https://imgtu.com/i/h7eVKO\"><img src=\"https://z3.ax1x.com/2021/09/08/h7eVKO.png\" alt=\"管理文章.png\"></a></p>\n<h3><a href=\"https://www.yuque.com/daolong/kxy/dzzca0\">发布文章</a></h3>\n<p><a href=\"https://imgtu.com/i/h7euad\"><img src=\"https://z3.ax1x.com/2021/09/08/h7euad.png\" alt=\"发布文章.png\"></a></p>\n<h3><a href=\"https://www.yuque.com/daolong/kxy/cypc4u\">自定义渠道</a></h3>\n<p><a href=\"https://imgtu.com/i/h7eZrD\"><img src=\"https://z3.ax1x.com/2021/09/08/h7eZrD.png\" alt=\"自定义渠道.png\"></a></p>\n<blockquote>\n<p>更丰富的功能介绍，<a href=\"https://www.yuque.com/daolong/kxy\">点击跳转</a>。</p>\n</blockquote>\n<h2>如何下载</h2>\n<p>Github地址：<a href=\"https://github.com/oncework/kuaixieya\">https://github.com/oncework/kuaixieya</a></p>\n<p>下载地址：<a href=\"https://github.com/oncework/kuaixieya/releases\">https://github.com/oncework/kuaixieya/releases</a></p>\n</div>",
      "title": "「快写鸭」一文多发新工具，让分享技术更简单",
      "author": {
        "loginname": "xudaolong",
        "avatar_url": "https://avatars.githubusercontent.com/u/9654838?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 145,
      "country": "Japan"
    },
    {
      "id": "613822edfe0c515e5dae9213",
      "content": "<div class=\"markdown-text\"><p>登入可以用session模块管理。用户访问资源权限，接口怎么控制？针对每个接口写感觉有点僵硬。有什么好的设计思想？</p>\n</div>",
      "title": "后端权限接口如何实现",
      "author": {
        "loginname": "qian-ryan",
        "avatar_url": "https://avatars.githubusercontent.com/u/44833789?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 146,
      "country": "Japan"
    },
    {
      "id": "6138250cfe0c513c95ae923a",
      "content": "<div class=\"markdown-text\"><p>deviceSchema.post(“remove”, function (device, next) {\nConnection.deleteMany({device: device._id}).<em>exec()</em>\nDeviceACL.deleteMany({broker_username: device.broker_username}).<em>exec()</em>\nnext()\n})\n我想问一下，这个mongoose中的exec在什么情况下，才用它，我对它不是很理解，哪位高手指点一下小的？</p>\n</div>",
      "title": "mongoose中的exec怎样理解",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 147,
      "country": "USA"
    },
    {
      "id": "6135b04ffe0c514a33ae8ca7",
      "content": "<div class=\"markdown-text\"><p>var express = require(‘express’);\nvar router = express.Router();\nvar Device = require(&quot;…/models/device&quot;)\nvar messageService = require(&quot;…/services/message_service&quot;)</p>\n<p>router.post(&quot;/&quot;, function (req, res) {\nswitch (<em>req.body.action</em>){\ncase “client_connected”:\nDevice.addConnection(req.body)\nbreak\ncase “client_disconnected”:\nDevice.removeConnection(req.body)\nbreak;\ncase “message_publish”:\nmessageService.dispatchMessage({\ntopic: <em>req.body.topic</em>,\npayload: new Buffer(<em>req.body.payload</em>, ‘base64’),\nts: req.body.ts\n})\n}\nres.status(200).send(“ok”)\n})</p>\n<p>module.exports = router\n我想问一下这段代码的req.body后面带的topic,payload,action这些属性在哪里能查到它的具体用途，在官网http://expressjs.com/en/4x/api.html#req.body没找到。</p>\n</div>",
      "title": "express中的req.body后面附带属性是什么意思",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 148,
      "country": "China"
    },
    {
      "id": "61376833fe0c512029ae9135",
      "content": "<div class=\"markdown-text\"><p>好长时间不用jquqery了，现在网上搜jquery 全是jquery3的新特性\njquery2.x有什么新功能还没怎么用就被错过了？</p>\n</div>",
      "title": "jquery2.x  有什么新增的功能特点吗？",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 149,
      "country": "Eurozone"
    },
    {
      "id": "612a7ad1fe0c5183d3ae7908",
      "content": "<div class=\"markdown-text\"><p>现在在做组件库按需引入打包，每个组件作为一个entry入口，和一些开源基础组件库不同，我们组件库的一些依赖里面有require.ensure按需加载语法，导致一些组件打包出来的文件出了组件本身chunk，还有按需加载模块的chunk，我都已经把splitchunk提取公共代码机制给关了，但根据webpack的机制似乎按需加载的模块就是会单独作为一个chunk，所以应该怎么解决或有什么插件可以使一个entry入口无论是否有多少按需加载模块都打包成一个chunk</p>\n</div>",
      "title": "webpack多入口打包怎么一个入口对应一个chunk",
      "author": {
        "loginname": "ch8839",
        "avatar_url": "https://avatars.githubusercontent.com/u/44232902?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 150,
      "country": "Eurozone"
    },
    {
      "id": "611775a0baed4e9cdfb83243",
      "content": "<div class=\"markdown-text\"><p>var express = require(‘express’);\n<strong><em>var app = express();</em></strong>\nmongoose.connect( <code>mongodb://iot:iot@localhost:27017/iothub</code>, { useNewUrlParser: true })</p>\n<p>// view engine setup\napp.set(‘views’, path.join(__dirname, ‘views’));\napp.set(‘view engine’, ‘jade’);</p>\n<p>app.use(logger(‘dev’));\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, ‘public’)));</p>\n<p>app.use(’/devices’, deviceRouter);\napp.use(’/tokens’, tokensRouter);\napp.use(’/emqx_web_hook’, webHookeRouter)\napp.use(’/messages’, messageRouter)\napp.use(’/tags’, tagsRouter)\napp.use(’/ota’, otaRouter)</p>\n<p>// catch 404 and forwa有rd to error handler\napp.use(function(req, res, next) {\nnext(createError(404));\n});</p>\n<p>// error handler\napp.use(function(err, req, res, next) {\n// set locals, only providing error in development\nres.locals.message = err.message;\nres.locals.error = req.app.get(‘env’) === ‘development’ ? err : {};</p>\n<p>// render the error page\nres.status(err.status || 500);\nres.render(‘error’);\n});</p>\n<p>module.exports = app;\n我想问一下怎样理解这段代码中的var app = express()和它下面的代码之间的关系，是不是在这个之后的代码最后都会被封装进app中去，包括ongoose.connect( <code>mongodb://iot:iot@localhost:27017/iothub</code>, { useNewUrlParser: true })这段代码，然后我想再问一下，如果有另外的文件调用这个导出的模块时，var app = express(）后面的代码是怎样执行的？</p>\n</div>",
      "title": "我想问一下怎样理解这段代码中的var app = express()和它下面的代码之间的关系",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 151,
      "country": "Eurozone"
    },
    {
      "id": "61306189fe0c51bee0ae851b",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-js\"><code>const fs = require(&#x27;fs&#x27;)\nvar text\nfs.readFile(&#x27;.&#x2F;test.txt&#x27;, {encoding:&#x27;&#x27;}, function(err, data){\n    if(err){\n        console.log(err);\n    }else{\n        text = data.toString()\n        console.log(data.toString());\n    }   \n});\nconsole.log(&#x27;This is the end.&#x27;)\nconsole.log(&#x27;out:&#x27;,text)\n</code></pre><p>输出</p>\n<pre class=\"prettyprint language-js\"><code>This is the end.\nout: undefined\nThis is a test file. \n</code></pre><p>怎么让那个out等到text被赋值了再输出啊</p>\n</div>",
      "title": "想问，怎么把callback函数的内容拿出来。。",
      "author": {
        "loginname": "nichousha233",
        "avatar_url": "https://avatars.githubusercontent.com/u/51410285?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 152,
      "country": "China"
    },
    {
      "id": "6131e743fe0c514c03ae8908",
      "content": "<div class=\"markdown-text\"><p>都为哪些项目捐过款呢</p>\n</div>",
      "title": "习惯统计----各位有在opencollective上为开源项目捐款的习惯吗。。",
      "author": {
        "loginname": "ganshiqingyuan",
        "avatar_url": "https://avatars.githubusercontent.com/u/33950951?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 153,
      "country": "USA"
    },
    {
      "id": "6131d255fe0c51d485ae8880",
      "content": "<div class=\"markdown-text\"><p>目前的项目是一个单体应用，由于用户基数不大，因此很多第三方服务都是直接由业务端直接接入。现在要接入内容审核的服务，考虑到不需要实时处理审核结果和减轻业务端的压力，想要将其抽离业务端，想请教各位有无比较好的实现方案？</p>\n</div>",
      "title": "单体应用中，如何将服务剥离业务？",
      "author": {
        "loginname": "gxsandzxl",
        "avatar_url": "https://avatars.githubusercontent.com/u/35101675?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 154,
      "country": "Eurozone"
    },
    {
      "id": "6130bb67fe0c511308ae86de",
      "content": "<div class=\"markdown-text\"><p>最近写了个小玩意，可以根据 HTTP 响应的 JSON 数据，自动生成 TS 类型文件。。\n做之前也没调研清楚，花了些时间搞完了之后，发现现在大家似乎都是用 swagger 的一些工具，来自动生成 TS 类型文件。。。欲哭无泪，想着不能白搞，如果有些内容对大家有所启发也是极好的，遂还是写篇文章，讲讲过程。</p>\n<h2>前言</h2>\n<p>使用 TypeScript 开发前端项目，完善的类型批注是非常提升开发效率的。然而，当遇到 Restful，似乎只能为 Restful 返回的 JSON 数据手动书写类型，随着接口越来越多，手写类型是繁琐且低效的。 有没有一种简单的方式，可以拿到返回数据的类型呢？</p>\n<h2>JSON 类型文件生成</h2>\n<p>首先，我们目前前后端分离的开发模式中，接口响应数据一般都是 JSON 格式的，那怎么为 JSON 数据生成 TS 类型？</p>\n<h3>JSON 类型</h3>\n<p>Json 中数据类型有 6 种: string 、number、boolean、array、object、null</p>\n<p>其中 string、number、boolean 的类型可以直接使用 <code>typeof</code> 判别类型。</p>\n<p>null 有些复杂，它可能是其他 5 中类型中的一种，无法判断具体是什么类型，因而只能填充 any</p>\n<p>对于 object，它可能由 Json 的 6 种数据结构组成，可以使用递归遍历的方式，来判断 value 的类型</p>\n<p>而对于 array ，array 中的每一项数据结构应当都是相同的，因而只需要取出第一项进行处理，处理逻辑与上述几种类型相同。</p>\n<h3>文件生成</h3>\n<p>可以使用 node fs api，利用拼接字符串的形式，将 JSON 类型处理后，输出到类型文件中。这样简单且有效，但不那么优雅，且易出错。</p>\n<p>可以借助 <a href=\"https://ts-morph.com/\">ts-morph</a> 这个库，来完成类型的生成和导出。</p>\n<p>ts-morph 使用伪代码如下:</p>\n<pre class=\"prettyprint language-text\"><code>const project = createProject()\nproject.addInterface({ name, value }).setIsExport(true)\nsaveProject(project)\n</code></pre><p>相比 fs API，ts-morph 使用更简单</p>\n<h2>Restful 整合</h2>\n<p>可以根据 JSON 数据生成类型文件后，很容易想到，在请求库的拦截器中，拦截响应，执行 JSON 类型文件生成。但值得注意的是，前端项目中，Node API 不能使用，因为你的代码是运行在浏览器的。怎么解决这个问题？</p>\n<h3>类型生成器脚本</h3>\n<p>既然前端项目中不能集成JSON类型文件生成工具，那么可以编写 Node 脚本来解决问题。后端提供一个接口后，前端新增一个接口，脚本配置文件也要注册一个接口，最后运行一下脚本即可。</p>\n<p>那么看看脚本需要完成哪些功能。</p>\n<p>首先脚本需要集成一个请求库，用以发起请求，接收服务端的 JSON 数据。</p>\n<p>然后还要集成上面的 JSON类型文件生成脚本。</p>\n<p>此外，还需要维护一份配置文件，文件中要有请求参数列表，用以动态生成类型文件。为了避免同时发起的请求数量太多，导致电脑死机，或者服务端宕机，还要对请求进行并发控制。</p>\n<p>每次执行脚本，所有请求都会再发送一遍，所以还要考虑检测文件是否生成，再去请求。</p>\n<p>考虑到可维护性，建议单独维护一个 URL 的映射文件，在Node脚本和前端项目，引用 URL 文件的URL 地址。</p>\n<p>有了这样一个脚本，每次新增一个接口时，需要在配置文件中配一下接口和请求参数，然后手动执行一下脚本。这样也不太方便，可以使用 <a href=\"https://github.com/paulmillr/chokidar\">chokidar</a> 监听文件变更，使用 shelljs 来执行脚本。</p>\n<p>可以看到，上面的步骤繁琐且复杂，维护这样一个复杂配置文件，会让人望而却步。并且这样的配置文件对于一些复杂的请求，涉及到的 Token 校验， Post 的 Body 处理，响应的 Data 的处理等等都要区别与前端项目，再单独处理一遍。</p>\n<p>有没有更好的办法，来完成类型生成的目的？</p>\n<h3>Server-Clinet 类型生成器</h3>\n<p>写这样一个脚本，主要的难点在于Node脚本怎么便捷的拿到前端项目的响应数据，也就是前端拿到数据后怎么通知到脚本？</p>\n<p>这么一想，事情就简单了，如果 Node 脚本中开启一个 HTTP Server，前端拿到数据后，再向 HTTP Server 发起一个 POST 请求，将一些参数携带过去，指挥 HTTP Server 向目标目录生成类型文件即可。</p>\n<p>但这一套流程还有个缺点，类型文件是“运行时”生成的，生成类型文件前，需要前端项目先调用一次请求。但是，这一点缺点无伤大雅，开发代码时，肯定需要先测试接口能不能通什么的。</p>\n<h2>工具链</h2>\n<p>基于几天的尝试，我开发了几个库，完成了这样一件事情，最后看 demo 的效果，还不错。</p>\n<h3>Demo 项目</h3>\n<p>我基于 Vite React TypeScript 写了一个 demo 项目：<a href=\"https://github.com/xdoer/restful-types-generate-example\">restful-types-generate-example</a>。</p>\n<p>clone 项目后，运行 yarn 安装, yarn dev 启动项目，点击页面按钮，发起请求后即可看到效果。</p>\n<h3>JsonTypesGenerator</h3>\n<p><a href=\"https://github.com/xdoer/json-types-generator\">json-types-generator</a> 是根据第一小节中介绍的原理完成的</p>\n<p>使用方式如下:</p>\n<pre class=\"prettyprint language-ts\"><code>import jsonTypesGenerator from &#x27;json-types-generator&#x27;\n\nconst json = { a: { b: 1, c: { d: true } } }\njsonTypesGenerator({\n   data: json,\n   outPutPath: &#x27;&#x2F;User&#x2F;xdoer&#x2F;types.ts&#x27;,\n   rootInterfaceName: &#x27;ChinaRegion&#x27;,\n   customInterfaceName(key, value, data) {\n     if (key === &#x27;a&#x27;) return &#x27;Province&#x27;\n     return key\n   },\n})\n</code></pre><p>上面的代码，将会在 <code>/User/xdoer/types.ts</code> 文件中生成导出 interface 为 <code>ChinaRegion</code> 的类型文件，产生的中间 inteface 名称为 <code>Province</code>。不传入 customInterfaceName的情况下，中间产物默认的 interface 名称为 key 的大写</p>\n<pre class=\"prettyprint language-ts\"><code>&lt;!----&#x2F;User&#x2F;xdoer&#x2F;types.ts----&gt;\nexport interface ChinaRegion {\n  a: Province\n}\n\nexport interface Province {\n  b: number\n  c: c\n}\n\nexport interface c {\n  d: boolean\n}\n</code></pre><h3>ResponseTypesServer</h3>\n<p><a href=\"https://github.com/xdoer/PreQuest/tree/main/packages/response-types-server\">response-types-server</a> 是上文提到的 Server-Clinet 类型生成器 中的 Server 部分。只需要向这个Server 发送 POST 请求，即可生成类型。</p>\n<p>使用方式如下:</p>\n<pre class=\"prettyprint language-ts\"><code>import server from &#x27;@prequest&#x2F;response-types-server&#x27;\n\n&#x2F;&#x2F; 默认开启的端口为 10086\nserver()\n\n&#x2F;&#x2F; 你可以通过传参指定端口\nserver({ port: 10010 })\n</code></pre><p>发送的请求，路径任意， POST 请求参数为:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>outPutDir</td>\n<td>string</td>\n<td>类型文件输出目录</td>\n</tr>\n<tr>\n<td>outPutName</td>\n<td>string</td>\n<td>文件名称</td>\n</tr>\n<tr>\n<td>overwrite</td>\n<td>boolean</td>\n<td>文件可复写</td>\n</tr>\n<tr>\n<td>data</td>\n<td>Json</td>\n<td>要解析的 Json 数据</td>\n</tr>\n<tr>\n<td>interfaceName</td>\n<td>string</td>\n<td>导出的接口名称</td>\n</tr>\n</tbody>\n</table>\n<h3>ResponseTypesClient</h3>\n<p><a href=\"https://github.com/xdoer/PreQuest/tree/main/packages/response-types-client\">response-types-client</a> 是上文提到的 Server-Clinet 类型生成器 中的 Client 部分。它是一个中间件 Wrapper，只要将其注册到请求库中间件中，即可发起请求。</p>\n<p>下面的 demo 使用了我自己封装的请求库 PreQuest，基于 Koa 中间件模型的请求库应该都可以使用，比如说 Umi-Request。对于 Axios，需要自己在拦截器中实现，也非常容易。</p>\n<p>使用方式如下：</p>\n<pre class=\"prettyprint language-ts\"><code>import { create, Request, Response } from &#x27;@prequest&#x2F;xhr&#x27;\nimport generateMiddleware, { TypesGeneratorInject } from &#x27;@prequest&#x2F;response-types-client&#x27;\n\n&#x2F;&#x2F; 生成中间件\nconst middleware = generateMiddleware&lt;Request, Response&gt;({\n   enable: process.env.NODE_ENV === &#x27;development&#x27;,\n   httpAgent: create({ path: &#x27;http:&#x2F;&#x2F;localhost:10010&#x2F;&#x27; }),\n   outPutDir: &#x27;src&#x2F;api-types&#x27;\n   parseResponse(res) {\n      &#x2F;&#x2F; res 应当返回接口 data 数据\n      return res as any\n   },\n\n   typesGeneratorConfig(req, res) {\n     const { path } = req\n     const { data } = res\n     \n     if (!path) throw new Error(&#x27;path not found&#x27;)\n\n     &#x2F;&#x2F; 根据请求路径生成文件名和类型导出名称\n     const outPutName = path.replace(&#x2F;.*\\&#x2F;(\\w+)&#x2F;, (_, __) =&gt; __)\n     const interfaceName = outPutName.replace(&#x2F;^[a-z]&#x2F;, g =&gt; g.toUpperCase())\n\n     return {\n       data,\n       outPutName,\n       interfaceName,\n       overwrite: true\n     }\n}})\n\n&#x2F;&#x2F; 注入 TypesGeneratorInject， 可在请求时，根据 rewriteType 参数强制重新生成类型文件\nexport const prequest = create&lt;TypesGeneratorInject, {}&gt;({ baseURL: &#x27;http:&#x2F;&#x2F;localhost:3000&#x27; })\n\n&#x2F;&#x2F; 注册中间件\nprequest.use(middleware)\n</code></pre><h3>ResponseTypesGenerator</h3>\n<p>此外，还有基于上文 “类型生成器脚本” 一节中的原理，进行了一个失败的尝试:<a href=\"https://github.com/xdoer/PreQuest/tree/main/packages/response-types-generator\">response-types-generator</a>，也一并放到这里，感兴趣的可以看看</p>\n<h2>结语</h2>\n<p>以上基于我浅薄的学识进行的一些对 Restful 响应的 JSON 数据类型生成的一些探索，如果您发现了文中的一些错误之处，或者有更简便的方式生成类型文件，欢迎在评论里提出来，大家一起探讨。</p>\n</div>",
      "title": "写了个没用的自动根据 HTTP 响应数据生成 TS 类型文件的生成器",
      "author": {
        "loginname": "LuckyHH",
        "avatar_url": "https://avatars.githubusercontent.com/u/22864183?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 155,
      "country": "USA"
    },
    {
      "id": "61000aaae3e671fbda58fc24",
      "content": "<div class=\"markdown-text\"><p>分析过程：</p>\n<ol>\n<li>服务压测的QPS上不去，通过启动加–prof，拿到CPUprofile，80%是/lib/x86_64-linux-gnu/libc-2.19.so\t导致的，但是，展开后只有0.62是/usr/local/nvm/versions/node/v12.13.1/bin/node\t导致的，没有展示出其他占比比较高的库。</li>\n<li>通过Linux 的perf命令分析，拿到的火焰图没有业务代码，都是底层代码</li>\n</ol>\n<p>是我分析的姿势不对吗？大家有分析过火焰图吗？是怎么分析的？</p>\n</div>",
      "title": "大家有perf拿到的火焰图分析经验吗",
      "author": {
        "loginname": "LiuWeiMr",
        "avatar_url": "https://avatars.githubusercontent.com/u/17976666?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 156,
      "country": "Eurozone"
    },
    {
      "id": "611f0029baed4e1946b84919",
      "content": "<div class=\"markdown-text\"><p>印象中，<a href=\"https://wuyuan.io\">无远开发平台</a>只适合做<strong>强业务逻辑</strong>和<strong>重结构化</strong>的信息管理系统，实际上，只需稍作配置，也能实现偏重于前端展示的各种网站，比如下图展示的政务型网站：</p>\n<h3>【示例一 政务型网站】</h3>\n<p><img src=\"//forum-assets.wuyuan.io/22528/0b4f8220-b60d-41b7-80ac-d9406ca8838216292690600146\" alt></p>\n<ul>\n<li>示例预览地址：<a href=\"https://previewer.wuyuan.io/proj/25011#100\">https://previewer.wuyuan.io/proj/25011#100</a></li>\n<li>示例配置地址：<a href=\"https://workbench.wuyuan.io/proj/25011#100\">https://workbench.wuyuan.io/proj/25011#100</a></li>\n</ul>\n<p><strong>也许你觉得上面的网站结构中规中矩，那么再看下面这个例子：</strong></p>\n<h3>【示例二 SAAS 创业型网站落地页】</h3>\n<p><img src=\"//forum-assets.wuyuan.io/22528/0b4f8220-b60d-41b7-80ac-d9406ca8838216292690591360\" alt></p>\n<p><strong>能看出来这些页面使用了哪些组件吗？</strong></p>\n<p><img src=\"//forum-assets.wuyuan.io/22528/0b4f8220-b60d-41b7-80ac-d9406ca8838216292690597563\" alt></p>\n<ul>\n<li>示例预览地址：<a href=\"https://previewer.wuyuan.io/proj/25040#100\">https://previewer.wuyuan.io/proj/25011#100</a></li>\n<li>示例配置地址：<a href=\"https://workbench.wuyuan.io/proj/25040#100\">https://workbench.wuyuan.io/proj/25011#100</a></li>\n</ul>\n<p><strong>基本上，展示型页面，只需要使用一个背景窗口打底，在其上放置各种功能窗口组件即可快速实现。</strong></p>\n<h1>实现步骤</h1>\n<h3>1. 在【工作台 &gt; 全局配置 &gt; 系统设置】中，启用访客模式。</h3>\n<p>启用后，用户在未登录的情况下进入PC端系统主界面，并可以浏览公共的和允许未授权查看的菜单节点。</p>\n<h3>2. 在【工作台 &gt; 全局配置 &gt; 前端 &gt; 主页设置 &gt; 菜单导航】中，设置菜单样式为顶部级联，并根据菜单节点数设置合理的宽度。</h3>\n<p><img src=\"//forum-assets.wuyuan.io/22528/0b4f8220-b60d-41b7-80ac-d9406ca8838216292690599335\" alt></p>\n<h3>3. 在【工作台 &gt; 页面管理】中创建首页页面，添加窗口并做相应的布局设置。</h3>\n<p><img src=\"//forum-assets.wuyuan.io/22528/0b4f8220-b60d-41b7-80ac-d9406ca8838216292690596582\" alt></p>\n<p><strong>怎么样？步骤是不是很简单？真的学会了吗？</strong></p>\n<p><strong>能分清楚下面这个页面哪些是背景，哪些是组件吗？</strong></p>\n<h3>【示例三 落地页】</h3>\n<p><img src=\"//forum-assets.wuyuan.io/22528/0b4f8220-b60d-41b7-80ac-d9406ca8838216292690594181\" alt></p>\n<ul>\n<li>示例预览地址：<a href=\"https://previewer.wuyuan.io/proj/25065#100\">https://previewer.wuyuan.io/proj/25011#100</a></li>\n<li>示例配置地址：<a href=\"https://workbench.wuyuan.io/proj/25065#100\">https://workbench.wuyuan.io/proj/25011#100</a></li>\n</ul>\n<p><img src=\"//forum-assets.wuyuan.io/22528/0b4f8220-b60d-41b7-80ac-d9406ca8838216292690598324\" alt></p>\n<p>怎么样？是不是有想创业的冲动了？ 23333</p>\n<p>如果觉得有用，请不要吝啬吹捧~~~</p>\n</div>",
      "title": "低代码搞了个智慧政务平台",
      "author": {
        "loginname": "dafanzhi",
        "avatar_url": "https://avatars.githubusercontent.com/u/53632540?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 157,
      "country": "Japan"
    },
    {
      "id": "612f49e7fe0c5112a8ae83d0",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>async.mapLimit(urls, 3, function (url, callback) {\n\t\n}）\n</code></pre><p>如何让mapLimit的同时执行的三个线程间隔某一个时间后，再执行下一个三个线程呢</p>\n</div>",
      "title": "向大家请教一个async模块的问题",
      "author": {
        "loginname": "Choicelin",
        "avatar_url": "https://avatars.githubusercontent.com/u/10152588?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 158,
      "country": "China"
    },
    {
      "id": "612f4115fe0c511fb5ae83b0",
      "content": "<div class=\"markdown-text\"><p>关注<a href=\"https://github.com/simon9124/my_demos/blob/master/README.md\">前端小讴</a>，阅读更多原创技术文章</p>\n<h1>异步编程</h1>\n<ul>\n<li>ES6 新增了正式的<code>Promise</code>引用类型，支持更优雅地定义和组织<strong>异步逻辑</strong></li>\n<li>接下来的几个版本，使用<code>async</code>和<code>await</code>关键字定义异步函数的机制</li>\n</ul>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89/%E7%AC%AC11%E7%AB%A0%20%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/11.1.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.js\">相关代码→</a></p>\n<h2>同步与异步</h2>\n<ul>\n<li><strong>同步行为</strong>在内存中<strong>顺序执行</strong>处理器指令\n<ul>\n<li>每条指令都在<strong>单个线程</strong>中<strong>按出现顺序</strong>执行</li>\n<li>每条指令执行后，都可以推断出程序的状态，并<strong>立即获得</strong>存储在系统本地（或寄存器或系统内存）的信息</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let x = 3 &#x2F;&#x2F; 操作系统在栈内存上分配一个存储浮点数值的空间\nx = x + 4 &#x2F;&#x2F; 针对这个值做一次数学计算，并把计算结果写回之前分配的内存中\n</code></pre><ul>\n<li><strong>异步行为</strong>类似于<strong>系统中断</strong>\n<ul>\n<li>当前<strong>进程外部的实体</strong>可以触发代码执行，通常在<strong>定时回调</strong>中执行</li>\n<li>执行线程<strong>不知道何时</strong>将信息存储到系统本地（或寄存器或系统内存），取决于回调合适从消息队列出列并执行</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let x2 = 3 &#x2F;&#x2F; 操作系统在栈内存上分配一个存储浮点数值的空间\nsetTimeout(() =&gt; {\n  x = x + 4 &#x2F;&#x2F; 执行线程不知道x值何时会改变，取决于回调何时从消息队列出列并执行\n}, 1000)\n</code></pre><h2>以往的异步编程方式</h2>\n<ul>\n<li>早期的 JS 只支持<strong>回调函数</strong>表明异步操作，串联<strong>多个</strong>异步操作需<strong>深度嵌套</strong>回调函数（<strong>回调地狱</strong>）</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function double(value) {\n  setTimeout(() =&gt; {\n    setTimeout(() =&gt; {\n      console.log(value * 2)\n    }, 2000) &#x2F;&#x2F; 2000毫秒后，JS运行时会把回调函数推到消息队列上等待执行\n  }, 1000) &#x2F;&#x2F; 1000毫秒后，JS运行时会把回调函数推到消息队列上等待执行\n}\ndouble(3) &#x2F;&#x2F; 6(约3000毫秒后)，double()函数在setTimeout成功调度异步操作后，立即退出\n</code></pre><h3>异步返回值</h3>\n<ul>\n<li>若<code>setTimeout</code>操作返回有用的值，可给异步操作提供一个回调，把这个值传给需要它的地方</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function double2(value, callback) {\n  setTimeout(() =&gt; {\n    callback(value * 2) &#x2F;&#x2F; 1000毫秒后，把回调函数推到消息队列上\n  }, 1000)\n}\ndouble2(3, (x) =&gt; console.log(&#96;I was given: ${x}&#96;)) &#x2F;&#x2F; &#x27;I was given: 6&#x27;(约1000毫秒后)\n</code></pre><h3>失败处理</h3>\n<ul>\n<li>在回调模型中做异步操作的失败处理（成功回调 &amp; 失败回调）</li>\n<li>该方法<strong>已不可取</strong>，因为必须在<strong>初始化异步操作</strong>时定义回调，异步函数<strong>返回值只在短时间内存在，必须预备好将该返回值作为参数的回调</strong>才能接收到它</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function double3(value, success, failure) {\n  setTimeout(() =&gt; {\n    &#x2F;&#x2F; 必须在初始化异步操作时定义回调\n    try {\n      if (typeof value !== &#x27;number&#x27;) {\n        throw &#x27;Must provide number as first argument&#x27;\n      }\n      success(value * 2)\n    } catch (error) {\n      failure(error)\n    }\n  }, 1000)\n}\nconst successCallback = (x) =&gt; console.log(&#96;Success: ${x}&#96;)\nconst failureCallback = (e) =&gt; console.log(&#96;Failure: ${e}&#96;)\ndouble3(3, successCallback, failureCallback) &#x2F;&#x2F; &#x27;Success: 6&#x27;(约1000毫秒后)\ndouble3(&#x27;3&#x27;, successCallback, failureCallback) &#x2F;&#x2F; &#x27;Failure: Must provide number as first argument&#x27;(约1000毫秒后)\n</code></pre><h3>嵌套异步回调</h3>\n<ul>\n<li>若<strong>异步返回值依赖另一个异步返回值</strong>，则需要<strong>嵌套回调</strong>（<strong>回调地狱</strong>，不具有扩展性，代码难以维护）</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function double4(value, success, failure) {\n  setTimeout(() =&gt; {\n    try {\n      if (typeof value !== &#x27;number&#x27;) {\n        throw &#x27;Must provide number as first argument&#x27;\n      }\n      success(value * 2)\n    } catch (error) {\n      failure(error)\n    }\n  }, 1000)\n}\nconst successCallback2 = (x) =&gt; {\n  double4(x, (y) =&gt; console.log(&#96;Success: ${y}&#96;)) &#x2F;&#x2F; 异步返回值依赖另一个异步返回值，嵌套回调产生“回调地狱”\n}\nconst failureCallback2 = (e) =&gt; console.log(&#96;Failure: ${e}&#96;)\ndouble4(3, successCallback2, failureCallback2) &#x2F;&#x2F; &#x27;Success: 12&#x27;(约2000毫秒后)\n</code></pre><h2>总结 &amp; 问点</h2>\n<ul>\n<li>在执行线程和内存存储方面，同步行为和异步行为有哪些区别？</li>\n<li>写一段代码，将 setTimeout 的返回值作为回调传给函数，并执行这个函数获取结果</li>\n<li>写一段代码，在回调模型中做异步操作的成功/失败处理，并说说为什么该方法已经不可取</li>\n<li>回调地狱是如何形成的？其有什么缺点？</li>\n</ul>\n</div>",
      "title": "《javascript高级程序设计》学习笔记 | 11.1.异步编程",
      "author": {
        "loginname": "simon9124",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 159,
      "country": "Eurozone"
    },
    {
      "id": "612c6839fe0c51b81dae7d8f",
      "content": "<div class=\"markdown-text\"><p>这个社区不错我喜欢！！！</p>\n</div>",
      "title": "不错这个社区不错我喜欢！！！",
      "author": {
        "loginname": "zwtduserid",
        "avatar_url": "https://avatars.githubusercontent.com/u/88653780?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 160,
      "country": "Eurozone"
    },
    {
      "id": "611dd024baed4e05d7b845b2",
      "content": "<div class=\"markdown-text\"><p>ar mongoose = require(‘mongoose’);\nvar Schema = mongoose.Schema;\nvar Connection = require(’./connection’)\nvar DeviceACL = require(&quot;…/models/device_acl&quot;)\nconst emqxService = require(&quot;…/services/emqx_service&quot;)\nconst influxDBService = require(&quot;…/services/influxdb_service&quot;)\nconst ObjectId = require(‘bson’).ObjectID;</p>\n<p>const deviceSchema = new Schema({\n//ProductName\nproduct_name: {\ntype: String,\nrequired: true\n},\n//DeviceName\ndevice_name: {\ntype: String,\nrequired: true,\n},\n//接入EMQX时使用的username\nbroker_username: {\ntype: String,\nrequired: true\n},\n//secret\nsecret: {\ntype: String,\nrequired: true,\n},</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;可接入状态\nstatus: String,\ndevice_status: {\n    type: String,\n    default: &quot;{}&quot;\n},\nlast_status_update: Number,\n\ntags: {\n    type: Array,\n    default: []\n},\n\ntags_version: {\n    type: Number,\n    default: 1\n},\nshadow: {\n    type: String,\n    default: JSON.stringify({\n        &quot;state&quot;: {},\n        &quot;metadata&quot;: {},\n        &quot;version&quot;: 0\n    })\n}\n</code></pre><p>})</p>\n<p>deviceSchema.methods.toJSONObject = function () {\nreturn {\nproduct_name: this.product_name,\ndevice_name: this.device_name,\nsecret: this.secret,\ndevice_status: JSON.parse(this.device_status),\ntags: this.tags,\nshadow: JSON.parse(this.shadow),\n}\n}</p>\n<p>deviceSchema.statics.addConnection = function (event) {\nif(event.username != null) {\nvar username_arr = event.username.split(&quot;/&quot;)\nlet productName = username_arr[0];\nlet deviceName = username_arr[1];\nthis.findOne({product_name: productName, device_name: deviceName}, function (err, device) {\nif (err == null &amp;&amp; device != null) {\nConnection.findOneAndUpdate({\nclient_id: event.client_id,\ndevice: device._id\n}, {\nconnected: true,\nclient_id: event.client_id,\nkeepalive: event.keepalive,\nipaddress: event.ipaddress,\nproto_ver: event.proto_ver,\nconnected_at: event.connected_at,\nconn_ack: event.conn_ack,\ndevice: device._id\n}, {upsert: true, useFindAndModify: false, new: true}).exec()\ninfluxDBService.writeConnectionData({\nproductName: productName,\ndeviceName: deviceName,\nconnected: true,\nts: event.connected_at\n})\n}\n})\n}</p>\n<p>}</p>\n<p>deviceSchema.statics.removeConnection = function (event) {\nif(event.username != null) {\nvar username_arr = event.username.split(&quot;/&quot;)\nlet productName = username_arr[0];\nlet deviceName = username_arr[1];\nthis.findOne({product_name: productName, device_name: deviceName}, function (err, device) {\nif (err == null &amp;&amp; device != null) {\nConnection.findOneAndUpdate({client_id: event.client_id, device: device._id},\n{\nconnected: false,\ndisconnect_at: Math.floor(Date.now() / 1000)\n}, {useFindAndModify: false}).exec()\ninfluxDBService.writeConnectionData({\nproductName: productName,\ndeviceName: deviceName,\nconnected: false\n})\n}\n})\n}\n}</p>\n<p>deviceSchema.methods.getACLRule = function () {\nconst publish = [\n<code>upload_data/${this.product_name}/${this.device_name}/+/+</code>,\n<code>update_status/${this.product_name}/${this.device_name}/+</code>,\n<code>cmd_resp/${this.product_name}/${this.device_name}/+/+/+</code>,\n<code>rpc_resp/${this.product_name}/${this.device_name}/+/+/+</code>,\n<code>get/${this.product_name}/${this.device_name}/+/+</code>,\n<code>m2m/${this.product_name}/+/${this.device_name}/+</code>,\n<code>update_ota_status/${this.product_name}/${this.device_name}/+</code>,\n]\nconst subscribe = [<code>tags/${this.product_name}/+/cmd/+/+/+/#</code>]\nconst pubsub = []\nreturn {\npublish: publish,\nsubscribe: subscribe,\npubsub: pubsub\n}\n}</p>\n<p>deviceSchema.methods.disconnect = function () {\nConnection.find({device: this._id}).exec(function (err, connections) {\nconnections.forEach(function (conn) {\nemqxService.disconnectClient(conn.client_id)\n})\n})\n}</p>\n<p>deviceSchema.post(“remove”, function (device, next) {\nConnection.deleteMany({device: device._id}).exec()\nDeviceACL.deleteMany({broker_username: device.broker_username}).exec()\nnext()\n})</p>\n<p>deviceSchema.methods.sendCommand = function ({commandName, data, encoding = “plain”, ttl = undefined, commandType = “cmd”, qos = 1}) {\nreturn Device.sendCommand({\nproductName: this.product_name,\ndeviceName: this.device_name,\ncommandName: commandName,\ndata: data,\nencoding: encoding,\nttl: ttl,\ncommandType: commandType,\nqos: qos\n})\n}</p>\n<p>deviceSchema.statics.sendCommand = function ({productName, deviceName, commandName, data, encoding = “plain”, ttl = undefined, commandType = “cmd”, qos = 1}) {\nvar requestId = new ObjectId().toHexString()\nvar topic = <code>${commandType}/${productName}/${deviceName}/${commandName}/${encoding}/${requestId}</code>\nif (ttl != null) {\ntopic = <code>${topic}/${Math.floor(Date.now() / 1000) + ttl}</code>\n}\nemqxService.publishTo({topic: topic, payload: data, qos: qos})\nreturn requestId\n}</p>\n<p>deviceSchema.statics.sendCommandByTag = function ({productName, tag, commandName, data, encoding = “plain”, ttl = undefined, qos = 1}) {\nvar requestId = new ObjectId().toHexString()\nvar topic = <code>tags/${productName}/${tag}/cmd/${commandName}/${encoding}/${requestId}</code>\nif (ttl != null) {\ntopic = <code>${topic}/${Math.floor(Date.now() / 1000) + ttl}</code>\n}\nemqxService.publishTo({topic: topic, payload: data, qos: qos})\n}</p>\n<p>deviceSchema.methods.sendTags = function () {\nthis.sendCommand({\ncommandName: “$set_tags”,\ndata: JSON.stringify({tags: this.tags || [], tags_version: this.tags_version || 1}),\nqos: 0\n})\n}</p>\n<p>deviceSchema.methods.updateShadowDesired = function (desired, version) {\nvar ts = Math.floor(Date.now() / 1000)\nvar shadow = JSON.parse(this.shadow)\nif (version &gt; shadow.version) {\nshadow.state.desired = shadow.state.desired || {}\nshadow.metadata.desired = shadow.metadata.desired || {}\nfor (var key in desired) {\nshadow.state.desired[key] = desired[key]\nshadow.metadata.desired[key] = {timestamp: ts}\n}\nshadow.version = version\nshadow.timestamp = ts\nthis.shadow = JSON.stringify(shadow)\nthis.save()\nthis.sendUpdateShadow()\nreturn true\n} else {\nreturn false\n}\n}</p>\n<p>deviceSchema.methods.sendUpdateShadow = function () {\nthis.sendCommand({\ncommandName: “$update_shadow”,\ndata: this.shadow,\nqos: 0\n})\n}</p>\n<p>deviceSchema.methods.updateShadow = function (shadowUpdated) {\nvar ts = Math.floor(Date.now() / 1000)\nvar shadow = JSON.parse(this.shadow)\nif (shadow.version == shadowUpdated.version) {\nif (shadowUpdated.state.desired == null) {\nshadow.state.desired = shadow.state.desired || {}\nshadow.state.reported = shadow.state.reported || {}\nshadow.metadata.reported = shadow.metadata.reported || {}\nfor (var key in shadow.state.desired) {\nif (shadow.state.desired[key] != null) {\nshadow.state.reported[key] = shadow.state.desired[key]\nshadow.metadata.reported[key] = {timestamp: ts}\n} else {\ndelete(shadow.state.reported[key])\ndelete(shadow.metadata.reported[key])\n}\n}\nshadow.timestamp = ts\nshadow.version = shadow.version + 1\ndelete(shadow.state.desired)\ndelete(shadow.metadata.desired)\nthis.shadow = JSON.stringify(shadow)\nthis.save()\nthis.sendCommand({\ncommandName: “$shadow_reply”,\ndata: JSON.stringify({status: “success”, timestamp: ts, version: shadow.version}),\nqos: 0\n})\n}\n} else {\nthis.sendUpdateShadow()\n}\n}</p>\n<p>deviceSchema.methods.reportShadow = function (shadowReported) {\nvar ts = Math.floor(Date.now() / 1000)\nvar shadow = JSON.parse(this.shadow)\nif (shadow.version == shadowReported.version) {\nshadow.state.reported = shadow.state.reported || {}\nshadow.metadata.reported = shadow.metadata.reported || {}\nfor (var key in shadowReported.state.reported) {\nif (shadowReported.state.reported[key] != null) {\nshadow.state.reported[key] = shadowReported.state.reported[key]\nshadow.metadata.reported[key] = {timestamp: ts}\n} else {\ndelete(shadow.state.reported[key])\ndelete(shadow.metadata.reported[key])\n}\n}\nshadow.timestamp = ts\nshadow.version = shadow.version + 1\nthis.shadow = JSON.stringify(shadow)\nthis.save()\nthis.sendCommand({\ncommandName: “$shadow_reply”,\ndata: JSON.stringify({status: “success”, timestamp: ts, version: shadow.version}),\nqos: 0\n})\n} else {\nthis.sendUpdateShadow()\n}\n}</p>\n<p>const Device = mongoose.model(“Device”, deviceSchema);</p>\n<p>module.exports = Device;\n那个大神能教我一下，什么情况下导出的模块是不带操作的，什么样的情况下是带操作导出的，我有点搞不清楚，标准在什么地方，就是我想知道我导出模块的内容包括哪些，比如这个代码的deviceSchesma做为模块导出后，什么它定义下面的操作都能在其它文件中引用了，我并没有导出这样对模块的操作，比如上面的这个操作deviceSchema.methods.toJSONObject，我在其它文件和中就能直接用。</p>\n</div>",
      "title": "我想问一下module.exports导出模块的范围怎样看？",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 161,
      "country": "Eurozone"
    },
    {
      "id": "6100f54de3e67140e158fe63",
      "content": "<div class=\"markdown-text\"><h2>活动介绍</h2>\n<p>活动官方网站：<a href=\"https://subway.midwayjs.org/\">https://subway.midwayjs.org/</a>\n第十二届 Node 地下铁将于 2021 年 8 月 8 日在北京线下举行，我们邀请了业界 4 位有实践和落地经验的同学给大家分享相关话题，欢迎各位报名。</p>\n<p>PC 报名地址：<a href=\"https://www.huodongxing.com/event/6608502975800\">https://www.huodongxing.com/event/6608502975800</a></p>\n<h2>时间地点</h2>\n<p>沙龙时间：2021 年 8 月 8 日（周日）\n沙龙地点：北京·融新科技中心B座（创远路34号院5号楼）\n面向人群：Node.js 开发者</p>\n<h2>日程安排</h2>\n<p>13：00-13：30   活动签到\n13：30-13：40   开场\n13：40-14：20   杜佳昆：《云原生时代的 Alinode》\n14：20-15：00   李洋洋：《Node.js / NestJS 在 Authing 架构中的演进和工程实践》\n15：00-15：10   间休\n15：10-15：50   王东：《基于 Node.js 的物联网平台应用层实践》\n15：50-16：30   贾建容：《高德 Node.js Serverless体系化建设之路》\n16：30-16：35   北京 Node.js 圆桌讨论 + 抽奖\n17：00   合照 &amp; 结束</p>\n<h2>活动海报</h2>\n<p><img src=\"//static.cnodejs.org/FqcUo5fO-xn3tjHs4KUdOjYfkzkH\" alt=\"第十二届地下铁海报.jpg\"></p>\n<h2>温馨提示</h2>\n<p>1、本次活动免费。\n2、报名的朋友们如果提供的email和手机号码无误，我们会在活动开始前一天发送短信和邮件确认。所以请确认自己填写的email地址无误。\n3、本活动欢迎大家带自己的同事和朋友一起参加，不过为了确保良好的听课环境，请尽可能提前为他们报名。</p>\n</div>",
      "title": "2021年8 月8 日 第十二届 Node 地下铁北京专场来啦，开启报名中",
      "author": {
        "loginname": "czy88840616",
        "avatar_url": "//gravatar.com/avatar/c4e414b7264b513a00bbd8ec3e9a0d66?s=48"
      },
      "important": 3,
      "status": "draft",
      "num": 162,
      "country": "USA"
    },
    {
      "id": "611ba014baed4e06d2b83b6e",
      "content": "<div class=\"markdown-text\"><p>有2个数组,我想把一个数组的数据插入到另一个数组中,下面这样的应该如何实现啊?数学里这种叫什么?排列组合?</p>\n<p>{a,b} {c,d} =&gt; {a,b,c} {a,b,d} {a,c,d} {b,c,d}</p>\n<p>目前我是用for循环完成的,代码特别臃肿,有没有更好的办法实现这个需求呢?</p>\n</div>",
      "title": "求大家帮忙解答一个数组循环的问题......",
      "author": {
        "loginname": "iori2882",
        "avatar_url": "https://avatars.githubusercontent.com/u/1480587?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 163,
      "country": "USA"
    },
    {
      "id": "6128a690fe0c513786ae7570",
      "content": "<div class=\"markdown-text\"><p>类似jquery  req/resp都绑定在$上 所有的api都在$上  刀拉一把梭全部搞定</p>\n<pre class=\"prettyprint\"><code>\napp.get(&#x27;&#x2F;path&#x27;, function($){\n      $.end(&#x27;Hello world!&#x27;)\n  })\n</code></pre><p><a href=\"http://dietjs.com/api/signal/request#\">http://dietjs.com/api/signal/request#</a></p>\n</div>",
      "title": "推荐一个前端用的nodejs框架",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 164,
      "country": "Eurozone"
    },
    {
      "id": "6128929dfe0c512500ae74c2",
      "content": "<div class=\"markdown-text\"><h2>点击下载：<a href=\"http://www.97yrbl.com/t-667.html\">SpringBoot+Vue3 项目实战，打造企业级在线办公系统</a></h2>\n<p>基于企业真实应用场景，还原业务流程，能写进简历的大型项目</p>\n<p>未来，在线协同办公将成为企业常态化的工作方式。本课程选用市面上少有的，界面美观，功能模块齐全的大型在线办公系统。项目采用了当下最流行的前后端分离架构及技术（ Java、SSM、Vue3.0 ），课程作为全面提升前后端技术水平的不二选择，也很适合作为简历的加分项。</p>\n<p>适合人群\n1-3年的Java工程师\n缺乏项目经历的IT工作者\n想从面试脱颖而出的\n应届毕业生或者求职者\n技术储备\nJava体系基础知识，SSM框架\n理解Spring的思想和理念\n前端基础，SQL语法\nWeb项目经验</p>\n</div>",
      "title": "SpringBoot+Vue3 项目实战，打造企业级在线办公系统",
      "author": {
        "loginname": "woaimizainali",
        "avatar_url": "https://avatars.githubusercontent.com/u/89630901?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 165,
      "country": "Eurozone"
    },
    {
      "id": "61284c06fe0c516447ae7414",
      "content": "<div class=\"markdown-text\"><p><img src=\"https://pic3.zhimg.com/v2-6f1ed5de3e7587b848024b63c40e2ba5_r.jpg\" alt></p>\n<p>飞书是字节跳动旗下一款企业级协同办公软件，本文将介绍如何基于飞书开放平台的身份验证能力，使用 Lua 实现企业级组织架构的登录认证网关。</p>\n<h2>登录流程</h2>\n<p>让我们首先看一下飞书第三方网站免登的整体流程：</p>\n<p>第一步: 网页后端发现用户未登录，请求身份验证；\n第二步: 用户登录后，开放平台生成登录预授权码，302跳转至重定向地址；\n第三步: 网页后端调用获取登录用户身份校验登录预授权码合法性，获取到用户身份；\n第四步: 如需其他用户信息，网页后端可调用获取用户信息（身份验证）。</p>\n<p><img src=\"https://sf3-cn.feishucdn.com/obj/website-img/faf8b877126e0a5bc7e76f7bc955c352_CCgGABCJpR.png\" alt=\"浏览器内网页登录\"></p>\n<h2>Lua 实现</h2>\n<h3>飞书接口部分实现</h3>\n<h4>获取应用的 access_token</h4>\n<pre class=\"prettyprint language-lua\"><code>function _M:get_app_access_token()\n    local url = &quot;https:&#x2F;&#x2F;open.feishu.cn&#x2F;open-apis&#x2F;auth&#x2F;v3&#x2F;tenant_access_token&#x2F;internal&#x2F;&quot;\n    local body = {\n        app_id = self.app_id,\n        app_secret = self.app_secret\n    }\n    local res, err = http_post(url, body, nil)\n    if not res then\n        return nil, err\n    end\n    if res.status ~= 200 then\n        return nil, res.body\n    end\n    local data = json.decode(res.body)\n    if data[&quot;code&quot;] ~= 0 then\n        return nil, res.body\n    end\n    return data[&quot;tenant_access_token&quot;]\nend\n</code></pre><h4>通过回调 code 获取登录用户信息</h4>\n<pre class=\"prettyprint language-lua\"><code>function _M:get_login_user(code)\n    local app_access_token, err = self:get_app_access_token()\n    if not app_access_token then\n        return nil, &quot;get app_access_token failed: &quot; .. err\n    end\n    local url = &quot;https:&#x2F;&#x2F;open.feishu.cn&#x2F;open-apis&#x2F;authen&#x2F;v1&#x2F;access_token&quot;\n    local headers = {\n        Authorization = &quot;Bearer &quot; .. app_access_token\n    }\n    local body = {\n        grant_type = &quot;authorization_code&quot;,\n        code = code\n    }\n    ngx.log(ngx.ERR, json.encode(body))\n    local res, err = http_post(url, body, headers)\n    if not res then\n        return nil, err\n    end\n    local data = json.decode(res.body)\n    if data[&quot;code&quot;] ~= 0 then\n        return nil, res.body\n    end\n    return data[&quot;data&quot;]\nend\n</code></pre><h4>获取用户详细信息</h4>\n<p>获取登录用户信息时无法获取到用户的部门信息，故这里需要使用登录用户信息中的 <code>open_id</code> 获取用户的详细信息，同时 <code>user_access_token</code> 也是来自于获取到的登录用户信息。</p>\n<pre class=\"prettyprint language-lua\"><code>function _M:get_user(user_access_token, open_id)\n    local url = &quot;https:&#x2F;&#x2F;open.feishu.cn&#x2F;open-apis&#x2F;contact&#x2F;v3&#x2F;users&#x2F;&quot; .. open_id\n    local headers = {\n        Authorization = &quot;Bearer &quot; .. user_access_token\n    }\n    local res, err = http_get(url, nil, headers)\n    if not res then\n        return nil, err\n    end\n    local data = json.decode(res.body)\n    if data[&quot;code&quot;] ~= 0 then\n        return nil, res.body\n    end\n    return data[&quot;data&quot;][&quot;user&quot;], nil\nend\n</code></pre><h3>登录信息</h3>\n<h4>JWT 登录凭证</h4>\n<p>我们使用 JWT 作为登录凭证，同时用于保存用户的 <code>open_id</code> 和 <code>department_ids</code>。</p>\n<pre class=\"prettyprint language-lua\"><code>-- 生成 token\nfunction _M:sign_token(user)\n    local open_id = user[&quot;open_id&quot;]\n    if not open_id or open_id == &quot;&quot; then\n        return nil, &quot;invalid open_id&quot;\n    end\n    local department_ids = user[&quot;department_ids&quot;]\n    if not department_ids or type(department_ids) ~= &quot;table&quot; then\n        return nil, &quot;invalid department_ids&quot;\n    end\n\n    return jwt:sign(\n        self.jwt_secret,\n        {\n            header = {\n                typ = &quot;JWT&quot;,\n                alg = jwt_header_alg,\n                exp = ngx.time() + self.jwt_expire\n            },\n            payload = {\n                open_id = open_id,\n                department_ids = json.encode(department_ids)\n            }\n        }\n    )\nend\n\n-- 验证与解析 token\nfunction _M:verify_token()\n    local token = ngx.var.cookie_feishu_auth_token\n    if not token then\n        return nil, &quot;token not found&quot;\n    end\n\n    local result = jwt:verify(self.jwt_secret, token)\n    ngx.log(ngx.ERR, &quot;jwt_obj: &quot;, json.encode(result))\n    if result[&quot;valid&quot;] then\n        local payload = result[&quot;payload&quot;]\n        if payload[&quot;department_ids&quot;] and payload[&quot;open_id&quot;] then\n            return payload\n        end\n        return nil, &quot;invalid token: &quot; .. json.encode(result)\n    end\n    return nil, &quot;invalid token: &quot; .. json.encode(result)\nend\n</code></pre><h4>使用 Cookie 存储登录凭证</h4>\n<pre class=\"prettyprint language-lua\"><code>ngx.header[&quot;Set-Cookie&quot;] = self.cookie_key .. &quot;=&quot; .. token\n</code></pre><h3>组织架构白名单</h3>\n<p>我们在用户登录时获取用户的部门信息，或者在用户后续访问应用时解析登录凭证中的部门信息，根据设置的部门白名单，判断用户是否拥有访问应用的权限。</p>\n<pre class=\"prettyprint language-lua\"><code>-- 部门白名单配置\n_M.department_whitelist = {}\n\nfunction _M:check_user_access(user)\n    if type(self.department_whitelist) ~= &quot;table&quot; then\n        ngx.log(ngx.ERR, &quot;department_whitelist is not a table&quot;)\n        return false\n    end\n    if #self.department_whitelist == 0 then\n        return true\n    end\n\n    local department_ids = user[&quot;department_ids&quot;]\n    if not department_ids or department_ids == &quot;&quot; then\n        return false\n    end\n    if type(department_ids) ~= &quot;table&quot; then\n        department_ids = json.decode(department_ids)\n    end\n    for i=1, #department_ids do\n        if has_value(self.department_whitelist, department_ids[i]) then\n            return true\n        end\n    end\n    return false\nend\n</code></pre><h3>更多网关配置</h3>\n<p>同时支持 IP 黑名单和路由白名单配置。</p>\n<pre class=\"prettyprint language-lua\"><code>-- IP 黑名单配置\n_M.ip_blacklist = {}\n-- 路由白名单配置\n_M.uri_whitelist = {}\n\nfunction _M:auth()\n    local request_uri = ngx.var.uri\n    ngx.log(ngx.ERR, &quot;request uri: &quot;, request_uri)\n\n    if has_value(self.uri_whitelist, request_uri) then\n        ngx.log(ngx.ERR, &quot;uri in whitelist: &quot;, request_uri)\n        return\n    end\n\n    local request_ip = ngx.var.remote_addr\n    if has_value(self.ip_blacklist, request_ip) then\n        ngx.log(ngx.ERR, &quot;forbided ip: &quot;, request_ip)\n        return ngx.exit(ngx.HTTP_FORBIDDEN)\n    end\n\n    if request_uri == self.logout_uri then\n        return self:logout()\n    end\n\n    local payload, err = self:verify_token()\n    if payload then\n        if self:check_user_access(payload) then\n            return\n        end\n\n        ngx.log(ngx.ERR, &quot;user access not permitted&quot;)\n        self:clear_token()\n        return self:sso()\n    end\n    ngx.log(ngx.ERR, &quot;verify token failed: &quot;, err)\n\n    if request_uri ~= self.callback_uri then\n        return self:sso()\n    end\n    return self:sso_callback()\nend\n</code></pre><h2>使用</h2>\n<p>本文就不赘述 OpenResty 的安装了，可以参考我的另一篇文章<a href=\"https://k8scat.com/posts/linux/install-openresty-on-ubuntu-from-source-code/\">《在 Ubuntu 上使用源码安装 OpenResty》</a>。</p>\n<h3>下载</h3>\n<pre class=\"prettyprint language-bash\"><code>cd &#x2F;path&#x2F;to\ngit clone git@github.com:ledgetech&#x2F;lua-resty-http.git\ngit clone git@github.com:SkyLothar&#x2F;lua-resty-jwt.git\ngit clone git@github.com:k8scat&#x2F;lua-resty-feishu-auth.git\n</code></pre><h3>配置</h3>\n<pre class=\"prettyprint language-conf\"><code>lua_package_path &quot;&#x2F;path&#x2F;to&#x2F;lua-resty-feishu-auth&#x2F;lib&#x2F;?.lua;&#x2F;path&#x2F;to&#x2F;lua-resty-jwt&#x2F;lib&#x2F;?.lua;&#x2F;path&#x2F;to&#x2F;lua-resty-http&#x2F;lib&#x2F;?.lua;&#x2F;path&#x2F;to&#x2F;lua-resty-redis&#x2F;lib&#x2F;?.lua;&#x2F;path&#x2F;to&#x2F;lua-resty-redis-lock&#x2F;lib&#x2F;?.lua;;&quot;;\n\nserver {\n    access_by_lua_block {\n        local feishu_auth = require &quot;resty.feishu_auth&quot;\n        feishu_auth.app_id = &quot;&quot;\n        feishu_auth.app_secret = &quot;&quot;\n        feishu_auth.callback_uri = &quot;&#x2F;feishu_auth_callback&quot;\n        feishu_auth.logout_uri = &quot;&#x2F;feishu_auth_logout&quot;\n        feishu_auth.app_domain = &quot;feishu-auth.example.com&quot;\n\n        feishu_auth.jwt_secret = &quot;thisisjwtsecret&quot;\n\n        feishu_auth.ip_blacklist = {&quot;47.1.2.3&quot;}\n        feishu_auth.uri_whitelist = {&quot;&#x2F;&quot;}\n        feishu_auth.department_whitelist = {&quot;0&quot;}\n\n        feishu_auth:auth()\n    }\n}\n</code></pre><h3>配置说明</h3>\n<ul>\n<li><code>app_id</code> 用于设置飞书企业自建应用的 <code>App ID</code></li>\n<li><code>app_secret</code> 用于设置飞书企业自建应用的 <code>App Secret</code></li>\n<li><code>callback_uri</code> 用于设置飞书网页登录后的回调地址（需在飞书企业自建应用的安全设置中设置重定向 URL）</li>\n<li><code>logout_uri</code> 用于设置登出地址</li>\n<li><code>app_domain</code> 用于设置访问域名（需和业务服务的访问域名一致）</li>\n<li><code>jwt_secret</code> 用于设置 JWT secret</li>\n<li><code>ip_blacklist</code> 用于设置 IP 黑名单</li>\n<li><code>uri_whitelist</code> 用于设置地址白名单，例如首页不需要登录认证</li>\n<li><code>department_whitelist</code> 用于设置部门白名单（字符串）</li>\n</ul>\n<h3>应用权限说明</h3>\n<ul>\n<li>获取部门基础信息</li>\n<li>获取部门组织架构信息</li>\n<li>以应用身份读取通讯录</li>\n<li>获取用户组织架构信息</li>\n<li>获取用户基本信息</li>\n</ul>\n<h2>开源</h2>\n<p>本项目已完成且已在 GitHub 上开源：<a href=\"https://github.com/k8scat/lua-resty-feishu-auth\">k8scat/lua-resty-feishu-auth</a>，希望大家可以动动手指点个 Star，表示对本项目的肯定与支持！</p>\n</div>",
      "title": "飞书 + Lua 实现企业级组织架构登录认证",
      "author": {
        "loginname": "k8scat",
        "avatar_url": "https://avatars.githubusercontent.com/u/55872984?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 166,
      "country": "Japan"
    },
    {
      "id": "6125ff4efe0c51401bae7110",
      "content": "<div class=\"markdown-text\"><p>我使用 express、serilport 起了一个服务，对外提供 http 接口。</p>\n<p><strong>我期望接到 http 请求时，通过串口控制下位机，然后响应 response。</strong></p>\n<p>关于串口控制部分，有以下要求：</p>\n<ul>\n<li>下发串口数据时确认下发结果（回复包）</li>\n<li>接收串口数据上报时下发回复包</li>\n</ul>\n<p><strong>请问：代码的流程上应该怎么设计呢？</strong>—— 可以弄成同步的形式吗？</p>\n<p>事件监听的处理函数中，可以跳转到特定的代码后吗？比如下发一个串口数据后，在接收到某个包后，回到下发数据的代码后面 继续执行？</p>\n</div>",
      "title": "事件监听的处理函数中，可以跳转到特定的代码处吗？",
      "author": {
        "loginname": "seawin",
        "avatar_url": "https://avatars.githubusercontent.com/u/27120235?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 167,
      "country": "USA"
    },
    {
      "id": "612458e6fe0c519fe1ae6dbf",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Flc8uyPPhV1Mlqhe4x9DYlY9YUwd\" alt=\"image.png\"></p>\n<p><a href=\"https://www.techempower.com/benchmarks/#section=data-r20&amp;hw=ph&amp;test=composite\">地址在这里</a>\n<a href=\"https://github.com/just-js/just\">github地址</a></p>\n</div>",
      "title": "如何看待benchmark网站上基于v8构建的js服务端运行时  just-js 的优异表现，综合排名第二",
      "author": {
        "loginname": "ganshiqingyuan",
        "avatar_url": "https://avatars.githubusercontent.com/u/33950951?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 168,
      "country": "Eurozone"
    },
    {
      "id": "5acf6ea3ba60fcc66b7b804d",
      "content": "<div class=\"markdown-text\"><p>免费的以太坊技术资料，中文版：</p>\n<p>以太坊官方文档中文版：<a href=\"https://pan.baidu.com/s/1Jg2t4Jsau7-nFFO-ckkm7w\">https://pan.baidu.com/s/1Jg2t4Jsau7-nFFO-ckkm7w</a>\n以太坊白皮书中文版：<a href=\"https://pan.baidu.com/s/13T4yyjViGEWTbQZJ_fHbiw\">https://pan.baidu.com/s/13T4yyjViGEWTbQZJ_fHbiw</a>\nweb3.js API文档中文版：<a href=\"https://pan.baidu.com/s/1aOtte6zHUFEs5XHD0caWLA\">https://pan.baidu.com/s/1aOtte6zHUFEs5XHD0caWLA</a>\nsolidity官方文档中文版：<a href=\"https://pan.baidu.com/s/18YG0QDVjH9L2B02TnIqVvw\">https://pan.baidu.com/s/18YG0QDVjH9L2B02TnIqVvw</a>\ntruffle官方文档中文版：<a href=\"https://pan.baidu.com/s/1mTXw8g7zgCaJkX6QZiejVQ\">https://pan.baidu.com/s/1mTXw8g7zgCaJkX6QZiejVQ</a>\ngeth使用指南中文版：<a href=\"https://pan.baidu.com/s/1k8gJ1VihtXkOpCfPdB6Pdg\">https://pan.baidu.com/s/1k8gJ1VihtXkOpCfPdB6Pdg</a>\n区块链技术指南中文版：<a href=\"https://pan.baidu.com/s/1O-565-qDOPyR6LtnXQygRQ\">https://pan.baidu.com/s/1O-565-qDOPyR6LtnXQygRQ</a>\nc#区块链编程中文版：<a href=\"https://pan.baidu.com/s/1Wz0aUsxl5wuR9ww_BnYdjw\">https://pan.baidu.com/s/1Wz0aUsxl5wuR9ww_BnYdjw</a>\n精通比特币中文版：<a href=\"https://pan.baidu.com/s/1uWXKvKVxliTQW47xcbGvAg\">https://pan.baidu.com/s/1uWXKvKVxliTQW47xcbGvAg</a>\nNode.js区块链开发：<a href=\"https://pan.baidu.com/s/1Mi5oBWCb2eSdzMqZBP7Zkg\">https://pan.baidu.com/s/1Mi5oBWCb2eSdzMqZBP7Zkg</a>\n以太坊DApp开发环境搭建( Ubuntu）：<a href=\"https://pan.baidu.com/s/12xmAScSafm2cS6qPVoJrIQ\">https://pan.baidu.com/s/12xmAScSafm2cS6qPVoJrIQ</a>\n以太坊DApp开发环境搭建（Windows）：<a href=\"https://pan.baidu.com/s/1uA28smpBF9vQB7IHAOx3FQ\">https://pan.baidu.com/s/1uA28smpBF9vQB7IHAOx3FQ</a>\n以太坊DApp私链开发环境搭建（Ubuntu）：<a href=\"https://pan.baidu.com/s/1vy1vRz2_XGC4vsJw01ejlg\">https://pan.baidu.com/s/1vy1vRz2_XGC4vsJw01ejlg</a>\n以太坊DApp私链开发环境搭建（Windows）：<a href=\"https://pan.baidu.com/s/11aGSUNk8zHZq6Ho_kJP6ow\">https://pan.baidu.com/s/11aGSUNk8zHZq6Ho_kJP6ow</a></p>\n</div>",
      "title": "以太坊技术资料中文pdf电子书",
      "author": {
        "loginname": "ezpod",
        "avatar_url": "https://avatars2.githubusercontent.com/u/38157048?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 169,
      "country": "USA"
    },
    {
      "id": "611f5a4bfe0c51608eae6798",
      "content": "<div class=\"markdown-text\"><p>关注<a href=\"https://github.com/simon9124/my_demos/blob/master/README.md\">前端小讴</a>，阅读更多原创技术文章</p>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89/%E7%AC%AC10%E7%AB%A0%20%E5%87%BD%E6%95%B0/10.14-10.16.%E9%97%AD%E5%8C%85.js\">相关代码→</a></p>\n<h1>10.14 闭包</h1>\n<ul>\n<li><strong>闭包</strong>是指<strong>引用了另一个函数作用域中变量</strong>的函数，通常在嵌套函数中实现（<strong>如果一个函数访问了它的外部变量，那么它就是一个闭包</strong>）\n<ul>\n<li>闭包中函数的作用域链中，有对外部函数变量的引用</li>\n<li>为了<strong>在全局作用域可以访问到闭包函数</strong>，通常在外部函数内<strong>返回</strong>内部闭包函数</li>\n<li>因此外部函数<strong>被闭包引用的活动对象</strong>，并<strong>不能</strong>在外部函数执行后被销毁，仍保留在内存中</li>\n<li>若要<strong>释放内存</strong>，需<strong>解除闭包函数对外部函数活动对象的引用</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function arraySort(key, sort) {\n  return function (a, b) {\n    &#x2F;&#x2F; 内部匿名函数，引用外部函数变量key和sort，形成闭包\n    let va = a[key]\n    let vb = b[key]\n    if (sort === &#x27;asc&#x27; || sort === undefined || sort === &#x27;&#x27;) {\n      &#x2F;&#x2F; 正序：va &gt; vb\n      if (va &gt; vb) return 1\n      else if (va &lt; vb) return -1\n      else return 0\n    } else if (sort === &#x27;desc&#x27;) {\n      &#x2F;&#x2F; 倒序：va &lt; vb\n      if (va &lt; vb) return 1\n      else if (va &gt; vb) return -1\n      else return 0\n    }\n  }\n}\nlet compareNames = arraySort(&#x27;name&#x27;) &#x2F;&#x2F; 执行函数并返回匿名函数，匿名函数的作用域链仍对arraySort的活动对象key和sort有引用，因此不会被销毁\nlet result = compareNames({ name: &#x27;Nicholas&#x27; }, { name: &#x27;Matt&#x27; }) &#x2F;&#x2F; 执行匿名函数\ncompareNames = null &#x2F;&#x2F; 解除匿名函数对arraySort活动对象的引用，释放内存\n</code></pre><h2>10.14.1 this 对象</h2>\n<ul>\n<li>在<strong>闭包内</strong>使用<code>this</code>会让代码更复杂，若内部函数没有使用箭头函数，<code>this</code>绑定给<strong>执行函数的上下文</strong>：\n<ul>\n<li>全局函数中调用，非严格模式下<code>this</code>指向<code>window</code>，严格模式等于<code>undefined</code></li>\n<li>作为某个对象的方法调用，<code>this</code>指向该对象</li>\n<li><strong>匿名函数</strong>不会绑定到某个对象，其<code>this</code>指向<strong>调用该匿名函数的对象</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>global.identity = &#x27;The Window&#x27; &#x2F;&#x2F; vscode是node运行环境，无法识别全局对象window，测试时将window改为global\nlet object = {\n  identity: &#x27;My Object&#x27;,\n  getIdentityFunc() {\n    return function () {\n      return this.identity\n    }\n  },\n}\nconsole.log(object.getIdentityFunc()) &#x2F;&#x2F; ƒ () { return this.identity }，返回匿名函数\nconsole.log(object.getIdentityFunc()()) &#x2F;&#x2F; &#x27;The Window&#x27;，立即调用匿名函数返回this.identity，this指向全局对象\n</code></pre><ul>\n<li>函数被调用时自动创建变量<code>this</code>和<code>arguments</code>，<strong>内部函数不能直接访问外部函数的这两个变量</strong>，若想访问需<strong>将其引用先保存到闭包能访问的另一个变量中</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let object2 = {\n  identity: &#x27;My Object&#x27;,\n  getIdentityFunc() {\n    let that = this &#x2F;&#x2F; 外部函数的变量this保存在that中\n    return function () {\n      return that.identity &#x2F;&#x2F; 闭包（匿名函数）中引用that，that指向getIdentityFunc()上下文的this（而非闭包内的this）\n    }\n  },\n}\nconsole.log(object2.getIdentityFunc()()) &#x2F;&#x2F; &#x27;My Object&#x27;，立即调用匿名函数返回that.identity，that指向闭包外部函数getIdentityFunc的this\n</code></pre><ul>\n<li>一些特殊情况下的<code>this</code>值</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let object3 = {\n  identity: &#x27;My Object&#x27;,\n  getIdentity() {\n    return this.identity\n  },\n}\nconsole.log(object3.getIdentity()) &#x2F;&#x2F; &#x27;My Object&#x27;\nconsole.log(object3.getIdentity) &#x2F;&#x2F; [Function: getIdentity]，函数getIdentity()\nconsole.log((object3.getIdentity = object3.getIdentity)) &#x2F;&#x2F; [Function: getIdentity]，函数getIdentity()赋值给object3.getIdentity\nconsole.log((object3.getIdentity = object3.getIdentity)()) &#x2F;&#x2F; &#x27;The Window&#x27;，赋值后在全局立即调用匿名函数，this指向全局对象\nconsole.log((object3.funcA = object3.getIdentity)()) &#x2F;&#x2F; &#x27;The Window&#x27;，函数getIdentity()赋值给对象其他属性，结果相同\nobject3.funcB = object3.getIdentity\nconsole.log(object3.funcB()) &#x2F;&#x2F; &#x27;My Object&#x27;，赋值后在object3调用，this指向object3\n</code></pre><h2>10.14.2 内存泄漏</h2>\n<ul>\n<li>由于使用了不同的垃圾回收机制，闭包在 IE9 之前的 IE 浏览器会导致问题：一旦 HTML 元素保存在某个闭包的作用域中，其不会被销毁</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function assignHandler() {\n  let element = document.getElementById(&#x27;someElement&#x27;)\n  element.onclick = () =&gt; {\n    console.log(element.id) &#x2F;&#x2F; 引用外部函数的活动对象element，匿名函数一直存在因此element不会被销毁\n  }\n}\n\nfunction assignHandler2() {\n  let element = document.getElementById(&#x27;someElement&#x27;)\n  let id = element.id &#x2F;&#x2F; 保存element.id的变量id\n  element.onclick = () =&gt; {\n    console.log(id) &#x2F;&#x2F; 不直接引用element，改为引用改为引用保存着element.id的变量id\n  }\n  element = null &#x2F;&#x2F; 解除对element对象的引用，释放闭包内存\n}\n</code></pre><h1>10.15 立即调用的函数表达式</h1>\n<ul>\n<li><strong>立即调用的匿名函数</strong>又称<strong>立即调用的函数表达式（IIFE）</strong>，其类似于函数声明，被<strong>包含在括号中</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>;(function () {\n  &#x2F;&#x2F; 块级作用域\n})()\n</code></pre><ul>\n<li>ES5 尚未支持块级作用域，可以使用 IIFE 模拟</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>;(function () {\n  for (var i = 0; i &lt; 3; i++) {\n    console.log(i) &#x2F;&#x2F; 0、1、2\n  }\n})()\nconsole.log(i) &#x2F;&#x2F; ReferenceError: i is not defined，i在函数体作用域（模拟块级作用域）内\n</code></pre><ul>\n<li>ES6 支持块级作用域，无须 IIFE 即可实现同样的功能</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>{\n  let i = 0\n  for (i = 0; i &lt; 3; i++) {\n    console.log(i) &#x2F;&#x2F; 0、1、2\n  }\n}\nconsole.log(i) &#x2F;&#x2F; ReferenceError: i is not defined\n\nfor (let i = 0; i &lt; 3; i++) {\n  console.log(i) &#x2F;&#x2F; 0、1、2\n}\nconsole.log(i) &#x2F;&#x2F; ReferenceError: i is not defined\n</code></pre><ul>\n<li>执行<strong>单击处理程序</strong>时，<strong>迭代变量</strong>的值是<strong>循环结束时的最终值</strong>，可以用 IIFE 或块级作用域<strong>锁定每次单击要显示的值</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let divs = document.querySelectorAll(&#x27;div&#x27;)\nfor (var i = 0; i &lt; divs.length; ++i) {\n  divs[i].addEventListener(\n    &#x27;click&#x27;,\n\n    &#x2F;&#x2F; 错误的写法：直接打印（单击处理程序迭代变量的值是循环结束时的最终值）\n    &#x2F;&#x2F; function(){\n    &#x2F;&#x2F;   console.log(i);\n    &#x2F;&#x2F; }\n\n    &#x2F;&#x2F; 正确的写法：立即执行的函数表达式，锁定每次要显示的值\n    (function (_i) {\n      return function () {\n        console.log(_i)\n      }\n    })(i) &#x2F;&#x2F; 参数传入每次要显示的值\n  )\n}\n\nfor (let i = 0; i &lt; divs.length; ++i) {\n  &#x2F;&#x2F; 用let关键字，在循环内部为每个循环创建独立的变量\n  divs[i].addEventListener(&#x27;click&#x27;, function () {\n    console.log(i)\n  })\n}\n</code></pre><ul>\n<li>同理，执行<strong>超时逻辑</strong>时，<strong>迭代变量</strong>的值是<strong>导致循环退出的值</strong>，同样可用 IIFE 或块级作用域<strong>锁定每次要迭代的值</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>for (var i = 0; i &lt; 5; i++) {\n  &#x2F;&#x2F; 超时逻辑在退出循环后执行，迭代变量保存的是导致循环退出的值5\n  setTimeout(() =&gt; {\n    console.log(i) &#x2F;&#x2F; 5、5、5、5、5\n  }, 0)\n}\n\nfor (var i = 0; i &lt; 5; i++) {\n  &#x2F;&#x2F; 用立即调用的函数表达式，传入每次循环的当前索引，锁定每次超时逻辑应该显示的索引值\n  ;(function (_i) {\n    setTimeout(() =&gt; {\n      console.log(_i) &#x2F;&#x2F; 0、1、2、3、4\n    }, 0)\n  })(i)\n}\n\nfor (let i = 0; i &lt; 5; i++) {\n  &#x2F;&#x2F; 使用let声明：为每个迭代循环声明新的迭代变量\n  setTimeout(() =&gt; {\n    console.log(i) &#x2F;&#x2F; 0、1、2、3、4\n  }, 0)\n}\n</code></pre><h1>10.16 私有变量</h1>\n<ul>\n<li>任何定义在<strong>函数</strong>或<strong>块中</strong>的变量，都可以认为是<strong>私有</strong>的（函数或块的外部无法访问其中的变量）</li>\n<li>私有变量包括<strong>函数参数</strong>、<strong>局部变量</strong>和<strong>函数内部定义的其他函数</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function add(num1, num2) {\n  &#x2F;&#x2F; 3个私有变量：参数num1、参数num2、局部变量sum\n  let sum = num1 + num2\n  return sum\n}\n</code></pre><ul>\n<li><strong>特权方法</strong>是能够访问函数的私有变量（及私有函数）的公共方法，可在<strong>构造函数</strong>中实现</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function MyObject() {\n  let privateVariable = 10\n  function privateFunction() {\n    console.log(&#x27;privateFunction&#x27;)\n    return false\n  }\n  &#x2F;&#x2F; 特权方法（闭包）：访问私有变量privateVariable和私有方法privateFunction()\n  this.publicMethod = function () {\n    console.log(&#x27;privateVariable&#x27;, privateVariable++)\n    return privateFunction()\n  }\n}\nlet obj = new MyObject()\nobj.publicMethod()\n&#x2F;* \n  privateVariable 10\n  privateFunction\n*&#x2F;\n</code></pre><ul>\n<li>同<strong>构造函数的缺点</strong>，在构造函数中实现私有变量的问题是：<strong>每个实例都重新创建方法（私有方法&amp;特权方法），机制相同的 Function 对象被多次实例化</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function Person(name) {\n  &#x2F;* 私有变量name无法被直接访问到，只能通过getName()和setName()特权方法读写 *&#x2F;\n  this.getName = function () {\n    return name\n  }\n  this.setName = function (_name) {\n    name = _name\n  }\n}\nlet person = new Person(&#x27;Nicholas&#x27;) &#x2F;&#x2F; 每创建一个实例都创建一遍方法（私有方法&amp;特权方法）\nconsole.log(person.getName()) &#x2F;&#x2F; &#x27;Nicholas&#x27;\nperson.setName(&#x27;Greg&#x27;)\nconsole.log(person.getName()) &#x2F;&#x2F; &#x27;Greg&#x27;\n</code></pre><h2>10.16.1 静态私有变量</h2>\n<ul>\n<li>使用<strong>匿名函数表达式</strong>创建<strong>私有作用域</strong>，实现特权方法：\n<ul>\n<li>定义<strong>私有变量</strong>和<strong>私有方法</strong>\n<ul>\n<li>私有变量作为<strong>静态私有变量</strong>，被<strong>共享</strong>，但<strong>不存在</strong>于每个实例中</li>\n</ul>\n</li>\n<li>定义<strong>构造函数</strong>\n<ul>\n<li>使用<strong>函数表达式</strong>定义构造函数（函数声明会创建内部函数）</li>\n<li><strong>不使用关键字</strong>定义构造函数，使其创建在<strong>全局作用域</strong>中</li>\n</ul>\n</li>\n<li>定义<strong>公有方法（特权方法）</strong>\n<ul>\n<li>定义在构造函数的<strong>原型</strong>上</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>;(function () {\n  &#x2F;* 匿名函数表达式，创建私有作用域 *&#x2F;\n\n  &#x2F;&#x2F; 私有变量和私有方法，被隐藏\n  let privateVariable = 10\n  function privateFunction() {\n    return false\n  }\n\n  &#x2F;&#x2F; 构造函数：使用函数表达式 &amp; 不使用关键字（创建在全局作用域）\n  MyObject = function () {}\n\n  &#x2F;&#x2F; 公有方法&#x2F;特权方法（闭包）：定义在构造函数的原型上\n  MyObject.prototype.publicMethod = function () {\n    console.log(&#x27;privateVariable&#x27;, privateVariable++)\n    return privateFunction()\n  }\n})()\n</code></pre><ul>\n<li>该方式下，私有变量和私有方法由实例<strong>共享</strong>，<strong>特权方法</strong>定义在原型上，也由实例<strong>共享</strong></li>\n<li>创建实例<strong>不会重新创建方法</strong>，但<strong>调用特权方法并修改静态私有变量</strong>会<strong>影响所有实例</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>;(function () {\n  &#x2F;&#x2F; 私有变量name，被隐藏\n  let name = &#x27;&#x27;\n\n  &#x2F;&#x2F; 构造函数，创建在全局作用域中\n  Person = function (_name) {\n    name = _name\n  }\n\n  &#x2F;&#x2F; 特权方法，定义在构造函数原型上\n  Person.prototype.getName = function () {\n    return name\n  }\n  Person.prototype.setName = function (_name) {\n    name = _name\n  }\n})()\n\nlet person1 = new Person(&#x27;Nicholas&#x27;)\nconsole.log(person1.getName()) &#x2F;&#x2F; &#x27;Nicholas&#x27;\nperson1.setName(&#x27;Matt&#x27;)\nconsole.log(person1.getName()) &#x2F;&#x2F; &#x27;Matt&#x27;\n\nlet person2 = new Person(&#x27;Michael&#x27;)\nconsole.log(person2.getName()) &#x2F;&#x2F; &#x27;Michael&#x27;，调用特权方法并修改静态私有变量\nconsole.log(person1.getName()) &#x2F;&#x2F; &#x27;Michael&#x27;，影响所有实例\n</code></pre><h2>10.16.2 模块模式</h2>\n<ul>\n<li>在<strong>单例对象</strong>基础上加以扩展，通过<strong>作用域链</strong>关联私有变量和特权方法:\n<ul>\n<li>将单例对象的<strong>对象字面量</strong>扩展为<strong>立即调用的函数表达式</strong></li>\n<li>在匿名函数内部，定义私有变量和私有方法</li>\n<li>在匿名函数内部，<strong>返回</strong>只包含可以公开访问属性和方法的<strong>对象字面量</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let singleton = (function () {\n  &#x2F;* 立即调用的函数表达式，创建私有作用域 *&#x2F;\n\n  &#x2F;&#x2F; 私有变量和私有方法，被隐藏\n  let privateVariable = 10\n  function privateFunction() {\n    return false\n  }\n\n  &#x2F;&#x2F; 返回只包含可以公开访问属性和方法的对象字面量\n  return {\n    publicProperty: true,\n    publicMethod() {\n      console.log(++privateVariable)\n      return privateFunction\n    },\n  }\n})()\nconsole.log(singleton) &#x2F;&#x2F; { publicProperty: true, publicMethod: [Function: publicMethod] }\nsingleton.publicMethod() &#x2F;&#x2F; 11\n</code></pre><ul>\n<li><strong>本质</strong>上，该模式用对象字面量定义了<strong>单例对象的公共接口</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function BaseComponent() {} &#x2F;&#x2F; BaseComponent组件\n\nlet application = (function () {\n  let components = new Array() &#x2F;&#x2F; 创建私有数组components\n  components.push(new BaseComponent()) &#x2F;&#x2F; 初始化，将BaseComponent组件的新实例添加到数组中\n\n  &#x2F;* 公共接口 *&#x2F;\n  return {\n    &#x2F;&#x2F; getComponentCount()特权方法：返回注册组件数量\n    getComponentCount() {\n      return components.length\n    },\n    &#x2F;&#x2F; registerComponent()特权方法：注册组件\n    registerComponent(component) {\n      if (typeof component === &#x27;object&#x27;) {\n        components.push(component)\n      }\n    },\n    &#x2F;&#x2F; getRegistedComponents()特权方法：查看已注册的组件\n    getRegistedComponents() {\n      return components\n    },\n  }\n})()\n\nconsole.log(application.getComponentCount()) &#x2F;&#x2F; 1\nconsole.log(application.getRegistedComponents()) &#x2F;&#x2F; [ BaseComponent {} ]，已注册组件BaseComponent\n\nfunction APPComponent() {} &#x2F;&#x2F; APPComponent组件\napplication.registerComponent(new APPComponent()) &#x2F;&#x2F; 注册组件APPComponent\nconsole.log(application.getComponentCount()) &#x2F;&#x2F; 2\nconsole.log(application.getRegistedComponents()) &#x2F;&#x2F; [ BaseComponent {}, APPComponent {} ]，已注册组件BaseComponent和APPComponent\n</code></pre><h2>10.16.3 模块增强模式</h2>\n<ul>\n<li>利用<strong>模块模式</strong>，在<strong>返回对象前</strong>进行增强，适合<strong>单例对象为某个特定类型的实例，但必须给它添加额外属性或方法</strong>的场景：\n<ul>\n<li>在匿名函数内部，定义私有变量和私有方法</li>\n<li>在匿名函数内部，<strong>创建某（特定）类型的实例</strong></li>\n<li>给实例对象添加共有属性和方法（增强）</li>\n<li>返回实例对象</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function CustomType() {} &#x2F;&#x2F; 特定类型\nlet singleton2 = (function () {\n  &#x2F;&#x2F; 私有变量和私有方法，被隐藏\n  let privateVariable = 10\n  function privateFunction() {\n    return false\n  }\n\n  &#x2F;&#x2F; 创建特定类型的实例\n  let object = new CustomType()\n\n  &#x2F;&#x2F; 添加公有属性和方法\n  object.publicProperty = true\n  object.publicMethod = function () {\n    console.log(++privateVariable)\n    return privateFunction\n  }\n\n  &#x2F;&#x2F; 返回实例\n  return object\n})()\nconsole.log(singleton2) &#x2F;&#x2F; CustomType { publicProperty: true, publicMethod: [Function: publicMethod] }\nsingleton2.publicMethod() &#x2F;&#x2F; 11\n</code></pre><ul>\n<li>以<strong>模块模式</strong>的<strong>单例对象公共接口</strong>为例，若<code>application</code>必须是<code>BaseComponent</code>组件的实例，可以使用模块增强模式来创建：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let application2 = (function () {\n  let components = new Array() &#x2F;&#x2F; 创建私有数组components\n  components.push(new BaseComponent()) &#x2F;&#x2F; 初始化，将BaseComponent组件的新实例添加到数组中\n  let app = new BaseComponent() &#x2F;&#x2F; 创建局部变量保存实例\n\n  &#x2F;* 公共接口 *&#x2F;\n  &#x2F;&#x2F; getComponentCount()特权方法：返回注册组件数量\n  app.getComponentCount = function () {\n    return components.length\n  }\n  &#x2F;&#x2F; registerComponent()特权方法：注册组件\n  app.registerComponent = function (component) {\n    if (typeof component === &#x27;object&#x27;) {\n      components.push(component)\n    }\n  }\n  &#x2F;&#x2F; getRegistedComponents()特权方法：查看已注册的组件\n  app.getRegistedComponents = function () {\n    return components\n  }\n\n  return app &#x2F;&#x2F; 返回实例\n})()\n\nconsole.log(application2) &#x2F;&#x2F; BaseComponent { getComponentCount: [Function (anonymous)], registerComponent: [Function (anonymous)], getRegistedComponents: [Function (anonymous)] }\nconsole.log(application2.getComponentCount()) &#x2F;&#x2F; 1\nconsole.log(application2.getRegistedComponents()) &#x2F;&#x2F; [ BaseComponent {} ]，已注册组件BaseComponent\n\napplication2.registerComponent(new APPComponent()) &#x2F;&#x2F; 注册组件APPComponent\nconsole.log(application2.getComponentCount()) &#x2F;&#x2F; 2\nconsole.log(application2.getRegistedComponents()) &#x2F;&#x2F; [ BaseComponent {}, APPComponent {} ]，已注册组件BaseComponent和APPComponent\n</code></pre><table>\n<thead>\n<tr>\n<th></th>\n<th>私有变量 &amp; 私有方法</th>\n<th>特权方法</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>构造函数</td>\n<td>实例中，独立</td>\n<td>实例中</td>\n<td>每个实例重新创建方法（私有方法&amp;特权方法）</td>\n</tr>\n<tr>\n<td>私有作用域</td>\n<td>私有作用域中，静态，共享</td>\n<td>构造函数原型上</td>\n<td>调用特权方法修改私有变量，影响其他实例</td>\n</tr>\n<tr>\n<td>模块模式</td>\n<td>私有作用域中，独立</td>\n<td>单例对象上</td>\n<td></td>\n</tr>\n<tr>\n<td>模块增强模式</td>\n<td>私有作用域中，独立</td>\n<td>实例对象上</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h1>总结 &amp; 问点</h1>\n<ul>\n<li>什么是闭包？其作用是什么？</li>\n<li>在没有使用箭头函数的情况下，this 在全局和局部方法调用时，分别指向哪里？若是匿名函数中的 this 呢？</li>\n<li>函数嵌套时，内部函数如何访问外部函数的 this 和 arguments?</li>\n<li>什么是立即调用的函数表达式？请用代码用其模拟块级作用域</li>\n<li>请用代码实现功能：获取所有的 div 元素，点击不同的 div 显示其相应的索引值。要求分别用 IIFE 和块级作用域实现</li>\n<li>请用代码实现功能：1 秒后实现 0~4 的数字迭代。要求分别用 IIFE 和块级作用域实现</li>\n<li>什么是私有变量？其可能包括哪些内容？</li>\n<li>什么是特权方法？请写一段代码，在构造函数中实现特权方法，并说说这种方式有什么问题</li>\n<li>请写一段代码，通过私有变量实现特权方法，说说并证明这种方式有什么局限</li>\n<li>请写一段代码，通过模块模式定义单例对象的公共接口，实现 Web 组件注册</li>\n<li>模块增强模式适合什么场景？请用代码实现其模式下的 Web 组件注册</li>\n</ul>\n</div>",
      "title": "《javascript高级程序设计》学习笔记 | 10.14-10.16.闭包",
      "author": {
        "loginname": "simon9124",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 170,
      "country": "China"
    },
    {
      "id": "61200de6fe0c51a4edae6874",
      "content": "<div class=\"markdown-text\"><p>我发现现有的 JavaScript npm 包并没有以标准方式全面地涵盖对排序数组的操作，因此我创建了一个对排序数组操作的包。 如果您喜欢，请给 GitHub repo一个 star！\n<a href=\"https://github.com/sakura90/sorted-array-operations\">https://github.com/sakura90/sorted-array-operations</a>\n<a href=\"https://www.npmjs.com/package/sorted-array-operations\">https://www.npmjs.com/package/sorted-array-operations</a></p>\n</div>",
      "title": "我想分享一个排序数组的 npm 包",
      "author": {
        "loginname": "sakura90",
        "avatar_url": "https://avatars.githubusercontent.com/u/6892198?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 171,
      "country": "USA"
    },
    {
      "id": "60013d775d04ac7b3d217056",
      "content": "<div class=\"markdown-text\"><p>项目地址： <a href=\"https://github.com/ykfe/ssr\">https://github.com/ykfe/ssr</a></p>\n<p>ssr is serverless-side render specification implementation. focus on developer experience, easy debug and no over-engineering.\nfeatures</p>\n<ul>\n<li>minimal：build bundle size is smaller than nextjs</li>\n<li>full feature：write once，generate SSR/CSR bundle, tranfer ssr to csr mode seamless degradation</li>\n<li>support multi‑cloud：based on <a href=\"https://github.com/midwayjs/midway\">midway-faas</a> framework，can be deployed to any serverless plateform</li>\n</ul>\n<h2>Serverless for Developer</h2>\n<blockquote>\n<p>Serverless 解放了端开发者（不仅仅是 Web 开发者）的生产力，让端开发者可以更快、更好、更灵活地开发各种端上应用，不需要投入太多精力关注于后端服务的实现。”</p>\n</blockquote>\n<p>传统应用开发流程</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1CE7FB5_1gK0jSZFqXXcpaXXa-1402-150.png\" alt></p>\n<p>Serverless 应用开发流程</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1hZgHB7T2gK0jSZPcXXcKkpXa-1136-174.png\" alt></p>\n<p>使用本框架开发 Serverless SSR 应用开发流程</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1wzqpCkP2gK0jSZPxXXacQpXa-1880-256.jpg\" alt></p>\n<p>相比于传统服务端应用开发，我们将细节在底层统一抹平。前端开发者只需要关注业务逻辑，无需感知服务器的运行状况。成本和心智负担大大降低，只需要申请一个域名即可将应用发布到公网让所有用户可以访问。</p>\n<p>🚀 表示已经实现的功能</p>\n<table>\n<thead>\n<tr>\n<th>里程碑</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最小而美的实现 React 服务端渲染功能</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>约定式前端路由</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>All in JSX，抛弃传统模版引擎，所有部分包括 layout 布局皆使用 JSX 来编写生成</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>渲染模式切换：服务端渲染一键降级为客户端渲染</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>统一服务端客户端的数据获取方式</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>类型友好，全面拥抱 TS</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>支持无缝接入 <a href=\"https://github.com/ant-design/ant-design\">antd</a> 无需修改任何配置</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>支持使用 less 作为 css 预处理器</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>实现 SSR 场景下<a href=\"https://zhuanlan.zhihu.com/p/343743374\">最优秀的代码分割方案</a></td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>接入 useContext + useReducer 实现极简的<a href=\"#%E4%B8%8D%E5%90%8C%E9%A1%B5%E9%9D%A2%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB\">数据管理</a>，摒弃传统的 redux/dva 等数据管理方案</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>支持在阿里云 <a href=\"https://zhuanlan.zhihu.com/p/139210473\">云平台</a>创建使用</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>ssr deploy 一键部署到<a href=\"https://www.aliyun.com/\">阿里云</a>平台</td>\n<td>🚀</td>\n</tr>\n<tr>\n<td>ssr deploy --tencent 无需修改任何配置一键部署到<a href=\"https://cloud.tencent.com/\">腾讯云</a>平台</td>\n<td>🚀</td>\n</tr>\n</tbody>\n</table>\n<h2>哪些应用在使用</h2>\n<p>正在使用这个项目的公司(应用), 如果您正在使用但名单中没有列出来的话请提 issue，欢迎推广分享，我们将随时提供技术支持</p>\n<p>&lt;table&gt;\n&lt;tr height=“100”&gt;\n&lt;td align=“center”&gt;&lt;a target=&quot;_blank&quot; href=“<a href=\"http://youku.com/\">http://youku.com/</a>”&gt;&lt;img src=“<a href=\"https://img.alicdn.com/tfs/TB17DTuXkH0gK0jSZPiXXavapXa-680-133.svg\">https://img.alicdn.com/tfs/TB17DTuXkH0gK0jSZPiXXavapXa-680-133.svg</a>” width=“100px;”/&gt;&lt;br /&gt;\n&lt;sub&gt;&lt;b&gt;优酷视频\n&lt;/b&gt;&lt;/td&gt;\n&lt;td align=“center”&gt;&lt;a target=&quot;_blank&quot; href=“<a href=\"https://yulebao.alibaba.com/\">https://yulebao.alibaba.com/</a>”&gt;&lt;img src=“<a href=\"https://gw.alicdn.com/tfs/TB1CmlIIFT7gK0jSZFpXXaTkpXa-190-46.png\">https://gw.alicdn.com/tfs/TB1CmlIIFT7gK0jSZFpXXaTkpXa-190-46.png</a>” width=“100px;”/&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;阿里影业娱乐宝\n&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;/td&gt;\n&lt;td align=“center”&gt;&lt;a target=&quot;_blank&quot; href=“<a href=\"http://ssr-fc.com/\">http://ssr-fc.com/</a>”&gt;&lt;img src=“<a href=\"https://img.alicdn.com/tfs/TB13DzOjXP7gK0jSZFjXXc5aXXa-212-48.png\">https://img.alicdn.com/tfs/TB13DzOjXP7gK0jSZFjXXc5aXXa-212-48.png</a>” width=“100px;”/&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;部署于阿里云示例应用\n&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;/td&gt;\n&lt;td align=“center”&gt;&lt;a target=&quot;_blank&quot; href=“<a href=\"http://tx.ssr-fc.com/\">http://tx.ssr-fc.com/</a>”&gt;&lt;img src=“<a href=\"http://s0.60logo.com/uploads/items/images/soft/180126/tengxunyun.svg\">http://s0.60logo.com/uploads/items/images/soft/180126/tengxunyun.svg</a>” width=“100px;”/&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;部署于腾讯云示例应用\n&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;</p>\n<h2>快速开始</h2>\n<p>开发者只需 5 分钟就可以快速的创建并发布一个 SSR 应用上线</p>\n<h3>环境准备</h3>\n<pre class=\"prettyprint language-bash\"><code>$ node -v # 建议版本&gt;=v10.15.0\nv12.16.1\n</code></pre><h3>创建项目</h3>\n<p>我们使用 <a href=\"https://github.com/zhangyuang/create-ssr-app\">create-ssr-app</a> 来快速的创建项目</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm init ssr-app my-ssr-project\n$ cd my-ssr-project\n</code></pre><h3>本地开发</h3>\n<pre class=\"prettyprint language-bash\"><code>$ npm i\n$ npm start # 等价于 ssr start\n$ open http:&#x2F;&#x2F;localhost:3000\n</code></pre><p>为了方便开发我们建议全局安装 <code>ssr</code> 模块 <code>npm i -g ssr</code> 这样可以很方便的通过在命令行使用 <code>ssr xxx</code> 等命令来开发部署应用</p>\n<h3>资源构建</h3>\n<pre class=\"prettyprint language-bash\"><code>$ npm run build # 等价于 ssr build\n$ GENERATE_ANALYSIS=true npm run build # 可视化生成构建产物\n$ npm run build --func=index # 对指定函数进行构建(支持中)\n</code></pre><h3>发布到阿里云</h3>\n<p>发布命令</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm run deploy # 支持发布多个平台默认发布到阿里云 等价于 ssr deploy\n</code></pre><p>首次发布需要输入阿里云账户信息，并且在阿里云控制台开通函数计算服务。账户信息在函数计算<a href=\"https://fc.console.aliyun.com/fc\">控制台</a>查看。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1fZzQB.z1gK0jSZLeXXb9kVXa-1446-1262.jpg\" alt></p>\n<p>将 AccountId 以及 Key Secret 在下面输入，只需要输入一次信息会储存在本地，之后 deploy 无需做该操作。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB10vYVBYY1gK0jSZTEXXXDQVXa-2044-528.jpg\" alt></p>\n<p>发布成功后得到一个 http 地址<code>https://1812856288776972.cn-shanghai.fc.aliyuncs.com/***</code>。由于阿里云安全限制，无法直接在浏览器查看。需要手动配置域名转发过去。<code>阿里云控制台域名服务</code> -&gt; <code>域名解析设置</code> -&gt; <code>函数计算控制台</code> -&gt; <code>自定义域名</code>。之后打开<a href=\"http://ssr-fc.com\">域名</a>便能够访问到发布的函数。</p>\n<p><img src=\"https://gw.alicdn.com/tfs/TB1yfjUB4D1gK0jSZFKXXcJrVXa-1212-680.jpg\" alt></p>\n<p><img src=\"https://gw.alicdn.com/tfs/TB1g_CwB7P2gK0jSZPxXXacQpXa-1254-698.jpg\" alt></p>\n<p><img src=\"https://gw.alicdn.com/tfs/TB1JZGyB1H2gK0jSZFEXXcqMpXa-1468-1012.jpg\" alt></p>\n<h3>发布到腾讯云</h3>\n<p>无需做任何配置文件的修改即可一键发布到腾讯云！</p>\n<p>发布命令</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm run dploy:tencent # 发布到腾讯云 等价于 ssr deploy --tencent\n</code></pre><p>首次发布时需要使用微信扫终端展示的二维码注册/登陆腾讯云服务。<br>\n如果想详细的了解腾讯云发布功能可参考<a href=\"https://www.yuque.com/midwayjs/faas/deploy_tencent_faq\">文档</a>\n发布后同样我们可以得到平台返回的一个地址, 需要绑定域名后才能正确的访问页面渲染服务。否则由于访问 /test 路径造成服务端路由和客户端路由不一致会导致页面内容闪现后白屏。<br>\n<img src=\"https://res.wx.qq.com/op_res/mbNMsqF_px3tS0x_x1fryyR3Z5RipX3Lo8PIzvcAVxyXwoQyvQz0lQev-W2io3AP\" alt>\n默认发布到测试环境, 这里建议在第一次发布后显示在 yml 中指定要发布的<a href=\"https://www.yuque.com/midwayjs/faas/deploy_tencent_faq\">serviceID</a>, 否则每次发布将会创建一个新的 server 实例。<br>\n在腾讯云<a href=\"https://console.cloud.tencent.com/apigateway/service-detail\">API</a>网关平台进行域名的绑定以及函数发布到正式环境的操作<br>\n在腾讯云<a href=\"https://console.cloud.tencent.com/scf\">SCF</a>平台可以进行函数的管理调试以及日志查看\n如何复用 serviceId 如下</p>\n<pre class=\"prettyprint language-yml\"><code>service:\n  name: serverless-ssr-spa\nprovider:\n  name: aliyun # 无需修改 name 通过 ssr deploy --tencent 指定腾讯云即可\n  region: ap-hongkong\n  serviceId: service-xxx\n</code></pre><h4>绑定域名</h4>\n<p>在发布到腾讯云时 midway-faas 支持通过 <a href=\"https://www.yuque.com/midwayjs/faas/serverless_yml\">provider.region</a> 来设置发布的服务器区域。<br>\n如果发布的区域是国内则绑定的域名需要在腾讯云进行备案服务，如果是香港则无需备案。默认绑定域名后需要通过 <a href=\"http://tx.ssr-fc.com\">tx.ssr-fc.com/release</a> 来访问具体的环境。也可以通过自定义路径映射使得不需要添加 /release 也可以访问到具体的环境。\n<img src=\"https://res.wx.qq.com/op_res/Ln1MuNWmmfNDyTuJlooXiGdhwtCtz_4rVDi_qvmuUEoL_mo6PNsd3z4d7z9RBj17\" alt></p>\n<h3>线上案例</h3>\n<pre class=\"prettyprint language-bash\"><code>$ open http:&#x2F;&#x2F;ssr-fc.com&#x2F; # 发布到阿里云的函数\n$ open http:&#x2F;&#x2F;ssr-fc.com?csr=true # 以csr模式运行\n$ open http:&#x2F;&#x2F;tx.ssr-fc.com&#x2F; # 发布到腾讯云的函数\n$ open http:&#x2F;&#x2F;tx.ssr-fc.com?csr=true # 以csr模式运行\n</code></pre><h3>结合阿里云开发平台</h3>\n<p>本框架可结合阿里云开发平台，使用 CloudIDE 全程上云开发 Serverless SSR 应用使用方式可参考该<a href=\"https://zhuanlan.zhihu.com/p/139210473\">教程</a>。</p>\n<h2>开发规范</h2>\n<p><code>注：本规范适用于绝大多数的业务场景，如需额外定制请先想清楚是否必要!</code></p>\n<h3>前端技术选型</h3>\n<ul>\n<li>前端框架: React v17, 实时跟进 React17的新特性</li>\n<li>开发语言: TypeScript</li>\n<li>代码风格: <a href=\"https://standardjs.com/\">Standard</a></li>\n<li>样式处理: less + css modules</li>\n<li>UI 组件: 默认已对 antd 的使用做打包配置无需额外配置</li>\n<li>前端路由: 约定式路由</li>\n<li>数据管理: 使用 React Hooks 提供的 useContext + useReducer 实现极简的数据管理方案, 摒弃传统的 redux/dva 等数据管理方案</li>\n</ul>\n<h3>本地调试</h3>\n<p>借助 <a href=\"https://github.com/visionmedia/debug\">debug</a> 模块的能力，开发者可以在本地开发过程中获取一些构建渲染过程的信息。</p>\n<pre class=\"prettyprint language-bash\"><code>$ DEBUG=ssr:* npm start # 打印所有的 ssr 模块提供的 debug 信息\n$ DEBUG=ssr:parse npm start # 打印约定式路由解析 debug 信息\n$ DEBUG=ssr:render npm start # 打印页面渲染 debug 信息\n</code></pre><h3>应用原理解析</h3>\n<p>点击<a href>此处</a>查看高清大图\n<img src alt></p>\n<h3>不同页面组件进行数据共享</h3>\n<p>通过使用 <code>useContext</code> 来获取全局的 <code>context</code>, <code>useContext</code> 返回两个值分别为</p>\n<ul>\n<li>state: 全局的状态，可在不同的组件/页面之间共享</li>\n<li>dispatch: 通过 <code>disptach</code> 来触发类型为 <code>updateContext</code> 的 <code>action</code> 来更新全局的 <code>context</code></li>\n</ul>\n<p><code>注: hooks 只能够在函数组件内部使用</code></p>\n<pre class=\"prettyprint language-ts\"><code>import { useContext } from &#x27;react&#x27;\nimport { IContext } from &#x27;ssr-types&#x27;\n\nconst { state, dispatch } = useContext&lt;IContext&lt;IData&gt;&gt;(window.STORE_CONTEXT) &#x2F;&#x2F; 通过 IData 指定业务自己的 data interface\n</code></pre><p>通过 <code>dispatch action</code> 来触发全局 <code>context</code> 的更新，并通知到所有的组件。<br>\n<code>注: dispatch 是异步的只能够在客户端渲染的阶段使用，服务端使用无效。context 更新会导致所有组件重新 render 可根据实际情况使用 React.useMemo 来避免不必要的重新计算，且建议根据不同的模块使用不同的 namespace 防止数据覆盖</code></p>\n<pre class=\"prettyprint language-js\"><code>import React, { useContext } from &#x27;react&#x27;\nimport styles from &#x27;.&#x2F;index.less&#x27;\n\nfunction Search (props) {\n  const { state, dispatch } = useContext&lt;IContext&lt;SearchState&gt;&gt;(window.STORE_CONTEXT)\n  const handleChange = e =&gt; {\n    dispatch({\n      type: &#x27;updateContext&#x27;,\n      payload: {\n        search: {\n          &#x2F;&#x2F; 搜索框模块的 namespace 为 search\n          text: e.target.value\n        }\n      }\n    })\n  }\n   return (\n    &lt;div className={styles.searchContainer}&gt;\n      {&#x2F;* 这里需要给 value 一个兜底的状态 否则 context 改变 首次 render 的 text 值为 undefined 会导致 input 组件 unmount *&#x2F;}\n      {&#x2F;* ref: https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;47012169&#x2F;a-component-is-changing-an-uncontrolled-input-of-type-text-to-be-controlled-erro&#x2F;47012342 *&#x2F;}\n      &lt;input type=&quot;text&quot; className={styles.input} value={state.search?.text ?? &#x27;&#x27;} onChange={handleChange} placeholder=&quot;该搜索框内容会在所有页面共享&quot;&#x2F;&gt;\n      &lt;img src=&quot;https:&#x2F;&#x2F;img.alicdn.com&#x2F;tfs&#x2F;TB15zSoX21TBuNjy0FjXXajyXXa-48-48.png&quot; alt=&quot;&quot; className={styles.searchImg} onClick={toSearch}&#x2F;&gt;\n    &lt;&#x2F;div &gt;\n  )\n}\n\nexport default Search\n\n</code></pre><p><code>注: 我们只推荐在跨组件通信时使用 dispatch，局部状态不推荐使用，会导致函数内部状态过于复杂，难以阅读。</code></p>\n<p>关于更多 hooks 使用的最佳实践可以参考该<a href=\"https://zhuanlan.zhihu.com/p/81752821\">文章</a></p>\n<h3>应用类型</h3>\n<p>由于本框架同时具备 SSR 服务端渲染能力 以及 loadable 代码分割能力。我们天生可以看作既是单页面应用也是多页面应用。表现如下</p>\n<ul>\n<li>用户可以通过 react-router 的形式进行页面之间的跳转。此时是纯前端的跳转不会向服务器发送请求视为单页面应用页面之间的互相跳转</li>\n<li>同时用户也可以通过 a 标签的形式来进行页面之间的跳转。此时视为在服务端渲染一个新页面。视为多页面应用之间的互相跳转，由于我们具备 SSR 能力，此时页面的源代码是新页面具备 SEO 能力以及首屏直出页面能力</li>\n<li>每个独立页面之间的代码是互相分离互不冗余的</li>\n</ul>\n<h4>应用介绍</h4>\n<p>注意：</p>\n<ul>\n<li>我们的策略是将所有负责页面渲染的服务端路由都对应同一个 FaaS 函数。例如 首页和详情页是打到同一个 FaaS 函数。共享函数的资源。优势是便于开发管理。且每一个服务端路由都可对应多个前端路由</li>\n<li>如果你一定要将首页和详情页分别部署到不同的函数。我们建议你分成两个 Repo 分别进行开发部署</li>\n</ul>\n<h5>目录结构</h5>\n<p>这里我们使用约定式前端路由。无需手动声明路由配置文件，会根据文件夹名称及路径自动生成路由配置。</p>\n<pre class=\"prettyprint language-bash\"><code>.\n├── build # web目录构建产物\n│   └── index # 函数名称\n│       ├── client\n│       └── server\n├── config.js # 定义应用的配置\n├── f.yml\n├── package.json\n├── src # 存放faas函数的handler\n│   └── index.ts\n├── tsconfig.json\n├── web\n│   ├── components # 存放公共组件\n│   │   └── header\n│   │   │   ├── index.less\n│   │   │   └── index.tsx\n│   │   └── layout # SPA应用只需要一个默认的layout\n│   │       ├── index.less\n│   │       └── index.tsx\n│   ├── pages # pages目录下的文件夹会映射为前端路由\n│   │   ├── index # index文件夹映射为根路由\n│   │   │   ├── fetch.ts # 定义fetch文件用来获取数据，会自动注入到组件的props中\n│   │   │   ├── index.less\n│   │   │   └── render.tsx # 定义render文件用来定义页面渲染逻辑\n│   │   └── detail\n│   │       ├── fetch.ts\n│   │       ├── index.less\n│   │       └── render$id.tsx # 映射为&#x2F;detail&#x2F;:id\n│   │       └── render$id$.tsx # 映射为&#x2F;detail&#x2F;:id?\n│   ├── tsconfig.json # 仅用于编辑器ts语法检测\n│   └── typings.d.ts\n</code></pre><h5>yml 文件编写规范</h5>\n<pre class=\"prettyprint language-yml\"><code>service:\n  name: serverless-ssr\nprovider:\n  name: aliyun\n\nfunctions:\n  index:\n    handler: index.handler\n    render: # 定义页面渲染服务\n      mode: ssr\n    events:\n      - http:\n          path: &#x2F;\n          method: get\n      - http:\n          path: &#x2F;detail&#x2F;*\n          method: get\n  api-index: # 定义api接口服务\n    handler: api.handler\n    events:\n      - http:\n          path: &#x2F;api&#x2F;index\n          method: get\n  api-detail:\n    handler: api.detail.handler\n    events:\n      - http:\n          path: &#x2F;api&#x2F;detail&#x2F;*\n          method: get\n\npackage:\n  artifact: code.zip\n</code></pre><h5>如何发布</h5>\n<pre class=\"prettyprint language-bash\"><code>$ ssr deploy # 默认发布到阿里云\n$ ssr deploy --tencent # 发布到腾讯云\n</code></pre><h5>展示形式</h5>\n<p><a href=\"http://ssr-fc.com/\">http://ssr-fc.com/</a> -&gt; index 函数 -&gt; 渲染 index 组件<br>\n<a href=\"http://ssr-fc.com/detail/*\">http://ssr-fc.com/detail/*</a> -&gt; index 函数 -&gt; 渲染 detail 组件</p>\n<h3>渲染函数</h3>\n<p>1）在 FaaS 函数里</p>\n<p>在 FaaS 函数里，只需要调用 ssr-core 提供的 render 方法传入 ctx 即可</p>\n<pre class=\"prettyprint language-js\"><code>import { render } from &#x27;ssr-core&#x27;\n\nasync handler () {\n  try {\n    const htmlStr = await render(this.ctx)\n    return htmlStr\n  } catch (error) {\n    return error\n  }\n}\n</code></pre><p>根据 f.yml 或者 query 来判断当前渲染模式</p>\n<p>2）在 Node.js Web 框架里</p>\n<p>该渲染方式实现是服务端无关的，理论上可以支持任何 Node.js 框架只需引入 render 方法以及有一个 web 目录，用法与 Faas 函数保持一致。</p>\n<pre class=\"prettyprint\"><code>const Koa = require(&#x27;koa&#x27;);\nconst { render } = require(&#x27;ssr-core&#x27;)\nconst app = new Koa();\n\n&#x2F;&#x2F;  mount routes from config\napp.use(ssr)\n\n&#x2F;&#x2F; ctx.ssrRender()\napp.get(&#x27;&#x2F;*&#x27;, async ctx =&gt; {\n  ctx.body = render(ctx)\n});\n\napp.listen(3000);\n</code></pre><h3>模式切换</h3>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; url查询参数或者头信息\nconf.mode = req.query.ssr || req.headers[&#x27;x-mode-ssr&#x27;]\n</code></pre><ul>\n<li>ssr(conf)\n<ul>\n<li>cookie</li>\n<li>querystring</li>\n<li>header</li>\n</ul>\n</li>\n</ul>\n<p>此处需要考虑优先级，比如 querystring 第一，其次是 f.yml 里的 render.mode。</p>\n<h2>配置</h2>\n<p>config.js 支持以下配置, 默认配置已适用于绝大部分应用, 无特殊需求不要修改</p>\n<pre class=\"prettyprint language-js\"><code>{\n  cwd: string; &#x2F;&#x2F; 设置命令执行的cwd，默认为 process.cwd()，无特殊需求不需修改\n  isDev: boolean; &#x2F;&#x2F; 当前运行环境，默认为 process.env.NODE_ENV\n  publicPath: string; &#x2F;&#x2F; webpack-dev-server 的publishPath，默认为 &#x2F;\n  useHash: boolean; &#x2F;&#x2F; 生成文件是否带有 hash，默认本地运行关闭，生产环境构建时开启\n  port: number; &#x2F;&#x2F; 前端静态资源本地开发时的监听端口，默认为 8000FaaS Server 会自动 proxy,无特殊需求不需要修改\n  faasPort: number; &#x2F;&#x2F; 本地开发启动的FaaS 服务的端口，默认为3000\n  chunkName: string; &#x2F;&#x2F; 生成的bundle的chunkName，默认为Page,无特殊需求不要修改\n  webpackDevServerConfig: webpackDevServer.Configuration; &#x2F;&#x2F; webpack-dev-server 启动配置\n  staticPrefix: string; &#x2F;&#x2F; 加载的静态资源前缀，需要发布到单独的cdn服务时可以使用该配置设置为cdn服务的地址\n  chainServerConfig: (config: Config) =&gt; Configuration; &#x2F;&#x2F; 使用 webpack-chain 来修改服务端 wbepack 构建配置\n  chainClientConfig: (config: Config) =&gt; Configuration; &#x2F;&#x2F; 使用 webpack-chain 来修改服务端 wbepack 构建配置\n  whiteList: RegExp[]; &#x2F;&#x2F; 设置服务端构建配置 externals 的白名单，即需要让 webpack 来处理的模块\n  cssModulesWhiteList: RegExp[]; &#x2F;&#x2F; 设置该选项指定样式文件不用 css-modules 处理，防止样式和 className 不匹配\n  prefix: string; &#x2F;&#x2F; 为前端路由添加统一的prefix, 如 &#x2F;${prefix}&#x2F;, &#x2F;${prefix}&#x2F;detail&#x2F;:id\n  proxy: {\n    &#x2F;&#x2F; 底层使用 http-proxy-middleware 来进行代理, 具体配置查看 http-proxy-middleware 文档即可\n   &#x27;&#x2F;api&#x27;: {\n      target: &#x27;xxx&#x27;\n   }\n  },\n  dynamic?: boolean &#x2F;&#x2F; 是否启用代码分割优化代码，默认为 true\n}\n\n</code></pre><h2>FAQ</h2>\n<p>遇到问题先去该<a href=\"http://ykfe.surge.sh/guide/faq.html\">文档</a>找答案，该文档列举了开发 SSR 应用可能会遇到的大部分问题。如果没有预期的答案再提 issue</p>\n<h2>CONTRIBUTING</h2>\n<p>如果你想为本应用贡献代码，请阅读<a href>贡献文档</a>，我们为你准备了丰富的脚本用于 bootstrap</p>\n<h2>License</h2>\n<p><a href>MIT</a></p>\n<h2>答疑群</h2>\n<p>虽然我们已经尽力检查了一遍应用，但仍有可能有疏漏的地方，如果你在使用过程中发现任何问题或者建议，欢迎提<a href=\"https://github.com/ykfe/ssr/issues\">issue</a>或者<a href=\"https://github.com/ykfe/ssr/pulls\">PR</a>\n欢迎直接扫码加入钉钉群\n<img src=\"https://res.wx.qq.com/op_res/gQfTCN-BGtR7Luw1CjnJoJiPt7MDmyxl_G-LAyR4Wp4l8R9ISlTWj6yLuLt41zTO4nwneqdAd9g5-QnMt9qKTQ\" alt></p>\n</div>",
      "title": "Serverless场景下最强大的SSR框架正式发布",
      "author": {
        "loginname": "zhangyuang",
        "avatar_url": "https://avatars.githubusercontent.com/u/17424434?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 172,
      "country": "USA"
    },
    {
      "id": "5e4be9ad1225c9423dcda5b9",
      "content": "<div class=\"markdown-text\"><p>示范代码  (最近在学 RxJS)\nimport { range } from ‘rxjs’;\nimport { map, filter } from ‘rxjs/operators’;\nrange(1, 200).pipe(\nfilter(x =&gt; x % 2 === 1),\nmap(x =&gt; x + x)\n).subscribe(x =&gt; console.log(x));</p>\n<p>报错\nimport { range } from ‘rxjs’;\n^^^^^^</p>\n<p>SyntaxError: Cannot use import statement outside a module\nat wrapSafe (internal/modules/cjs/loader.js:1071:16)\nat Module._compile (internal/modules/cjs/loader.js:1121:27)\nat Object.Module._extensions…js (internal/modules/cjs/loader.js:1177:10)\nat Module.load (internal/modules/cjs/loader.js:1001:32)\nat Function.Module._load (internal/modules/cjs/loader.js:900:14)\nat Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\nat internal/main/run_main_module.js:18:47</p>\n<p>环境信息  MacOS  10.11.6   Node 12.16.0<br>\n猜测 node 对ES6  Imports  支持 有限。\ngoogle 关键词  node es6 import run\nso 链接 <a href=\"https://stackoverflow.com/questions/45854169/how-can-i-use-an-es6-import-in-node\">https://stackoverflow.com/questions/45854169/how-can-i-use-an-es6-import-in-node</a>\n高赞答案 要上Node13 ，\n尝试 第二个答案， 安装esm   解决问题</p>\n</div>",
      "title": "解决 SyntaxError: Cannot use import statement outside a module 报错",
      "author": {
        "loginname": "luojiyin1987",
        "avatar_url": "https://avatars.githubusercontent.com/u/6524977?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 173,
      "country": "China"
    },
    {
      "id": "611cb553baed4eae94b840b8",
      "content": "<div class=\"markdown-text\"><p>各位好，我和朋友开发了一套面向后端程序员的生产力工具 —— <a href=\"http://kalacloud.com/?utm_source=cnodejs&amp;utm_medium=p06\">卡拉云</a>，帮助后端程序员快速搭建企业内部后台的工具。</p>\n<p>目前已经上线，正在内测中，第一批种子用户反馈还不错，也很想听听大家的意见。</p>\n<p><strong>一、我们解决的问题</strong>\n将多数据源组合在一起，快速搭建一套企业内部后台。数周的工作量降低至几天，极大的提升开发效率。\n1.快速接入 API\n2.快速接入 常见的数据库\n3.前端组件拖放、与数据源轻松连接\n<img src=\"//static.cnodejs.org/FnYx8s7Gz75mwsbTnpI9WJUgj6kU\" alt=\"卡拉云可快速接入常见的api与数据库\"></p>\n<p><strong>二、使用场景</strong>\n多数据源融合，前端展现编辑处理，返回数据源。</p>\n<p>1.案例一：一家社区类app，社区中高级用户需要认证自己的账号，认证账号填写一份申请资料表。\n之后社区运营会根据这张表判断是否符合认证需求。最后在数据库中修改该用户对应账号的状态。\n<img src=\"//static.cnodejs.org/Flfpf8eOL6Hy-t3XmorE7T3FREBS\" alt=\"面包多搭建动图.gif\">\n数据源：\n（1）用户填写账号认证<a href=\"https://jinshuju.net/f/s5InEp\">申请表</a> -&gt; 金数据 API\n（2）运营人员审核用户并更改用户状态 -&gt; 自己的数据库</p>\n<p><img src=\"https://duckfiles.oss-cn-qingdao.aliyuncs.com/eleduck/image/f8c7900d-08f1-4ad9-90f0-35d267fa25d9.png\" alt=\"卡拉云搭建的认证后台\">\n运营前端操作：\n（1）根据用户填写的金数据表格数据、社区数据库中用户详情，判断是否给予认证\n（2）根据规则等级，修改认证用户的账号权限\n（3）将修改后的数据提交至数据库中</p>\n<p>我在B站做了个讲解视频，录的不太好，还请见谅 -&gt; <a href=\"https://www.bilibili.com/video/BV1mV411s7Fv/\">如何使用卡拉云快速搭建用户认证审核系统</a></p>\n<p>2.其他案例：</p>\n<p>（1）某地方网约车公司，使用卡拉云搭建「用户端、司机端钱包余额审核退款后台」\n（2）某地方网约车公司，使用卡拉云搭建「司机端人脸、身份证、驾照审核认证后台」\n（3）某地产企业，使用卡拉云，搭建「小程序内容上传后台」\n（4）某活动公司，使用卡拉云，搭建「电子票核销后台」\n（5）某电商公司，使用卡拉云，搭建「线上优惠券发放核销后台」\n（6）某在线教育，使用卡拉云，搭建「支付宝微信财务对账后台」\n（7）某法务公司，使用卡拉云，搭建「合同审核管理后台」</p>\n<p><strong>三、我们正在寻找种子用户</strong></p>\n<p>我们团队一共两个人，人手不够也并不太擅长做市场。还请大家多多帮助。</p>\n<p>我们已经帮助非常多轻后端的创业公司解决了后台开发效率的问题，如果您的工作中也有类似后台搭建的场景话，欢迎来试试我们的卡拉云。</p>\n<p><strong>【【【目前我们还没有开放注册，请加我微信 HiJiangChuan ，我来给您开账号。】】】</strong></p>\n</div>",
      "title": "我们开发了一套面向后端程序员的生产力工具，正在内测中，欢迎试用",
      "author": {
        "loginname": "JiangTianZheng",
        "avatar_url": "https://avatars.githubusercontent.com/u/17161752?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 174,
      "country": "China"
    },
    {
      "id": "611b1ca5baed4e0577b8382b",
      "content": "<div class=\"markdown-text\"><p>上文说到，我对《你的性格主导色》活动中最感兴趣的部分就是通过 <code>Three.js</code> 实现穿越云层动效了，据作者说每朵云出现的位置都是随机的，效果很好，下图是我实现的版本。</p>\n<p><img src=\"https://i.loli.net/2021/08/11/iQlAp3ePza64fZJ.gif\" alt></p>\n<p>在线 <a href=\"https://hezf-music.vercel.app/\">Demo</a></p>\n<p>首先说下实现穿越云层动效的基本思路：</p>\n<ol>\n<li>沿着Z轴均匀的放一堆64*64的平面图形，这些平面的X坐标和Y坐标是随机的（很像下图的桶装薯片）</li>\n<li>把上面的所有图形合并成一个大的图形</li>\n<li>把大的图形和贴片材质（云）生成网格，网格放进场景中</li>\n<li>动效就是将相机从远处沿着Z轴缓慢移动，就会有了穿越云层的效果</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/08/17/gQXypJ7UblejCGz.jpg\" alt></p>\n<p>首先官方文档提供了一个<a href=\"https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene\">创建一个场景</a>的快速开始，阅读后可以对下面的内容更好的理解。</p>\n<p>下面介绍下<code>Three.js</code>中的基本概念。仅限我这新手的理解。有讲的好的文档或者分享，欢迎帮忙指个路。</p>\n<h2>场景</h2>\n<p>场景就是一块空间，用来装下我们想要渲染的内容。最简单的用处就是，场景可以添加一个网格，然后渲染出来。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 初始化场景\nvar scene = new THREE.Scene();\n\n&#x2F;&#x2F; 其他代码...\n&#x2F;&#x2F; 把物体添加进场景\nscene.add(mesh);\n&#x2F;&#x2F; 渲染场景\nrenderer.render(scene, camera);\n</code></pre><p>这里说下场景中的坐标规则：原点是canvas 的平面中心，Z轴垂直于X、Y轴，正向是冲着我们的，我这里把Z轴的线做了些旋转，不然我们看不到，如下图：</p>\n<p><img src=\"https://i.loli.net/2021/08/16/mCsLi25byTHAWVB.png\" alt></p>\n<p>代码：</p>\n<pre class=\"prettyprint\"><code> const scene = new THREE.Scene();\n\n  var camera = new THREE.PerspectiveCamera(70, window.innerWidth &#x2F; window.innerHeight, 1, 1000);\n  camera.position.set(0, 0, 100);\n\n  const renderer = new THREE.WebGLRenderer();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  document.body.appendChild(renderer.domElement);\n\n  &#x2F;&#x2F; 线段1，红色的，从原点到X轴40\n  const points = [];\n  points.push(new THREE.Vector3(0, 0, 0));\n  points.push(new THREE.Vector3(40, 0, 0));\n  const geometry1 = new THREE.BufferGeometry().setFromPoints(points);\n  var material1 = new THREE.LineBasicMaterial({ color: &#x27;red&#x27; });\n  var line1 = new THREE.Line(geometry1, material1);\n\n  &#x2F;&#x2F; 线段2，蓝色的，从原点到Y轴40\n  points.length = 0;\n  points.push(new THREE.Vector3(0, 0, 0));\n  points.push(new THREE.Vector3(0, 40, 0));\n  const geometry2 = new THREE.BufferGeometry().setFromPoints(points);\n  var material2 = new THREE.LineBasicMaterial({ color: &#x27;blue&#x27; });\n  var line2 = new THREE.Line(geometry2, material2);\n\n  &#x2F;&#x2F; 线段3，绿色的，从原点到Z轴40\n  points.length = 0;\n  points.push(new THREE.Vector3(0, 0, 0));\n  points.push(new THREE.Vector3(0, 0, 40));\n  const geometry3 = new THREE.BufferGeometry().setFromPoints(points);\n  var material3 = new THREE.LineBasicMaterial({ color: &#x27;green&#x27; });\n  var line3 = new THREE.Line(geometry3, material3);\n  &#x2F;&#x2F; 做了个旋转，不然看不到Z轴上的线\n  line3.rotateX(Math.PI &#x2F; 8);\n  line3.rotateY(-Math.PI &#x2F; 8);\n\n  scene.add(line1, line2, line3);\n\n  renderer.render(scene, camera);\n</code></pre><h2>相机</h2>\n<p>场景内的物体要想被我们看见，也就是渲染出来，需要相机去“看”，通过上面的坐标系图，我们知道同一个物体，相机观察的角度不同，肯定也会呈现出不一样的画面。最常用的就是这里用的透视相机，可以穿透物体，用在这里正好穿透云层，效果拔群。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 初始化相机\ncamera = new THREE.PerspectiveCamera(70, pageWidth &#x2F; pageHeight, 1, 1000);\n\n&#x2F;&#x2F; 最后，场景和相机一起渲染出来，我们就能够看到场景中的物体了\nrenderer.render(scene, camera);\n\n</code></pre><h2>材质</h2>\n<p>材质很好理解，在最初的例子中，使用<code>MeshBasicMaterial</code>给立方体添加了颜色。材质的使用方式是，将材质和图形共同生成一个网格，我们这里使用的是比较复杂的贴图材质。</p>\n<pre class=\"prettyprint\"><code>  &#x2F;&#x2F; 贴图材质\n  const material = new THREE.ShaderMaterial({\n    &#x2F;&#x2F; 这里的值是给着色器传递的\n    uniforms: {\n      map: {\n        type: &#x27;t&#x27;,\n        value: texture\n      },\n      fogColor: {\n        type: &#x27;c&#x27;,\n        value: fog.color\n      },\n      fogNear: {\n        type: &#x27;f&#x27;,\n        value: fog.near\n      },\n      fogFar: {\n        type: &#x27;f&#x27;,\n        value: fog.far\n      }\n    },\n    vertexShader: vShader,\n    fragmentShader: fShader,\n    transparent: true\n  });\n</code></pre><h2>图形和网格</h2>\n<p><code>Three.js</code>默认提供了很多的几何体图形，也就是各种<code>Geometry</code>，他们的基类是<code>BufferGeometry</code>。</p>\n<p>图形可以进行合并，像这里就是clone了很多个一样的平面图形，通过修改各自的位置，生成合并后形成一大片云的效果。</p>\n<p>最初我认为图形和网格是一个概念，后来知道了，材质和图形可以生成网格，网格可以放进场景中。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 把上面合并出来的形状和材质，生成一个网格\nmesh = new THREE.Mesh(mergedGeometry, material);\n</code></pre><h2>渲染</h2>\n<p>将场景和相机渲染到目标元素上，会生成一个<code>canvas</code>，如果是一个静态的场景，那么渲染完毕就可以了。但是如果是一个会动的场景，这里需要用到一个原生函数<code>requestAnimationFrame</code>。</p>\n<pre class=\"prettyprint\"><code>function animate() {\n  requestAnimationFrame(animate);\n  renderer.render(scene, camera);\n}\n</code></pre><p>上面的代码是一个渲染循环，在一般屏幕上的频率是60HZ，在高刷屏幕上会增长刷新频率，也就是会给用户良好的刷新体验，不需要我们自己使用<code>setInterval</code>去控制。并且当用户切换到其它的标签页时，它会暂停刷新，不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。</p>\n<h2>揭秘过程</h2>\n<p>过程其实很有意思，也很曲折。</p>\n<p>扒下来了《你的性格主导色》活动的前端代码，但是云层动效相关有很多代码压缩过了，看不懂。</p>\n<p>怎么办？然后我就去 <code>three.js</code> 找官方的例子去，找了半天只找到一个下图这样的：</p>\n<p><img src=\"https://i.loli.net/2021/08/16/Dpnbo93lqJYh7EK.png\" alt></p>\n<p>后来经过各种搜索，终于在<code>three.js</code>的<a href=\"https://discourse.threejs.org/t/flying-through-clouds/14203\">讨论区</a>发现了这种穿越云层的特效，是<code>three.js</code>的作者很久之前写的例子。</p>\n<p>把云层动效源码拿到手以后，我对比后感觉 <code>imyzf</code> 同学应该也是从这个例子中借鉴了一下。</p>\n<p>我发现源码中的<code>three.js</code>的版本有一些落后，源码中的版本是55，最新的是131版本，版本差距有点大，已经没有了上面的一些类和API，下面介绍下不同的部分：</p>\n<h3>THREE.Geometry</h3>\n<p>首先就是这个类在最新版没有了，这个类是用来将很多个平面图形，合并为一个图形。观察下面的代码，55的版本是先生成一个<code>Geometry</code>，然后生成一个平面网格，再把网格和<code>Geometry</code>合并。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 初始化一个基础的图形\ngeometry = new THREE.Geometry();\n&#x2F;&#x2F; 初始化一个64*64的平面\nvar plane = new THREE.Mesh(new THREE.PlaneGeometry(64, 64));\n\nfor (var i = 0; i &lt; 8000; i++) {\n  &#x2F;&#x2F; 调整平面图案的位置和旋转角度等\n  plane.position.x = Math.random() * 1000 - 500;\n  plane.position.y = -Math.random() * Math.random() * 200 - 15;\n  plane.position.z = i;\n  plane.rotation.z = Math.random() * Math.PI;\n  plane.scale.x = plane.scale.y = Math.random() * Math.random() * 1.5 + 0.5;\n  &#x2F;&#x2F; 平面合并到基础图形\n  THREE.GeometryUtils.merge(geometry, plane);\n}\n</code></pre><p>经过对最新文档的查询后，发现所有图形的基类<code>BufferGeometry</code>提供clone方法，平面图形自然也可以被clone出来。</p>\n<pre class=\"prettyprint\"><code>  &#x2F;&#x2F; 一个平面形状\n  const geometry = new THREE.PlaneGeometry(64, 64);\n  const geometries = [];\n\n  for (var i = 0; i &lt; CloudCount; i++) {\n    const instanceGeometry = geometry.clone();\n\n    &#x2F;&#x2F; 把这个克隆出来的云，通过随机参数，做一些位移，达到一堆云彩的效果，每次渲染出来的云堆都不一样\n    &#x2F;&#x2F; X轴偏移后，通过调整相机位置达到平衡\n    &#x2F;&#x2F; Y轴想把云彩放在场景的偏下位置，所以都是负值\n    &#x2F;&#x2F; Z轴位移就是：当前第几个云*每个云所占的Z轴长度\n    instanceGeometry.translate(Math.random() * RandomPositionX, -Math.random() * RandomPositionY, i * perCloudZ);\n\n    geometries.push(instanceGeometry);\n  }\n\n  &#x2F;&#x2F; 把这些形状合并\n  const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries);\n</code></pre><h3>GeometryUtils.merge</h3>\n<p>旧代码码中有一个这样的API，这是一个很重要的API，目的就是产生这一大片的云，然后通过相机去看，最新版的<code>three.js</code>已经没有了。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 合并所有的平面图形到一个基础图形\nTHREE.GeometryUtils.merge(geometry, plane);\n</code></pre><p>通过查询最新版的文档，发现了可以将一组图形进行合并，个人觉得比上面的好一些，语义上好很多。上面的代码是重复的把平面合并到一个基础图形上面，下面是把这一组平面合成为一个新的平面。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 把这些形状合并\nconst mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries);\n</code></pre><h3>着色器</h3>\n<p>着色器代码逻辑我是完全的没有修改，GLSL(OpenGL着色语言OpenGL Shading Language)，原来的着色器代码是写在<code>&lt;script&gt;</code>元素标签里的，这和我们的工程化项目不符合。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 原来的\n&lt;script id=&quot;vs&quot; type=&quot;x-shader&#x2F;x-vertex&quot;&gt;\n  varying vec2 vUv;\n  void main()\n  {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n&lt;&#x2F;script&gt;\n\n&lt;script id=&quot;fs&quot; type=&quot;x-shader&#x2F;x-fragment&quot;&gt;\n   uniform sampler2D map;\n   uniform vec3 fogColor;\n   uniform float fogNear;\n   uniform float fogFar;\n   varying vec2 vUv;\n   void main()\n   {\n       float depth = gl_FragCoord.z &#x2F; gl_FragCoord.w;\n       float fogFactor = smoothstep( fogNear, fogFar, depth );\n       gl_FragColor = texture2D(map, vUv );\n       gl_FragColor.w *= pow( gl_FragCoord.z, 20.0 );\n       gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n  }\n&lt;&#x2F;script&gt;\n</code></pre><p>后来找了几个地方才知道可以时间使用字符串代替：</p>\n<pre class=\"prettyprint\"><code>  const vShader = &#96;\n    varying vec2 vUv;\n    void main()\n    {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  &#96;;\n</code></pre><h2>源码</h2>\n<p>最后放上<a href=\"https://github.com/hezhongfeng/music163-demo\">源码</a>，感兴趣的同学可以看一下，欢迎 Star 和提出建议。</p>\n</div>",
      "title": "Threejs实现穿越云层动效",
      "author": {
        "loginname": "hezhongfeng",
        "avatar_url": "https://avatars.githubusercontent.com/u/12163050?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 175,
      "country": "China"
    },
    {
      "id": "6118b759baed4ef54db833ab",
      "content": "<div class=\"markdown-text\"><p>我在 2013 年发布了一款扩展程序“划词翻译”，一直到 2020 年初，它的主要功能就跟它的名字一样，只支持在网页上划词后翻译的形式。最近一年，我重写了整个划词翻译，除了给已有的<a href=\"https://hcfy.limingkai.cn/docs/guides/cross\">网页划词</a>做了很多改进（增加多个翻译结果的对比等）之外，还加入了<a href=\"https://hcfy.limingkai.cn/docs/guides/page/\">网页全文翻译</a>、<a href=\"https://hcfy.limingkai.cn/docs/guides/screenshot/\">截图 / 图片翻译</a>、<a href=\"https://hcfy.limingkai.cn/docs/guides/video\">音视频翻译</a>等新功能。对于我这个程序员来说，<a href=\"https://hcfy.limingkai.cn/docs/guides/page/\">网页全文翻译</a>是看文档的最佳利器。</p>\n<p>之前<a href=\"https://www.v2ex.com/t/794286\">我在 V2EX 发的贴子</a>里的评论<strong>全是好评</strong>。感兴趣的同学可以看一下<a href=\"https://hcfy.limingkai.cn/docs/guides/summary/\">划词翻译简介</a>。</p>\n</div>",
      "title": "推荐一下自己开发的适合程序员阅读英文文档的扩展程序——划词翻译",
      "author": {
        "loginname": "lmk123",
        "avatar_url": "https://avatars.githubusercontent.com/u/5035625?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 176,
      "country": "Eurozone"
    },
    {
      "id": "60e503bfba7460b2a0862a7e",
      "content": "<div class=\"markdown-text\"><p>话不多说，先放上截图和仓库地址：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4319bf92bf64975872cc34c25078cec~tplv-k3u1fbpfcp-watermark.image\" alt=\"QQ20210705-210753.gif\"></p>\n<p>代码仓库：<a href=\"https://github.com/clouDr-f2e/rubick\">github</a></p>\n<h2>故事背景</h2>\n<h3>网络抓包</h3>\n<p>之前公司内部因为开发需要，需要和后端进行接口联调，测试环境的时候，经常会涉及到一些状态改变要看交互样式的问题。比如测试需要测商品的待支付、支付中、支付完成等各种节点的交互样式是否符合预期，这种情况测试一般会去造数据或者让后端改数据库接口。\n有的小伙伴可能会用<code>Charles</code>修改返回数据进行测试。但是<code>Charles</code>的抓包体验和配置体验感觉有点麻烦，不是很友好，所以我们自己做了个<code>抓包&amp;mock</code>工具：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbe19cfe19ff4fb099202c7a87addc7f~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>傻瓜式交互一次性解决：抓包、代理、请求转发、接口数据篡改mock、跨域访问 等能力，并得到了广泛使用和好评。</p>\n<h3>文件上传</h3>\n<p>随着项目开发的继续，有些用户给我们反馈页面加载图片资源比较慢，我们看了一下很多图片资源都没有经过压缩处理，这个时候我们可以通过 <code>webpack</code> 写了一些 <code>loader</code> 来对图片资源进行压缩处理。这个时候我们的图片资源大部分是存放在项目目录下。而有的时候，我们是需要将图片存放于 <code>cdn</code> 上的，此时我们又需要一个图床工具，可以在线存储图片资源。于是乎，我们又整合了图片压缩和上传的功能，做了个图床工具：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/542fcabe595740e19665e8f07edb3e99~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3>性能测评</h3>\n<p>开发者开发页面的时候，需要对页面的性能进行评估，另一方面也可以把评估报告通知给测试同学，对其进行性能测试。之前大多采用的是 <code>chrome</code> 插件 <code>lighthouse</code> 来做。但是这个东西对未登录用户无法做到性能评估，因为用户未登录直接测评了登录页面，显然不符合预期，其次，每个电脑上都得安装插件，受限于设备的不同，可能会导致性能没有同一的变量（网络、网速、分辨率、CUP等）。所以我们基于 <code>pupeeteer-core</code>以及<code>electron</code> 做了一个免登的测评工具：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2ce2d6baad343e49a2b589f1fc9f63a~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>但是这些还远远不够，我们随着业务的增加，功能愈发的多了起来：我们的埋点检测工具、需求管理工具、前端多环境切换工具 等等等…一方面导致 <code>electron</code> 体积变得臃肿起来，另一方面随着发布频率增加，安装下载的成本也越来越大，很多用户就不愿意再接着安装，因为确实很麻烦。所以我们需要改变，让功能不依赖与容器。这就需要把我们的功能全部独立出去，做成<strong>插件化</strong>。所以我注意到了 <a href=\"https://u.tools/\">utools</a></p>\n<h2>插件化之旅</h2>\n<p>一开始想到做插件化，无非就是使用 <code>electron</code> 的 <code>webview</code> 能力，实现类似于原生内嵌<code>h5</code>那样的方式，<code>h5</code> 页面可以做独立发布，原生提供 <code>nativaAPI</code> 之间通过 <code>jsBridge</code> 来桥接调用原生的方法。这样实现并无问题，我们也尝试了做了一次。最终思路大概是：</p>\n<h3>electron webview 方式</h3>\n<h4>1. electron 中使用 webview</h4>\n<pre class=\"prettyprint language-html\"><code>&lt;webview src=&quot;https:&#x2F;&#x2F;xxx.xx.com&#x2F;index.html&quot; preload=&quot;preload.js&quot; &#x2F;&gt;\n</code></pre><h4>2. 实现 <code>bridge</code></h4>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; preload.js\nwindow.rubickBridge = {\n  sayHello() {\n    console.log(&#x27;hello world&#x27;)\n  }\n}\n</code></pre><h4>3. 插件借助 <code>bridge</code> 调用 <code>electron</code> 的能力</h4>\n<pre class=\"prettyprint language-html\"><code>&lt;html&gt;\n &lt;body&gt;\n     &lt;div&gt;这是一个插件&lt;div&gt;\n &lt;&#x2F;body&gt;\n &lt;script&gt;\n  window.rubickBridge.sayHello()\n&lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n</code></pre><h4>4. 通信</h4>\n<p>因为 <code>proload.js</code> 是 <code>electron</code> 的 <code>renderer</code> 进程的，所以如果需要使用部分 <code>main</code> 进程的能力，则需要使用通信机制：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; main process\nipcMain.on(&#x27;msg-trigger&#x27;, async (event, arg) =&gt; {\n    const window = arg.winId ? BrowserWindow.fromId(arg.winId) : mainWindow\n    const operators = arg.type.split(&#x27;.&#x27;);\n    let fn = Api;\n    operators.forEach((op) =&gt; {\n      fn = fn[op];\n    });\n    const data = await fn(arg, window);\n    event.sender.send(&#96;msg-back-${arg.type}&#96;, data);\n});\n  \n&#x2F;&#x2F; renderer process\nipcRenderer.send(&#x27;msg-trigger&#x27;, {\n  type: &#x27;getPath&#x27;,\n  name,\n});\nipcRenderer.on(&#96;msg-back-getPath&#96;, (e, result) =&gt; {\n  console.log(result)\n});\n</code></pre><h3>为什么后来我们又放弃了这条路🤔 ？</h3>\n<p>其实上面的思路大致是没啥问题的，我们也基于上面的思路成功把功能抽成了插件，按照插件的方式进行安装加载。直到我们注意到 <code>utools</code> 的强大，感觉 <code>utools</code> 的生态非常丰富，我们要是能集成 <code>utools</code> 的生成那该多好呀！所以我们秉持着干不过他就成为他的原则，我们尝试着成为他。但是 <code>utools</code> 本身并没有开源，所以没有办法去吸取一些优秀的代码实现，但是我们可以看他的官方文档。</p>\n<p>我们发现其实 <code>utools</code> 大多数插件都是和 <code>container</code> 层分离的，也就是说 <code>utools</code> 只是一个插件的容器，为插件提供了一些 <code>api</code> 能力和方法。所以一旦我们实现了<code>utools</code>加载插件的能力，实现 <code>utools</code> 的所有 <code>API</code> 函数，是不是就约等于实现了 <code>utools</code> ! 我们就可以使用 <code>utools</code> 的插件？</p>\n<h3>utools 方式</h3>\n<p>按照 utools 的 文档，首先我们需要实现一个插件，必须要有个 <code>plugin.json</code>，这玩意就是用来告诉 <code>utools</code> 插件的信息。我们也按照文档来写：</p>\n<pre class=\"prettyprint language-json\"><code>{\n    &quot;pluginName&quot;: &quot;helloWorld&quot;,\n    &quot;description&quot;: &quot;我的第一个uTools插件&quot;,\n    &quot;main&quot;: &quot;index.html&quot;,\n    &quot;version&quot;: &quot;0.0.1&quot;,\n    &quot;logo&quot;: &quot;logo.png&quot;,\n    &quot;features&quot;: [\n        {\n          &quot;code&quot;: &quot;hello&quot;,\n          &quot;explain&quot;: &quot;hello world&quot;,\n          &quot;cmds&quot;:[&quot;hello&quot;, &quot;你好&quot;]\n        }\n    ]\n}\n</code></pre><p>接下来是将写好的插件用 <code>utools</code> 跑起来，按照 <code>utools</code>的交互是复制 <code>plugin.json</code> 到<code>utools</code>搜索框即可，我们也可以实现：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 监听 input change\n&#x2F;&#x2F; 读取剪切板内容\nconst fileUrl = clipboard.read(&#x27;public.file-url&#x27;).replace(&#x27;file:&#x2F;&#x2F;&#x27;, &#x27;&#x27;);\n&#x2F;&#x2F; 复制文件\nif (fileUrl &amp;&amp; value === &#x27;plugin.json&#x27;) {\n  &#x2F;&#x2F; 读取 plugin.json 配置\n  const config = JSON.parse(fs.readFileSync(fileUrl, &#x27;utf-8&#x27;));\n  const pluginConfig = {\n    ...config,\n    &#x2F;&#x2F; index.html 文件位置，用于webview加载\n    sourceFile: path.join(fileUrl, &#96;..&#x2F;${config.main || &#x27;index.html&#x27;}&#96;),\n    id: uuidv4(),\n    type: &#x27;dev&#x27;,\n    icon: &#x27;image:&#x2F;&#x2F;&#x27; + path.join(fileUrl, &#96;..&#x2F;${config.logo}&#96;),\n    subType: (() =&gt; {\n      if (config.main) {\n        return &#x27;&#x27;\n      }\n      return &#x27;template&#x27;;\n    })()\n  };\n}\n</code></pre><p>实现效果如下：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b40162dd4c774a3ca6db2aa63c3606eb~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>接下来就是进行命令搜索插件:</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/236e9308fa324a3bac266ff7332cd1ab~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>实现这个功能其实也就是对之前存储的<code>pluginConfig</code>的里面的 <code>features</code> 进行遍历，找到相应的 <code>cmd</code> 后进行下拉框展示即可。</p>\n<p>然后我们要去实现选择功能，用 <code>webview</code> 加载页面的能力：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;webview id=&quot;webview&quot; :src=&quot;path&quot; :preload=&quot;preload&quot;&#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      path: &#96;File:&#x2F;&#x2F;${this.$route.query.sourceFile}&#96;,\n      preload: &#96;File:&#x2F;&#x2F;${path.join(__static, &#x27;.&#x2F;preload.js&#x27;)}&#96;,\n      webview: null,\n      query: this.$route.query,\n      config: {}\n    }\n  }\n}\n&lt;&#x2F;script&gt;\n</code></pre><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37cf1909b1374606bdd1fbae657433c7~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>到此结束了？并没有！！！由于篇幅的原因，我们后续再说。本出写的插件demo已上传github: <a href=\"https://github.com/clouDr-f2e/rubick-plugin-demo\">https://github.com/clouDr-f2e/rubick-plugin-demo</a></p>\n<h2>Far from enough 这只是开始</h2>\n<p>接下来我们就可以参考 <code>utools</code> 交互一口气实现其大部分功能：</p>\n<h3>超级面板</h3>\n<p><img src=\"//static.cnodejs.org/Fl-gy-iyc8sjhe0s9eOhJJRab8_M\" alt=\"image.png\"></p>\n<h3>加载utools生态插件</h3>\n<p>斗图：<a href=\"https://github.com/vst93/doutu-uToolsPlugin\">https://github.com/vst93/doutu-uToolsPlugin</a></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba1eb758180433294c93b59724adefd~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3>窗口分离</h3>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4de3a72c7244db898b2106b96c48416~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3>utools doc 模板</h3>\n<p>uTools 的插件开发给予了开发者最大的自由度，你可以随心所欲的设计页面结构、样式、交互，对于特别擅长前端开发的同学，这没有什么问题，但对于非前端开发者，要做出漂亮的、高质量的前端 UI 是一件困难的事情。</p>\n<p>所以 Rubick 也实现了模板能力：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1acf7f300d2490d99aa208080e00dad~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3>utools 自带的系统命令</h3>\n<h4>取色</h4>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c3e00e5f08545bcb96613689649b337~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h4>截屏</h4>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18023dab52e1420c9e87362cefddb2a1~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h2>最后</h2>\n<p>目前 <code>rubick</code> 已经实现 <code>utools</code> 大多数核心能力，<strong>最重要的是可以使用 utools 所有生态 ！</strong> 更多能力可以前往 github 体验。如果感觉有用，可以帮忙反手一个 star ✨</p>\n<p><a href=\"https://github.com/clouDr-f2e/rubick\">Rubick github</a></p>\n</div>",
      "title": "基于 Electron 我实现并开源了一个 uTools",
      "author": {
        "loginname": "muwoo",
        "avatar_url": "https://avatars.githubusercontent.com/u/21073039?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 177,
      "country": "Eurozone"
    },
    {
      "id": "611aa9bebaed4e2410b8372a",
      "content": "<div class=\"markdown-text\"><h1>下载地址：<a href=\"http://www.97yrbl.com/t-659.html\">百度网盘</a></h1>\n<p>TypeScript已经异常火爆，几乎每一家IT企业在招聘前端时，都要求熟练掌握TS。但许多前端开发者虽然已经使用很多年TS，但是技术仅停留在皮毛，对于TS理解并不透彻。这就导致在实际工作中难以应对复杂问题，发挥TS的最大优势。本课程基于多个真实项目：手写vuex及Promise源码 ，并对TS高级核心知识类和泛型进行了深度讲解，并融合了Vue3源码，由浅入深，提升大家综合运用TS的能力。</p>\n<p>适合人群\n了解 TS 知识但不够深入的人\n想大幅提升 TS 水平的前端开发者\n难以应付复杂 TS 技术问题的人\n技术储备\nJavaScript 基础\nES6 基础\nVue 基础\n环境参数\n语言： TypeScript4、Vue3、Express4</p>\n</div>",
      "title": "晋级TypeScript高手，成为抢手的前端开发人才",
      "author": {
        "loginname": "yuanrenbuluo",
        "avatar_url": "https://avatars.githubusercontent.com/u/88777264?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 178,
      "country": "Eurozone"
    },
    {
      "id": "611a8cf3baed4e2d3fb83716",
      "content": "<div class=\"markdown-text\"><p>There are many <a href=\"https://idoras.com\">free apk download</a> websites such as apkmirror, today i will tell you how to build a website like apkmirror, the programming language i used is <a href=\"https://nodejs.org/en/\">node.js</a>, the database i used is <a href=\"https://www.mongodb.com/\">mongodb</a>, search engine used is <a href=\"https://elastic.co/\">elasticsearch</a>, the web framework i use is <a href=\"https://eggjs.org/\">eggjs</a>.</p>\n<p><strong>Part I analysis apk file and save data</strong></p>\n<p>The tool we need is appt, you can install it with <strong>sudo apt-get install aapt</strong> on ubuntu, the command to analysis apk file is <strong>aapt dump badging test.apk</strong>, as we need execute the command in node.js script so i use execSync to call the command, the code block is below.</p>\n<pre class=\"prettyprint\"><code>const { execSync } = require(&#x27;child_process&#x27;);\nconst fs = require(&quot;fs&quot;); \nconst md5 = require(&#x27;md5&#x27;);\nconst { sleep, getDir } = require(&#x27;..&#x2F;util&#x27;);\n\nconst analysis = (output) =&gt; {\n  const res = {};\n  let out = output.toString().replace(&#x2F;&#x27;&#x2F;g, &#x27;&#x27;);\n\n  out = out.split(&#x27;\\n&#x27;);\n\n  let tmp = out[0].split(&#x27; &#x27;);\n  res.package = tmp[1].split(&#x27;=&#x27;)[1];\n  res.versionCode = tmp[2].split(&#x27;=&#x27;)[1];\n  res.versionName = tmp[3].split(&#x27;=&#x27;)[1];\n\n  tmp = out[2].split(&#x27;:&#x27;)\n  if (tmp[0] == &#x27;sdkVersion&#x27;) {\n    res.sdkVersion = tmp[1];\n  }\n\n  tmp = out[3].split(&#x27;:&#x27;);\n  if (tmp[0] == &#x27;targetSdkVersion&#x27;) {\n    res.targetSdkVersion = tmp[1];\n  }\n\n  tmp = out[out.length - 2].split(&#x27;:&#x27;);\n  if (tmp[0] == &#x27;native-code&#x27;) {\n    res.variant = tmp[1].trim().replace(&#x2F; &#x2F;g, &#x27;|&#x27;);\n\n    tmp = out[out.length - 6].split(&#x27;:&#x27;);\n    res.screen = tmp[1].trim();\n\n    tmp = out[out.length - 4].split(&#x27;:&#x27;);\n    res.locales = tmp[1].trim();\n  } else {\n    res.variant = &#x27;noarch&#x27;;\n\n    tmp = out[out.length - 5].split(&#x27;:&#x27;);\n    res.screen = tmp[1].trim();\n\n    tmp = out[out.length - 3].split(&#x27;:&#x27;);\n    res.locales = tmp[1].trim();\n  }\n  return res;\n}\n\nconst filters = [&#x27;.&#x27;, &#x27;..&#x27;];\n\nconst run = async () =&gt; {\n  while (true) {\n    const dirs = fs.readdirSync(getDir(&#x27;tmp&#x27;));\n    for (const dir of dirs) {\n      if (!filters.includes(dir)) {\n        const name = getDir(&#x27;tmp&#x27;, dir);\n        try {\n          const output = execSync(&#96;&#x2F;usr&#x2F;bin&#x2F;aapt dump badging ${name}&#96;);\n          const res = analysis(output);\n          const stats = fs.statSync(name);\n          res.fileSize = stats.size;\n          const newName = getDir(&#x27;apk&#x27;, &#96;${res.package}_${res.versionCode}_idoras.com.apk&#96;);\n          const tasks = [];\n          const url = &#96;https:&#x2F;&#x2F;play.google.com&#x2F;store&#x2F;apps&#x2F;details?id=${res.package}&#96;;\n          tasks.push({ _id: md5(url), url, host: &#x27;play.google.com&#x27;, type: &#x27;detail&#x27;, package: res.package, done: 0 });\n          await global.db.collection(&#x27;tasks&#x27;).insertMany(tasks, { ordered: false }).catch(() =&gt; {});\n          const one = await global.db.collection(&#x27;apk&#x27;).findOne({ _id: res.package }).catch(() =&gt; {});\n          if (one) {\n            const a = +one.versionCode;\n            const b = +res.versionCode;\n            if (b &gt; a) {\n              await global.db.collection(&#x27;apk&#x27;).updateOne({ _id: res.package }, { $set:{ udate: Date.now(), versionCode: res.versionCode, versionName: res.versionName, done: 1 }}).catch(() =&gt; {});\n            }\n          } else {\n            await global.db.collection(&#x27;apk&#x27;).insertOne({ _id: res.package, versionCode: res.versionCode, versionName: res.versionName, cdate: Date.now(), udate: Date.now(), done: 0, down: 0 }).catch(() =&gt; {});\n          }\n          res._id = &#96;${res.package}_${res.versionCode}&#96;;\n          await global.db.collection(&#x27;variant&#x27;).insertOne({ ...res, cdate: Date.now() }).catch(() =&gt; {});\n          fs.renameSync(name, newName);\n        } catch (err) {\n          console.error(err);\n          fs.unlinkSync(name);\n        }\n      }\n    }\n    if (dirs.length == 0) {\n      console.log(&#x27;no apk files to analysis&#x27;);\n      await sleep(60000);\n    }\n  }\n};\n\nmodule.exports = run;\n\n</code></pre><p>The <strong>getDir</strong> and <strong>sleep</strong> is util function, you can find the source code below.</p>\n<pre class=\"prettyprint\"><code>const req = require(&#x27;request&#x27;);\nconst path = require(&#x27;path&#x27;);\nconst os = require(&#x27;os&#x27;);\nconst agent = new require(&#x27;socks-proxy-agent&#x27;)(&#x27;socks5:&#x2F;&#x2F;localhost:1080&#x27;);\n\nlet root = &#x27;&#x2F;data&#x27;;\nconst options = {\n  headers: {\n    &#x27;User-Agent&#x27;: &#x27;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;92.0.4515.107 Safari&#x2F;537.36&#x27;\n  },\n  timeout: 30000,\n  encoding: null,\n};\nif (os.platform() == &#x27;win32&#x27;) {\n  options.agent = agent;\n  root = &#x27;d:&#x2F;data&#x27;;\n}\nconst request = req.defaults(options);\n\nconst getDir = (...paths) =&gt; {\n  paths.unshift(root);\n  return path.join(...paths);\n};\n\nconst sleep = (time) =&gt; new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      resolve();\n    }, time);\n  });\n\nconst fetch = (url) =&gt; new Promise((resolve) =&gt; {\n    console.log(&#96;down ${url} started&#96;);\n    request(url, (err, res, body) =&gt; {\n      if (res &amp;&amp; res.statusCode === 200) {\n        console.log(&#96;down ${url} 200&#96;);\n        resolve(body);\n      } else {\n        console.error(&#96;down ${url} ${res &amp;&amp; res.statusCode} ${err}&#96;);\n        if (res &amp;&amp; res.statusCode) {\n          resolve(res.statusCode);\n        } else {\n          &#x2F;&#x2F; ESOCKETTIMEOUT 超时错误返回600\n          resolve(600);\n        }\n      }\n    });\n  });\n\nmodule.exports = { getDir, sleep, fetch };\n\n</code></pre><p>The main logic is we get basic information from appt, parse the output, get apk id such as <strong>com.moonvideo.android.resso</strong>, and insert a task to get apk logo and images and brief from <a href=\"https://play.google.com/store/apps\">play.google.com</a>, i wrote a little crawler framework, each website with one parser bind with the host, every url have a type, each type bind with a function, the <a href=\"http://play.google.com\">play.google.com</a>’s parser code is below.</p>\n<pre class=\"prettyprint\"><code>const { URL } = require(&#x27;url&#x27;);\nconst md5 = require(&#x27;md5&#x27;);\nconst cheerio = require(&#x27;cheerio&#x27;);\nconst slugify = require(&#x27;slugify&#x27;);\n\nconst resolve = (from, to) =&gt; {\n  const resolvedUrl = new URL(to, new URL(from, &#x27;resolve:&#x2F;&#x2F;&#x27;));\n  if (resolvedUrl.protocol === &#x27;resolve:&#x27;) {\n    &#x2F;&#x2F; &#96;from&#96; is a relative URL.\n    const { pathname, search, hash } = resolvedUrl;\n    return pathname + search + hash;\n  }\n  return resolvedUrl.toString();\n}\n\nconst fns = {\n\n  detail: async (page) =&gt; {\n    const host = page.host;\n    try {\n      const $ = cheerio.load(page.con.toString(), { decodeEntities: false });\n      const brief = $(&#x27;div.DWPxHb &gt; span &gt; div:nth-child(1)&#x27;).html();\n      const name = $(&#x27;h1.AHFaub &gt; span&#x27;).text();\n      const dev = $(&#x27;div.qQKdcc &gt; span:nth-child(1) &gt; a&#x27;).text();\n      const tag = $(&#x27;div.qQKdcc &gt; span:nth-child(2) &gt; a&#x27;).attr(&#x27;href&#x27;).split(&#x27;&#x2F;&#x27;)[4];\n      const images = [];\n      const tasks = [];\n      $(&#x27;button.Q4vdJd &gt; img&#x27;).each((i, ele) =&gt; {\n        let url = $(ele).attr(&#x27;src&#x27;);\n        if (!url || !url.startsWith(&#x27;https&#x27;)) {\n          url = $(ele).attr(&#x27;data-src&#x27;)\n        }\n        tasks.push({ _id: md5(url), url, type: &#x27;download&#x27;, host: (new URL(url)).hostname, done: 0 });\n        images.push({ _id: md5(url), url });\n      });\n      const logourl = $(&#x27;div.xSyT2c &gt; img&#x27;).attr(&#x27;src&#x27;);\n      tasks.push({ _id: md5(logourl), url: logourl, type: &#x27;download&#x27;, host: (new URL(logourl)).hostname, package: page.package, done: 0 });\n      const res = await global.db.collection(&#x27;tasks&#x27;).insertMany(tasks, { ordered: false }).catch(() =&gt; {});\n      res &amp;&amp; console.log(&#96;${host}-detail insert ${res.insertedCount} from ${tasks.length} tasks&#96;);\n      await global.db.collection(&#x27;apk&#x27;).updateOne({ _id: page.package }, { $set:{ brief, name, dev, devSlug: slugify(dev), tag, tagSlug: slugify(tag), images, done: 1 } });\n      return 1;\n    } catch (err) {\n      console.error(&#96;${host}-detail parse ${page.url} ${err}&#96;);\n      return 4;\n    }\n  },\n\n  run: (page) =&gt; {\n    const fn = fns[page.type];\n    if (fn) {\n      return fn(page);\n    }\n    console.error(&#96;${page.url} parser not found&#96;);\n    return 0;\n  }\n\n};\n\nmodule.exports = fns;\n\n</code></pre><p>every apk we analysis with aapt will send one request to <a href=\"http://play.google.com\">play.google.com</a> to get it’s name, brief, developer info, tag, images, i will use these data to show on the website.</p>\n<p>now we have the data of apk file, so where to find the apk files? You can download them from <a href=\"https://idoras.com\">idoras</a> or <a href=\"https://www.apkmirror.com/\">apkmirror</a> or <a href=\"https://apkpure.com/\">apkpure</a>, also you can write node.js script to download them from website such as <a href=\"https://idoras.com\">idoras</a>.</p>\n<p>Next we need index these data with elasticsearch so we can use them later, the code is below.</p>\n<pre class=\"prettyprint\"><code>const { sleep } = require(&#x27;..&#x2F;util&#x27;);\nconst { Client } = require(&#x27;@elastic&#x2F;elasticsearch&#x27;);\n\nconst getApks = (apks) =&gt; {\n  const res = [];\n  apks.forEach((apk) =&gt; {\n    if(apk.name) {\n      const tmp = {};\n      res.push({ index: { _index: &#x27;apk&#x27;, _type: &#x27;_doc&#x27;, _id: apk._id } });\n      tmp.id = apk._id;\n      tmp.versionCode = apk.versionCode;\n      tmp.versionName = apk.versionName;\n      tmp.cdate = apk.cdate;\n      tmp.udate = apk.udate;\n      tmp.down = apk.down;\n      tmp.brief = apk.brief;\n      tmp.dev = apk.dev;\n      tmp.devSlug = apk.devSlug;\n      tmp.name = apk.name;\n      tmp.tag = apk.tag;\n      res.push(tmp);\n    }\n  });\n  return res;\n};\n\nconst run = async () =&gt; {\n\n  while (true) {\n    const esclient = new Client({\n      node: &#x27;http:&#x2F;&#x2F;username:password@ip:9200&#x27;,\n      maxRetries: 3,\n      requestTimeout: 60000\n    });\n    const apks = await global.db.collection(&#x27;apk&#x27;).find({ done: 1 }).limit(100).toArray().catch((err) =&gt; console.error(err));\n    const tmp = getApks(apks);\n    if (tmp &amp;&amp; tmp.length) {\n      let res = await esclient.bulk({ refresh: true, body: tmp }).catch((err) =&gt; console.error(err));\n      if (res) {\n        const ulist = apks.map((apk) =&gt; ({ updateOne: { filter: { _id: apk._id }, update: { $set: { done: 6 } }, upsert: false } }));\n        res = await global.db.collection(&#x27;apk&#x27;).bulkWrite(ulist, { ordered: false, w: 1 }).catch(() =&gt; {});\n        res &amp;&amp; console.log(&#96;apk:indexer update ${res.modifiedCount} from ${res.matchedCount}&#96;);\n      }\n    } else {\n      console.log(&#x27;apk:indexer no apk to index&#x27;);\n      await sleep(60000);\n    }\n    await esclient.close();\n  }\n};\n\nmodule.exports = run;\n\n</code></pre><p><strong>Part II build website with eggjs</strong></p>\n<p>The template engine i use is <a href=\"https://nunjucks.bootcss.com/\">nunjucks</a>, also i used some eggjs plugins such <a href=\"https://www.npmjs.com/package/egg-elasticsearch2\">egg-elasticsearch2</a></p>\n<p>The logic is easy, at home page we query data from elasticsearch, and render data into nunjucks template, basiclly it’s a list page, also i will cache the hot download apks into <strong>ctx.app.hots</strong>, refresh it every 30 minutes, and show the hot download apks on the right aside, also the html template support responsive design, it will show perfect on mobile system.</p>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\n\nconst Controller = require(&#x27;egg&#x27;).Controller;\n\nclass HomeController extends Controller {\n\n  async home() {\n    const { ctx } = this;\n    const params = ctx.params;\n    const page = parseInt(params.page, 10) || 1;\n    if (page &lt; 1) {\n      ctx.redirect(&#x27;&#x2F;list&#x2F;1&#x2F;&#x27;, 301);\n    }\n    const start = (page - 1) * ctx.helper.size;\n    const query = {\n      body: [\n        { index: &#x27;apk&#x27;, type: &#x27;_doc&#x27; },\n        { query: { bool: { must: [{ match_all: {} }, { exists: { field: &#x27;id&#x27; } }] } }, highlight: { fields: { name: {} } }, from: start, size: ctx.helper.size, sort: [{ udate: { order: &#x27;desc&#x27; } }, &#x27;_score&#x27; ] },\n      ],\n    };\n    const info = {};\n    const res = await ctx.app.elasticsearch.msearch(query);\n    ctx.helper.getList(res.responses[0], info);\n\n    let tpage = Math.floor(info.all &#x2F; ctx.helper.size) + (info.all % ctx.helper.size ? 1 : 0);\n    tpage &lt; 1 &amp;&amp; (tpage = 1);\n    if (page &gt; tpage) {\n      if (tpage &gt; 500) {\n        ctx.redirect(&#x27;&#x2F;list&#x2F;500&#x2F;&#x27;, 301);\n      } else {\n        ctx.redirect(&#96;&#x2F;list&#x2F;${tpage}&#x2F;&#96;, 301);\n      }\n    } else if (page &gt; 500) {\n      ctx.redirect(&#x27;&#x2F;list&#x2F;500&#x2F;&#x27;, 301);\n    }\n    tpage = tpage &gt; 500 ? 500 : tpage;\n    info.pages = ctx.helper.getPages(page, tpage);\n\n    info.url = ctx.request.url;\n    if (info.url === &#x27;&#x2F;&#x27;) {\n      info.title = &#x27;Free Apk download online - idoras.com&#x27;;\n      info.keywords = &#x27;app download,apk download, free apk download, idoras, apk downloader, android apk download&#x27;;\n      info.description = &#x27;Free apk download for Android with idoras APK downloader. NoAds, Faster apk downloads and apk file update speed. Best of all, it\\&#x27;s free&#x27;;\n      info.home = true;\n    } else {\n      info.title = &#96;Free Apk download - page${page} - idoras.com&#96;;\n      info.keywords = &#96;app download,apk download, free apk download, idoras, apk downloader, android apk download,apk list page${page}&#96;;\n      info.description = info.list.map(item =&gt; item.name).join(&#x27;,&#x27;).substring(0, 150);\n    }\n\n    if (!ctx.app.hots) {\n      ctx.app.hots = info.hots = await ctx.service.search.hot();\n    } else {\n      info.hots = ctx.app.hots;\n    }\n    info.slist = ctx.helper.getKeys();\n    await ctx.render(&#x27;home.html&#x27;, { info });\n  }\n\n  async version() {\n    const { ctx } = this;\n    const params = ctx.params;\n    const id = params.id;\n    const apk = await ctx.model.Apk.findById(id);\n    const list = await ctx.model.Variant.find({ package: id });\n    list.sort((a, b) =&gt; b.versionCode - a.versionCode);\n    const info = { apk, list };\n    info.variant = list[0] || {};\n    info.title = &#96;${apk.name} Free Apk download - idoras.com&#96;;\n    info.keywords = &#96;${apk.name} download, app download,apk download, free apk download, idoras, apk downloader, android apk download&#96;;\n    info.description = &#96;download ${apk.name} free apks online, it&#x27;s faster and free online, many version to download&#96;;\n    if (!ctx.app.hots) {\n      ctx.app.hots = info.hots = await ctx.service.search.hot();\n    } else {\n      info.hots = ctx.app.hots;\n    }\n    info.slist = ctx.helper.getKeys();\n    await ctx.render(&#x27;version.html&#x27;, { info });\n  }\n\n  async download() {\n    const { ctx } = this;\n    const params = ctx.params;\n    const id = params.id;\n    const version = params.version;\n    const apk = await ctx.model.Apk.findById(id);\n    const variant = await ctx.model.Variant.findById(&#96;${id}_${version}&#96;);\n    const list = await ctx.model.Variant.find({ package: id });\n    list.sort((a, b) =&gt; b.cdate - a.cdate);\n    apk.down = apk.down + 1;\n    apk.save();\n    ctx.app.elasticsearch.update({ index: &#x27;apk&#x27;, type: &#x27;_doc&#x27;, id, body: { script: &#x27;ctx._source.down += 1&#x27;, upsert: { down: 1 } } }, () =&gt; { });\n    const info = { apk, variant, list };\n    info.title = &#96;${apk.name} ${apk.versionName} Free Apk download online - idoras.com&#96;;\n    info.keywords = &#96;${apk.name} ${apk.versionName} download online, app download,apk download, free apk download, idoras, apk downloader, android apk download&#96;;\n    info.description = &#96;download ${apk.name} ${apk.versionName} free apks online, it&#x27;s faster and free online, many version to download&#96;;\n    if (!ctx.app.hots) {\n      ctx.app.hots = info.hots = await ctx.service.search.hot();\n    } else {\n      info.hots = ctx.app.hots;\n    }\n    info.slist = ctx.helper.getKeys();\n    await ctx.render(&#x27;download.html&#x27;, { info });\n  }\n\n  async dev() {\n    const { ctx } = this;\n    const params = ctx.params;\n    const devSlug = params.devSlug;\n    const page = parseInt(params.page, 10) || 1;\n    if (page &lt; 1) {\n      ctx.redirect(&#96;&#x2F;dev&#x2F;${devSlug}&#x2F;1&#x2F;&#96;, 301);\n    }\n    const start = (page - 1) * ctx.helper.size;\n    const info = { devSlug };\n    const query = {\n      body: [\n        { index: &#x27;apk&#x27;, type: &#x27;_doc&#x27; },\n        { query: { term: { devSlug } }, from: start, size: ctx.helper.size, sort: [{ udate: { order: &#x27;desc&#x27; } }, &#x27;_score&#x27; ] },\n      ],\n    };\n    const res = await ctx.app.elasticsearch.msearch(query);\n    ctx.helper.getList(res.responses[0], info);\n\n    let tpage = Math.floor(info.all &#x2F; ctx.helper.size) + (info.all % ctx.helper.size ? 1 : 0);\n    tpage &lt; 1 &amp;&amp; (tpage = 1);\n    if (page &gt; tpage) {\n      if (tpage &gt; 500) {\n        ctx.redirect(&#96;&#x2F;dev&#x2F;${devSlug}&#x2F;500&#x2F;&#96;, 301);\n      } else {\n        ctx.redirect(&#96;&#x2F;dev&#x2F;${devSlug}&#x2F;${tpage}&#x2F;&#96;, 301);\n      }\n    } else if (page &gt; 500) {\n      ctx.redirect(&#96;&#x2F;dev&#x2F;${devSlug}&#x2F;500&#x2F;&#96;, 301);\n    }\n    tpage = tpage &gt; 500 ? 500 : tpage;\n    info.pages = ctx.helper.getPages(page, tpage);\n\n    info.title = &#96;apk developered by ${devSlug} download - idoras.com&#96;;\n    info.keywords = &#96;${devSlug} apks download online, app download,apk download, free apk download, idoras, apk downloader, android apk download&#96;;\n    info.description = &#96;download ${devSlug} free apks online, it&#x27;s faster and free online, many version to download&#96;;\n    if (!ctx.app.hots) {\n      ctx.app.hots = info.hots = await ctx.service.search.hot();\n    } else {\n      info.hots = ctx.app.hots;\n    }\n    info.slist = ctx.helper.getKeys();\n    await ctx.render(&#x27;dev.html&#x27;, { info });\n  }\n\n  async tag() {\n    const { ctx } = this;\n    const params = ctx.params;\n    const tag = params.tag;\n    const page = parseInt(params.page, 10) || 1;\n    if (page &lt; 1) {\n      ctx.redirect(&#96;&#x2F;tag&#x2F;${tag}&#x2F;1&#x2F;&#96;, 301);\n    }\n    const start = (page - 1) * ctx.helper.size;\n    const info = { tag };\n    const query = {\n      body: [\n        { index: &#x27;apk&#x27;, type: &#x27;_doc&#x27; },\n        { query: { term: { tag } }, from: start, size: ctx.helper.size, sort: [{ udate: { order: &#x27;desc&#x27; } }, &#x27;_score&#x27; ] },\n      ],\n    };\n    const res = await ctx.app.elasticsearch.msearch(query);\n    ctx.helper.getList(res.responses[0], info);\n\n    let tpage = Math.floor(info.all &#x2F; ctx.helper.size) + (info.all % ctx.helper.size ? 1 : 0);\n    tpage &lt; 1 &amp;&amp; (tpage = 1);\n    if (page &gt; tpage) {\n      if (tpage &gt; 500) {\n        ctx.redirect(&#96;&#x2F;tag&#x2F;${tag}&#x2F;500&#x2F;&#96;, 301);\n      } else {\n        ctx.redirect(&#96;&#x2F;tag&#x2F;${tag}&#x2F;${tpage}&#x2F;&#96;, 301);\n      }\n    } else if (page &gt; 500) {\n      ctx.redirect(&#96;&#x2F;tag&#x2F;${tag}&#x2F;500&#x2F;&#96;, 301);\n    }\n    tpage = tpage &gt; 500 ? 500 : tpage;\n    info.pages = ctx.helper.getPages(page, tpage);\n\n    info.title = &#96;apk tagged with ${tag} download - idoras.com&#96;;\n    info.keywords = &#96;${tag} apks download online, app download,apk download, free apk download, idoras, apk downloader, android apk download&#96;;\n    info.description = &#96;download ${tag} free apks online, it&#x27;s faster and free online, many version to download&#96;;\n    if (!ctx.app.hots) {\n      ctx.app.hots = info.hots = await ctx.service.search.hot();\n    } else {\n      info.hots = ctx.app.hots;\n    }\n    info.slist = ctx.helper.getKeys();\n    await ctx.render(&#x27;tag.html&#x27;, { info });\n  }\n\n  async search() {\n    const { ctx } = this;\n    const params = ctx.params;\n    const key = params.key;\n    const page = parseInt(params.page, 10) || 1;\n    if (page &lt; 1) {\n      ctx.redirect(&#96;&#x2F;search&#x2F;${key}&#x2F;1&#x2F;&#96;, 301);\n    }\n    const start = (page - 1) * ctx.helper.size;\n    const info = { key };\n    const query = {\n      body: [\n        { index: &#x27;apk&#x27;, type: &#x27;_doc&#x27; },\n      ],\n    };\n    if (key) {\n      query.body.push({ query: { multi_match: { query: key, fields: [ &#x27;name&#x27;, &#x27;id&#x27;, &#x27;brief&#x27; ] } }, from: start, size: ctx.helper.size, sort: [ &#x27;_score&#x27; ] });\n    } else {\n      query.body.push({ query: { bool: { must: [{ match_all: {} }, { exists: { field: &#x27;id&#x27; } }] } }, from: start, size: ctx.helper.size, sort: [ &#x27;_score&#x27; ] });\n    }\n    const res = await ctx.app.elasticsearch.msearch(query);\n    key &amp;&amp; res.responses[0].hits.hits.length &amp;&amp; ctx.helper.putKey(key);\n    ctx.helper.getList(res.responses[0], info);\n\n    let tpage = Math.floor(info.all &#x2F; ctx.helper.size) + (info.all % ctx.helper.size ? 1 : 0);\n    tpage &lt; 1 &amp;&amp; (tpage = 1);\n    if (page &gt; tpage) {\n      if (tpage &gt; 500) {\n        ctx.redirect(&#96;&#x2F;search&#x2F;${key}&#x2F;500&#x2F;&#96;, 301);\n      } else {\n        ctx.redirect(&#96;&#x2F;search&#x2F;${key}&#x2F;${tpage}&#x2F;&#96;, 301);\n      }\n    } else if (page &gt; 500) {\n      ctx.redirect(&#96;&#x2F;search&#x2F;${key}&#x2F;500&#x2F;&#96;, 301);\n    }\n    tpage = tpage &gt; 500 ? 500 : tpage;\n    info.pages = ctx.helper.getPages(page, tpage);\n\n    info.title = &#96;search ${key} apks to download online - idoras.com&#96;;\n    info.keywords = &#96;${key} apks download online, app download,apk download, free apk download, idoras, apk downloader, android apk download&#96;;\n    info.description = &#96;download ${key} free apks online, it&#x27;s faster and free online, many version to download&#96;;\n    if (!ctx.app.hots) {\n      ctx.app.hots = info.hots = await ctx.service.search.hot();\n    } else {\n      info.hots = ctx.app.hots;\n    }\n    info.slist = ctx.helper.getKeys();\n    await ctx.render(&#x27;search.html&#x27;, { info });\n  }\n\n  async re() {\n    const { ctx } = this;\n    const params = ctx.request.body;\n    const key = params.key;\n    if (key) {\n      ctx.redirect(&#96;&#x2F;search&#x2F;${encodeURI(key)}&#x2F;&#96;, 301);\n    } else {\n      ctx.redirect(&#x27;&#x2F;search&#x2F;&#x27;, 301);\n    }\n  }\n}\n\nmodule.exports = HomeController;\n</code></pre><pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\n\n&#x2F;&#x2F; eslint-disable-next-line no-unused-vars\nmodule.exports = (options, app) =&gt; {\n  return async function mobileMiddleware(ctx, next) {\n    const u = ctx.get(&#x27;user-agent&#x27;) || &#x27;&#x27;;\n    const tmp = {\n      trident: u.indexOf(&#x27;Trident&#x27;) &gt; -1, &#x2F;&#x2F; IE内核\n      presto: u.indexOf(&#x27;Presto&#x27;) &gt; -1, &#x2F;&#x2F; opera内核\n      webKit: u.indexOf(&#x27;AppleWebKit&#x27;) &gt; -1, &#x2F;&#x2F; 苹果、谷歌内核\n      gecko: u.indexOf(&#x27;Gecko&#x27;) &gt; -1 &amp;&amp; u.indexOf(&#x27;KHTML&#x27;) === -1, &#x2F;&#x2F; 火狐内核\n      mobile: !!u.match(&#x2F;AppleWebKit.*Mobile.*&#x2F;), &#x2F;&#x2F; 是否为移动终端\n      ios: !!u.match(&#x2F;\\(i[^;]+;( U;)? CPU.+Mac OS X&#x2F;), &#x2F;&#x2F; ios终端\n      android: u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Linux&#x27;) &gt; -1, &#x2F;&#x2F; android终端或者uc浏览器\n      iPhone: u.indexOf(&#x27;iPhone&#x27;) &gt; -1, &#x2F;&#x2F; 是否为iPhone或者QQHD浏览器\n      iPad: u.indexOf(&#x27;iPad&#x27;) &gt; -1, &#x2F;&#x2F; 是否iPad\n      webApp: u.indexOf(&#x27;Safari&#x27;) === -1, &#x2F;&#x2F; 是否web应该程序，没有头部与底部\n      weixin: u.indexOf(&#x27;MicroMessenger&#x27;) &gt; -1, &#x2F;&#x2F; 是否微信 （2015-01-22新增）\n      qq: u.match(&#x2F;\\sQQ&#x2F;i) === &#x27; qq&#x27;, &#x2F;&#x2F; 是否QQ\n    };\n    if (tmp.mobile || tmp.android || tmp.ios || tmp.weixin) {\n      ctx.request.mobile = true;\n    }\n    await next();\n  };\n};\n\n</code></pre><pre class=\"prettyprint\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;{{info.title}}&lt;&#x2F;title&gt;\n  &lt;meta name=&quot;keywords&quot; content=&quot;{{info.keywords}}&quot;&gt;\n  &lt;meta name=&quot;description&quot; content=&quot;{{info.description}}&quot;&gt;\n  &lt;meta property=&quot;og:site_name&quot; content=&quot;idoras.com&quot;&gt;\n  &lt;meta property=&quot;og:title&quot; content=&quot;{{info.title}}&quot;&gt;\n  &lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt;\n  &lt;link rel=&quot;shortcut icon&quot; href=&quot;&#x2F;favicon.ico&quot;&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;normalize&#x2F;8.0.0&#x2F;normalize.min.css&quot;&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;https:&#x2F;&#x2F;fonts.googleapis.com&#x2F;icon?family=Material+Icons&quot;&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;&#x2F;css&#x2F;material-components-web.min.css&quot;&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;&#x2F;css&#x2F;app.css?v=2021080817&quot;&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n\n  &lt;aside class=&quot;mdc-drawer mdc-drawer--dismissible&quot;&gt;\n    &lt;div class=&quot;mdc-drawer__header&quot;&gt;\n      &lt;h3 class=&quot;mdc-drawer__title&quot;&gt;IDORAS&lt;&#x2F;h3&gt;\n      &lt;h6 class=&quot;mdc-drawer__subtitle&quot;&gt;download free android apks&lt;&#x2F;h6&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class=&quot;mdc-drawer__content&quot;&gt;\n      &lt;nav class=&quot;mdc-list&quot;&gt;\n        &lt;a class=&quot;mdc-list-item mdc-list-item--activated&quot; href=&quot;&#x2F;&quot; aria-selected=&quot;true&quot;&gt;\n          &lt;i class=&quot;material-icons mdc-list-item__graphic&quot; aria-hidden=&quot;true&quot;&gt;home&lt;&#x2F;i&gt;\n          &lt;span class=&quot;mdc-list-item__text&quot;&gt;Home&lt;&#x2F;span&gt;\n        &lt;&#x2F;a&gt;\n      &lt;&#x2F;nav&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;aside&gt;\n  &lt;div class=&quot;mdc-drawer-app-content&quot;&gt;\n    &lt;header class=&quot;mdc-top-app-bar app-bar&quot; id=&quot;app-bar&quot;&gt;\n      &lt;div class=&quot;mdc-top-app-bar__row container&quot;&gt;\n        &lt;section class=&quot;mdc-top-app-bar__section mdc-top-app-bar__section--align-start&quot;&gt;\n          &lt;i href=&quot;&quot; class=&quot;demo-menu material-icons mdc-top-app-bar__navigation-icon mdc-nav-icon menuLogo&quot;\n            style=&quot;text-decoration: none;cursor: pointer;&quot;&gt;menu&lt;&#x2F;i&gt;\n          &lt;a class=&quot;mdc-top-app-bar__title&quot; href=&quot;&#x2F;&quot; style=&quot;color: #fff;&quot;&gt;IDORAS&lt;&#x2F;a&gt;\n        &lt;&#x2F;section&gt;\n        &lt;section class=&quot;mdc-top-app-bar__section mdc-top-app-bar__section--align-end&quot; role=&quot;toolbar&quot;&gt;\n          &lt;a href=&quot;&#x2F;search&#x2F;&quot;&gt;\n            &lt;i class=&quot;material-icons icon-white&quot;&gt;search&lt;&#x2F;i&gt;\n          &lt;&#x2F;a&gt;\n        &lt;&#x2F;section&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;header&gt;\n\n    &lt;main class=&quot;main-content&quot; id=&quot;main-content&quot;&gt;\n      &lt;div class=&quot;mdc-top-app-bar--fixed-adjust container&quot;&gt;\n        &lt;div class=&quot;mdc-layout-grid&quot; style=&quot;padding:0&quot;&gt;\n          &lt;div class=&quot;mdc-layout-grid__inner&quot;&gt;\n            &lt;div\n              class=&quot;mdc-layout-grid__cell mdc-layout-grid__cell--span-8 mdc-layout-grid__cell--span-12-tablet mdc-layout-grid__cell--span-12-phone&quot;&gt;\n              {% if ctx.request.mobile %}\n              &lt;div class=&quot;details-title&quot;&gt;\n                &lt;!-- Go to www.addthis.com&#x2F;dashboard to customize your tools --&gt; \n                &lt;div class=&quot;addthis_inline_share_toolbox_bm88&quot;&gt;&lt;&#x2F;div&gt;\n              &lt;&#x2F;div&gt;\n              {% endif %}\n              &lt;div class=&quot;listWidght&quot;&gt;\n                &lt;form action=&quot;&#x2F;re&quot; style=&quot;overflow:visible&quot; method=&quot;POST&quot; onsubmit=&quot;return key.value!=&#x27;&#x27;&quot; role=&quot;search&quot;&gt;\n                  &lt;input class=&quot;search-key&quot; type=&quot;text&quot; id=&quot;key&quot; name=&quot;key&quot; placeholder=&quot;Google Play Store or com.android.vending&quot; size=&quot;1&quot; style=&quot;padding: 5px;&quot; &#x2F;&gt;\n                  &lt;button type=&quot;submit&quot; class=&quot;search mdc-button mdc-button--raised button&quot;&gt;\n                    &lt;i class=&quot;material-icons icon-white&quot;&gt;search&lt;&#x2F;i&gt;\n                  &lt;&#x2F;button&gt;\n                &lt;&#x2F;form&gt;\n              &lt;&#x2F;div&gt;\n              &lt;div class=&quot;listWidget&quot;&gt;\n                &lt;div class=&quot;box&quot;&gt;\n                  &lt;div class=&quot;title bread-crumbs&quot;&gt;\n                    &lt;h5 class=&quot;widgetHeader&quot;&gt;Latest Upload&lt;&#x2F;h5&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n                {% for item in info.list %}\n                &lt;div&gt;\n                  &lt;div class=&quot;appRow&quot;&gt;\n                    &lt;div class=&quot;table-row&quot;&gt;\n                      &lt;div style=&quot;width: 56px;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;img style=&quot;width:50px; height:50px;&quot;\n                          src=&quot;https:&#x2F;&#x2F;img.idoras.com&#x2F;img&#x2F;{{item.id}}.png&quot;&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div class=&quot;table-cell&quot;&gt;\n                        &lt;div style=&quot;padding-top: 4px;&quot;&gt;\n                          &lt;h5 title=&quot;{{item.name}} {{item.versionName}} ({{item.versionCode}}) by {{item.dev}}&quot;\n                            class=&quot;appRowTitle wrapText marginZero block-on-mobile&quot;&gt;\n                            &lt;a class=&quot;fontBlack&quot; href=&quot;&#x2F;apk&#x2F;{{item.id}}&#x2F;&quot;&gt;{{item.name}} {{item.versionName}}&lt;&#x2F;a&gt;\n                          &lt;&#x2F;h5&gt;\n                          &lt;a href=&quot;&#x2F;dev&#x2F;{{item.devSlug}}&#x2F;&quot; class=&quot;byDeveloper block-on-mobile wrapText&quot;&gt;by {{item.dev}}&lt;&#x2F;a&gt;\n                          &lt;span style=&quot;padding:4px 12px 0 0;&quot; class=&quot;colorLightBlack&quot;&gt;&lt;span class=&quot;udate&quot;&gt;{{ctx.helper.fdate(item.udate)}}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;\n                        &lt;&#x2F;div&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div style=&quot;width: 30px;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;div class=&quot;iconsBox &quot;&gt;\n                          &lt;div class=&quot;downloadIconPositioning&quot;&gt;\n                            &lt;a class=&quot;downloadLink&quot; href=&quot;&#x2F;apk&#x2F;{{item.id}}&#x2F;{{item.versionCode}}&#x2F;&quot;&gt;\n                              &lt;i class=&quot;material-icons icon-blue&quot; aria-hidden=&quot;true&quot;&gt;download&lt;&#x2F;i&gt;\n                            &lt;&#x2F;a&gt;\n                          &lt;&#x2F;div&gt;\n                        &lt;&#x2F;div&gt;\n                      &lt;&#x2F;div&gt;\n                    &lt;&#x2F;div&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n                {% endfor %}\n                &lt;div class=&quot;appRow center&quot;&gt;\n                  &lt;div class=&quot;pagination mobile&quot;&gt;\n                    &lt;div class=&quot;wp-pagenavi&quot; role=&quot;navigation&quot;&gt;\n                      {% for page in info.pages %}\n                      &lt;a href=&quot;&#x2F;list&#x2F;{{page.page}}&#x2F;&quot;\n                        class=&quot;{%if loop.first%}first{%endif%} {%if loop.last%}last{%endif%} {%if page.current%}current{%endif%}&quot;&gt;\n                        &lt;span class=&quot;mdc-fab__icon&quot;&gt;\n                          {{page.text}}\n                        &lt;&#x2F;span&gt;\n                      &lt;&#x2F;a&gt;\n                      {% endfor %}\n                    &lt;&#x2F;div&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n              &lt;&#x2F;div&gt;\n              &lt;div class=&quot;pages&quot;&gt;\n                \n              &lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n            &lt;div\n              class=&quot;mdc-layout-grid__cell mdc-layout-grid__cell--span-4 mdc-layout-grid__cell--span-12-tablet mdc-layout-grid__cell--span-12-phone&quot;&gt;\n              {% if info.slist.length &gt; 0 %}\n              &lt;div class=&quot;listWidget&quot;&gt;\n                &lt;div class=&quot;box&quot;&gt;\n                  &lt;div class=&quot;title bread-crumbs&quot;&gt;\n                    &lt;h5 class=&quot;widgetHeader&quot;&gt;Hot Searches&lt;&#x2F;h5&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n                &lt;div&gt;\n                  &lt;div class=&quot;appRow&quot;&gt;\n                    {% for item in info.slist %}\n                    &lt;a href=&quot;&#x2F;search&#x2F;{{item.ekey}}&#x2F;&quot; class=&quot;mdc-button&quot;&gt;\n                      &lt;span class=&quot;mdc-button__label&quot;&gt;{{item.key}}&lt;&#x2F;span&gt;\n                    &lt;&#x2F;a&gt;\n                    {% endfor %}\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n              &lt;&#x2F;div&gt;\n              {% endif %}\n              &lt;div class=&quot;listWidget&quot;&gt;\n                &lt;div class=&quot;box&quot;&gt;\n                  &lt;div class=&quot;title bread-crumbs&quot;&gt;\n                    &lt;h5 class=&quot;widgetHeader&quot;&gt;Social Medias&lt;&#x2F;h5&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n                &lt;div&gt;\n                  &lt;div class=&quot;appRow&quot;&gt;\n                    &lt;div class=&quot;table-row&quot;&gt;\n                      &lt;div class=&quot;table-cell center&quot;&gt;\n                        &lt;a href=&quot;https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id=100071468057179&quot; target=&quot;_blank&quot;&gt;\n                          &lt;img style=&quot;vertical-align: baseline; height: 24px; width: 24px;&quot; src=&quot;&#x2F;img&#x2F;facebook.png&quot; class=&quot;clickable&quot;&gt;\n                        &lt;&#x2F;a&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div class=&quot;table-cell center&quot;&gt;\n                        &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;Shaoyang2000&quot; target=&quot;_blank&quot;&gt;\n                          &lt;img style=&quot;vertical-align: baseline; height: 24px; width: 24px;&quot; src=&quot;&#x2F;img&#x2F;twitter.png&quot; class=&quot;clickable&quot;&gt;\n                        &lt;&#x2F;a&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div class=&quot;table-cell center&quot;&gt;\n                        &lt;a href=&quot;https:&#x2F;&#x2F;t.me&#x2F;idoras_official&quot; target=&quot;_blank&quot;&gt;\n                          &lt;img style=&quot;vertical-align: baseline; height: 24px; width: 24px;&quot; src=&quot;&#x2F;img&#x2F;telegram.png&quot; class=&quot;clickable&quot;&gt;\n                        &lt;&#x2F;a&gt;\n                      &lt;&#x2F;div&gt;\n                    &lt;&#x2F;div&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n              &lt;&#x2F;div&gt;\n              &lt;div class=&quot;listWidget&quot;&gt;\n                &lt;div class=&quot;box&quot;&gt;\n                  &lt;div class=&quot;title bread-crumbs&quot;&gt;\n                    &lt;h5 class=&quot;widgetHeader&quot;&gt;Popular In Last 24 Hours&lt;&#x2F;h5&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n                {% for item in info.hots[0].list %}\n                &lt;div&gt;\n                  &lt;div class=&quot;appRow&quot;&gt;\n                    &lt;div class=&quot;table-row&quot;&gt;\n                      &lt;div style=&quot;width: 56px;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;img style=&quot;width:50px; height:50px;&quot;\n                          src=&quot;https:&#x2F;&#x2F;img.idoras.com&#x2F;img&#x2F;{{item.id}}.png&quot;&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div class=&quot;table-cell&quot;&gt;\n                        &lt;h5 title=&quot;{{item.name}} {{item.versionName}}&quot; class=&quot;appRowTitle wrapText marginZero block-on-mobile&quot;&gt;\n                          &lt;a class=&quot;fontBlack&quot; href=&quot;&#x2F;apk&#x2F;{{item.id}}&#x2F;&quot;&gt;{{item.name}} {{item.versionName}}&lt;&#x2F;a&gt;\n                        &lt;&#x2F;h5&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div style=&quot;width: 50px; text-align: right;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;span style=&quot;padding-right:12px;&quot; class=&quot;colorLightBlack&quot;&gt;{{item.down}}&lt;&#x2F;span&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div style=&quot;width: 22px;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;div class=&quot;iconsBox one-icon&quot;&gt;\n                          &lt;div class=&quot;downloadIconPositioning&quot;&gt;\n                            &lt;a class=&quot;downloadLink&quot;\n                              href=&quot;&#x2F;apk&#x2F;{{item.id}}&#x2F;&quot;&gt;\n                              &lt;i class=&quot;material-icons icon-blue&quot; aria-hidden=&quot;true&quot;&gt;download&lt;&#x2F;i&gt;\n                            &lt;&#x2F;a&gt;\n                          &lt;&#x2F;div&gt;\n                        &lt;&#x2F;div&gt;\n                      &lt;&#x2F;div&gt;\n                    &lt;&#x2F;div&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n                {% endfor %}\n              &lt;&#x2F;div&gt;\n              &lt;div class=&quot;listWidget&quot;&gt;\n                &lt;div class=&quot;box&quot;&gt;\n                  &lt;div class=&quot;title bread-crumbs&quot;&gt;\n                    &lt;h5 class=&quot;widgetHeader&quot;&gt;Popular In Last 7 Days&lt;&#x2F;h5&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n                {% for item in info.hots[1].list %}\n                &lt;div&gt;\n                  &lt;div class=&quot;appRow&quot;&gt;\n                    &lt;div class=&quot;table-row&quot;&gt;\n                      &lt;div style=&quot;width: 56px;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;img style=&quot;width:50px; height:50px;&quot;\n                          src=&quot;https:&#x2F;&#x2F;img.idoras.com&#x2F;img&#x2F;{{item.id}}.png&quot;&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div class=&quot;table-cell&quot;&gt;\n                        &lt;h5 title=&quot;{{item.name}} {{item.versionName}}&quot; class=&quot;appRowTitle wrapText marginZero block-on-mobile&quot;&gt;\n                          &lt;a class=&quot;fontBlack&quot; href=&quot;&#x2F;apk&#x2F;{{item.id}}&#x2F;&quot;&gt;{{item.name}} {{item.versionName}}&lt;&#x2F;a&gt;\n                        &lt;&#x2F;h5&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div style=&quot;width: 50px; text-align: right;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;span style=&quot;padding-right:12px;&quot; class=&quot;colorLightBlack&quot;&gt;{{item.down}}&lt;&#x2F;span&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div style=&quot;width: 22px;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;div class=&quot;iconsBox one-icon&quot;&gt;\n                          &lt;div class=&quot;downloadIconPositioning&quot;&gt;\n                            &lt;a class=&quot;downloadLink&quot;\n                              href=&quot;&#x2F;apk&#x2F;{{item.id}}&#x2F;&quot;&gt;\n                              &lt;i class=&quot;material-icons icon-blue&quot; aria-hidden=&quot;true&quot;&gt;download&lt;&#x2F;i&gt;\n                            &lt;&#x2F;a&gt;\n                          &lt;&#x2F;div&gt;\n                        &lt;&#x2F;div&gt;\n                      &lt;&#x2F;div&gt;\n                    &lt;&#x2F;div&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n                {% endfor %}\n              &lt;&#x2F;div&gt;\n              &lt;div class=&quot;listWidget&quot;&gt;\n                &lt;div class=&quot;box&quot;&gt;\n                  &lt;div class=&quot;title bread-crumbs&quot;&gt;\n                    &lt;h5 class=&quot;widgetHeader&quot;&gt;Popular In Last 30 Days&lt;&#x2F;h5&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n                {% for item in info.hots[2].list %}\n                &lt;div&gt;\n                  &lt;div class=&quot;appRow&quot;&gt;\n                    &lt;div class=&quot;table-row&quot;&gt;\n                      &lt;div style=&quot;width: 56px;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;img style=&quot;width:50px; height:50px;&quot;\n                          src=&quot;https:&#x2F;&#x2F;img.idoras.com&#x2F;img&#x2F;{{item.id}}.png&quot;&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div class=&quot;table-cell&quot;&gt;\n                        &lt;h5 title=&quot;{{item.name}} {{item.versionName}}&quot; class=&quot;appRowTitle wrapText marginZero block-on-mobile&quot;&gt;\n                          &lt;a class=&quot;fontBlack&quot; href=&quot;&#x2F;apk&#x2F;{{item.id}}&#x2F;&quot;&gt;{{item.name}} {{item.versionName}}&lt;&#x2F;a&gt;\n                        &lt;&#x2F;h5&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div style=&quot;width: 50px; text-align: right;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;span style=&quot;padding-right:12px;&quot; class=&quot;colorLightBlack&quot;&gt;{{item.down}}&lt;&#x2F;span&gt;\n                      &lt;&#x2F;div&gt;\n                      &lt;div style=&quot;width: 22px;&quot; class=&quot;table-cell&quot;&gt;\n                        &lt;div class=&quot;iconsBox one-icon&quot;&gt;\n                          &lt;div class=&quot;downloadIconPositioning&quot;&gt;\n                            &lt;a class=&quot;downloadLink&quot;\n                              href=&quot;&#x2F;apk&#x2F;{{item.id}}&#x2F;&quot;&gt;\n                              &lt;i class=&quot;material-icons icon-blue&quot; aria-hidden=&quot;true&quot;&gt;download&lt;&#x2F;i&gt;\n                            &lt;&#x2F;a&gt;\n                          &lt;&#x2F;div&gt;\n                        &lt;&#x2F;div&gt;\n                      &lt;&#x2F;div&gt;\n                    &lt;&#x2F;div&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n                {% endfor %}\n              &lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class=&quot;footer&quot;&gt;\n        &lt;div class=&quot;b&quot;&gt;\n          &lt;p&gt;&lt;a href=&quot;&#x2F;about&#x2F;&quot;&gt;About Us&lt;&#x2F;a&gt; | &lt;a href=&quot;&#x2F;contact-us&#x2F;&quot;&gt;Contact Us&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;\n          &lt;p&gt;&lt;a href=&quot;&#x2F;privacy-policy&#x2F;&quot; rel=&quot;nofollow&quot;&gt;Privacy Policy&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;\n          &lt;p&gt;&lt;a href=&quot;&#x2F;report-content&#x2F;&quot;&gt;Report abuse&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;\n          &lt;p&gt;&lt;a href=&quot;&#x2F;dmca&#x2F;&quot; rel=&quot;nofollow&quot;&gt;DMCA Disclaimer&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;\n          &lt;p&gt;idoras.com © 2016-2021&lt;&#x2F;p&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;main&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script src=&quot;&#x2F;js&#x2F;material-components-web.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src=&quot;&#x2F;js&#x2F;app.js?v=20210805&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n</code></pre><p>That’s the main code i wrote for the website, leave a comment if you want to know more about my code, at last remember the website address <a href=\"https://idoras.com\">https://idoras.com</a> i built a week ago, and share it with your firends if you find it useful, thanks.</p>\n</div>",
      "title": "step by step guide tell you how to build a website like apkmirror",
      "author": {
        "loginname": "fengmao",
        "avatar_url": "https://avatars.githubusercontent.com/u/30584594?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 179,
      "country": "Eurozone"
    },
    {
      "id": "610bb232a5d29d36322d4a3f",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fl_FcCIi1yExliz2qCUQiY8_zyFU\" alt=\"dizhi.png\"></p>\n</div>",
      "title": "做技术就得要追赶最新的潮流，不然就落伍了",
      "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 180,
      "country": "USA"
    },
    {
      "id": "55b9e875f36f579657fc52f3",
      "content": "<div class=\"markdown-text\"><p>在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？</p>\n<p>大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。</p>\n<p>要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。</p>\n<blockquote>\n<p>本文的示例代码会备份到 Github : <a href=\"https://github.com/JerryC8080/unittest-demo\">unittest-demo</a></p>\n</blockquote>\n<h2>目录</h2>\n<ol>\n<li>测试框架</li>\n<li>断言库</li>\n<li>需求变更</li>\n<li>异步测试</li>\n<li>异常测试</li>\n<li>测试私有方法</li>\n<li>测试Web应用</li>\n<li>覆盖率</li>\n<li>使用Makefile把测试串起来</li>\n<li>持续集成，Travis-cli</li>\n<li>一些观点</li>\n<li>彩蛋</li>\n<li>整理</li>\n</ol>\n<h2>测试框架</h2>\n<p>Nodejs的测试框架还用说？大家都在用，Mocha。</p>\n<p>Mocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持<strong>BDD</strong>、<strong>TDD</strong>、<strong>QUnit</strong>、<strong>Exports</strong>式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的<a href=\"http://mochajs.org/\">官网</a></p>\n<h4>\b</h4>\n<h4>测试接口</h4>\n<p>Mocha的BDD接口有：</p>\n<ul>\n<li><code>describe()</code></li>\n<li><code>it()</code></li>\n<li><code>before()</code></li>\n<li><code>after()</code></li>\n<li><code>beforeEach()</code></li>\n<li><code>afterEach()</code></li>\n</ul>\n<h4>安装</h4>\n<p><code>npm install mocha -g</code></p>\n<h4>编写一个稳定可靠的模块</h4>\n<p>模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回</p>\n<pre class=\"prettyprint language- javascript\"><code>exports.limit = function (num) {\n  if (num &lt; 0) {\n    return 0;\n  }\n  return num;\n};\n</code></pre><h4>目录分配</h4>\n<ul>\n<li><code>lib</code>，存放模块代码的地方</li>\n<li><code>test</code>，存放单元测试代码的地方</li>\n<li><code>index.js</code>，向外导出模块的地方</li>\n<li><code>package.json</code>，包描述文件</li>\n</ul>\n<h4>测试</h4>\n<pre class=\"prettyprint language- javascript\"><code>var lib = require(&#x27;index&#x27;);\n\ndescribe(&#x27;module&#x27;, function () {\n  describe(&#x27;limit&#x27;, function () {\n    it(&#x27;limit should success&#x27;, function () {\n      lib.limit(10);\n    });\n  });\n});\n</code></pre><h4>结果</h4>\n<p>在当前目录下执行<code>mocha</code>：</p>\n<pre class=\"prettyprint language-\"><code>$ mocha\n\n  ․\n\n  ✔ 1 test complete (2ms)\n</code></pre><h2>断言库</h2>\n<p>上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：</p>\n<ul>\n<li>should.js</li>\n<li>expect.js</li>\n<li>chai</li>\n</ul>\n<h4>加上断言</h4>\n<p>使用<code>should</code>库为测试用例加上断言</p>\n<pre class=\"prettyprint language- javascript\"><code>it(&#x27;limit should success&#x27;, function () {\n  lib.limit(10).should.be.equal(10);\n});\n</code></pre><h2>\b需求变更</h2>\n<p>需求变更啦： <code>limit</code>这个方法还要求返回值大于100时返回100。</p>\n<p>针对需求重构代码之后，正是测试用例的价值所在了，</p>\n<p>它能确保你的改动对原有成果没有造成破坏。</p>\n<p>但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。</p>\n<h2>异步测试</h2>\n<h4>测试异步回调</h4>\n<p>lib库中新增async函数：</p>\n<pre class=\"prettyprint language- javascript\"><code>exports.async = function (callback) {\n  setTimeout(function () {\n    callback(10);\n  }, 10);\n};\t\n</code></pre><p>测试异步代码：</p>\n<pre class=\"prettyprint language- javascript\"><code>describe(&#x27;async&#x27;, function () {\n  it(&#x27;async&#x27;, function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n</code></pre><h4>测试Promise</h4>\n<p>使用should提供的Promise断言接口:</p>\n<ul>\n<li><code>finally</code> | <code>eventually</code></li>\n<li><code>fulfilled</code></li>\n<li><code>fulfilledWith</code></li>\n<li><code>rejected</code></li>\n<li><code>rejectedWith</code></li>\n<li><code>then</code></li>\n</ul>\n<p>测试代码</p>\n<pre class=\"prettyprint language- javascript\"><code>describe(&#x27;should&#x27;, function () {\n  describe(&#x27;#Promise&#x27;, function () {\n    it(&#x27;should.reject&#x27;, function () {\n      (new Promise(function (resolve, reject) {\n        reject(new Error(&#x27;wrong&#x27;));\n      })).should.be.rejectedWith(&#x27;wrong&#x27;);\n    });\n\n    it(&#x27;should.fulfilled&#x27;, function () {\n      (new Promise(function (resolve, reject) {\n        resolve({username: &#x27;jc&#x27;, age: 18, gender: &#x27;male&#x27;})\n      })).should.be.fulfilled().then(function (it) {\n          it.should.have.property(&#x27;username&#x27;, &#x27;jc&#x27;);\n        })\n    });\n  });\n});\n</code></pre><h4>异步方法的超时支持</h4>\n<p>Mocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。</p>\n<p>可以主动修改超时时间，有两种方法。</p>\n<h4>命令行式</h4>\n<p><code>mocha -t 10000</code></p>\n<h4>API式</h4>\n<pre class=\"prettyprint language- javascript\"><code>describe(&#x27;async&#x27;, function () {\n  this.timeout(10000);\n  it(&#x27;async&#x27;, function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n</code></pre><p>这样的话<code>async</code>执行时间不超过10s，就不会报错timeout错误了。</p>\n<h2>异常测试</h2>\n<p>异常应该怎么测试，现在有<code>getContent</code>方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。</p>\n<pre class=\"prettyprint language- javascript\"><code>exports.getContent = function (filename, callback) {\n  fs.readFile(filename, &#x27;utf-8&#x27;, callback);\n};\n</code></pre><p>这时候就应该模拟(mock)错误环境了</p>\n<h4>简单Mock</h4>\n<pre class=\"prettyprint language- javascript\"><code>describe(&quot;getContent&quot;, function () {\n  var _readFile;\n  before(function () {\n    _readFile = fs.readFile;\n    fs.readFile = function (filename, encoding, callback) {\n      process.nextTick(function () {\n        callback(new Error(&quot;mock readFile error&quot;));\n      });\n    };\t\n  });\n  &#x2F;&#x2F; it();\n  after(function () {\n    &#x2F;&#x2F; 用完之后记得还原。否则影响其他case\n    fs.readFile = _readFile;\n  })\n});\n</code></pre><h4>\bMock库</h4>\n<p>Mock小模块：<a href=\"https://github.com/fent/node-muk\"><code>muk</code></a> ，略微优美的写法：</p>\n<pre class=\"prettyprint language- javascript\"><code>var fs = require(&#x27;fs&#x27;);\nvar muk = require(&#x27;muk&#x27;);\n\nbefore(function () {\n  muk(fs, &#x27;readFile&#x27;, function(path, encoding, callback) {\n    process.nextTick(function () {\n      callback(new Error(&quot;mock readFile error&quot;));\n    });\n  });\n});\n&#x2F;&#x2F; it();\nafter(function () {\n  muk.restore();\n});\n</code></pre><h2>测试私有方法</h2>\n<p>针对一些内部的方法，没有通过exports暴露出来，怎么测试它？</p>\n<pre class=\"prettyprint language- javascript\"><code>function _adding(num1, num2) {\n  return num1 + num2;\n}\n</code></pre><h4>通过rewire导出方法</h4>\n<p>模块：<a href=\"http://jhnns.github.com/rewire/\"><code>rewire</code></a></p>\n<pre class=\"prettyprint language-\"><code>it(&#x27;limit should return success&#x27;, function () {\n  var lib = rewire(&#x27;..&#x2F;lib&#x2F;index.js&#x27;);\n  var litmit = lib.__get__(&#x27;limit&#x27;);\n  litmit(10);\n});\n</code></pre><h2>测试Web应用</h2>\n<p>在开发Web项目的时候，要测试某一个API，如：<code>/user</code>，到底怎么编写测试用例呢？</p>\n<p>使用：<a href=\"https://github.com/visionmedia/supertest\"><code>supertest</code></a></p>\n<pre class=\"prettyprint language- javascript\"><code>var express = require(&quot;express&quot;);\nvar request = require(&quot;supertest&quot;);\nvar app = express();\n\n&#x2F;&#x2F; 定义路由\napp.get(&#x27;&#x2F;user&#x27;, function(req, res){\n  res.send(200, { name: &#x27;jerryc&#x27; });\n});\n\ndescribe(&#x27;GET &#x2F;user&#x27;, function(){\n  it(&#x27;respond with json&#x27;, function(done){\n    request(app)\n      .get(&#x27;&#x2F;user&#x27;)\n      .set(&#x27;Accept&#x27;, &#x27;application&#x2F;json&#x27;)\n      .expect(&#x27;Content-Type&#x27;, &#x2F;json&#x2F;)\n      .expect(200)\n      .end(function (err, res) {\n        if (err){\n          done(err);\n        }\n        res.body.name.should.be.eql(&#x27;jerryc&#x27;);\n        done();\n      })\n  });\n});\n</code></pre><h2>覆盖率</h2>\n<p>测试的时候，我们常常关心，是否所有代码都测试到了。</p>\n<p>这个指标就叫做<a href=\"http://en.wikipedia.org/wiki/Code_coverage\">&quot;代码覆盖率&quot;</a>（code coverage）。它有四个测量维度。</p>\n<blockquote>\n<ul>\n<li><strong>行覆盖率</strong>（line coverage）：是否每一行都执行了？</li>\n<li><strong>函数覆盖率</strong>（function coverage）：是否每个函数都调用了？</li>\n<li><strong>分支覆盖率</strong>（branch coverage）：是否每个if代码块都执行了？</li>\n<li><strong>语句覆盖率</strong>（statement coverage）：是否每个语句都执行了？</li>\n</ul>\n</blockquote>\n<p><a href=\"https://github.com/gotwarlost/istanbul\">Istanbul</a> 是 JavaScript 程序的代码覆盖率工具。</p>\n<h4>安装</h4>\n<p><code>$ npm install -g istanbul</code></p>\n<h4>覆盖率测试</h4>\n<p>在编写过以上的测试用例之后，执行命令：</p>\n<p><code>istanbul cover _mocha</code></p>\n<p>就能得到覆盖率:</p>\n<pre class=\"prettyprint language- javascript\"><code>JerryC% istanbul cover _mocha                                                                                                                                                                \n\n\n  module\n    limit\n      ✓ limit should success\n    async\n      ✓ async\n    getContent\n      ✓ getContent\n    add\n      ✓ add\n\n  should\n    #Promise\n      ✓ should.reject\n      ✓ should fulfilled\n\n\n  6 passing (32ms)\n\n\n================== Coverage summary ======================\nStatements   : 100% ( 10&#x2F;10 )\nBranches     : 100% ( 2&#x2F;2 )\nFunctions    : 100% ( 5&#x2F;5 )\nLines        : 100% ( 10&#x2F;10 )\n==========================================================\n</code></pre><p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg\" alt=\"覆盖率html\"></p>\n<p>上面命令中，<code>istanbul cover</code> 命令后面跟的是 <code>_mocha</code> 命令，前面的下划线是不能省略的。</p>\n<p>因为，<a href=\"https://github.com/gotwarlost/istanbul/issues/44\">mocha 和 _mocha 是两个不同的命令</a>，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p>\n<p>如果要向 mocha 传入参数，可以写成下面的样子。</p>\n<pre class=\"prettyprint language-\"><code>$ istanbul cover _mocha -- tests&#x2F;test.sqrt.js -R spec\n</code></pre><p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接<a href=\"http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps\">1</a>，<a href=\"http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/\">2</a>）。</p>\n<h2>使用Makefile串起项目</h2>\n<pre class=\"prettyprint language-\"><code>TESTS = test&#x2F;*.test.js\nREPORTER = spec\nTIMEOUT = 10000\nJSCOVERAGE = .&#x2F;node_modules&#x2F;jscover&#x2F;bin&#x2F;jscover\n\ntest:\n    @NODE_ENV=test .&#x2F;node_modules&#x2F;mocha&#x2F;bin&#x2F;mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)\n\ntest-cov: lib-cov\n    @LIB_COV=1 $(MAKE) test REPORTER=dot\n    @LIB_COV=1 $(MAKE) test REPORTER=html-cov &gt; coverage.html\n\nlib-cov:\n    @rm -rf .&#x2F;lib-cov\n    @$(JSCOVERAGE) lib lib-cov\n\n.PHONY: test test-cov lib-cov\n\nmake test\nmake test-cov\n\n</code></pre><p>用项目自身的jscover和mocha，避免版本冲突和混乱</p>\n<h2>持续集成，Travis-cli</h2>\n<ul>\n<li><a href=\"https://travis-ci.org/\">Travis-ci</a>\n<ul>\n<li>绑定Github帐号</li>\n<li>在Github仓库的Admin打开Services hook</li>\n<li>打开Travis</li>\n<li>每次push将会hook触发执行<code>npm test</code>命令</li>\n</ul>\n</li>\n</ul>\n<p>注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入<code>.travis.yml</code>文件。内容如下：</p>\n<pre class=\"prettyprint language- yaml\"><code>language: node_js\nnode_js:\n  - &quot;0.12&quot;\n</code></pre><p>Travis-cli还会对项目颁发标签，</p>\n<p><img src=\"https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67\" alt=\"/\">or <img src=\"https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67\" alt=\"/\"></p>\n<p>如果项目通过所有测试，就会build-passing，</p>\n<p>如果项目没有通过所有测试，就会build-failing</p>\n<h2>一些观点</h2>\n<p>实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 “度”, 范围太小施展不开, 太大又侵犯 “别人的” 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.</p>\n<p>这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.</p>\n<p><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">单元测试准则</a></p>\n<h2>彩蛋</h2>\n<p>最后，介绍一个库：<a href=\"https://github.com/Marak/Faker.js\"><code>faker</code></a></p>\n<p>他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。</p>\n<p>是一个开发初期，模拟用户数据的绝佳好库。</p>\n<p>支持Node.js和浏览器端。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg\" alt=\"生成用户\"></p>\n<h2>整理</h2>\n<h4>Nodejs的单元测试工具</h4>\n<ol>\n<li>测试框架 mocha</li>\n<li>断言库：should.js、expect.js、chai</li>\n<li>覆盖率：istanbul、jscover、blanket</li>\n<li>Mock库：muk</li>\n<li>测试私有方法：rewire</li>\n<li>Web测试：supertest</li>\n<li>持续集成：Travis-cli</li>\n</ol>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://github.com/JacksonTian/unittesting\">https://github.com/JacksonTian/unittesting</a></li>\n<li><a href></a><a href=\"http://html5ify.com/unittesting/slides/index.html\">http://html5ify.com/unittesting/slides/index.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/06/istanbul.html\">http://www.ruanyifeng.com/blog/2015/06/istanbul.html</a></li>\n<li><a href=\"http://coolshell.cn/articles/8209.html\">http://coolshell.cn/articles/8209.html</a></li>\n<li><a href=\"http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests\">http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming\">http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming</a></li>\n<li><a href=\"http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D\">http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"https://github.com/visionmedia/superagent/blob/master/Makefile\">https://github.com/visionmedia/superagent/blob/master/Makefile</a></li>\n</ul>\n</div>",
      "title": "在Nodejs中贯彻单元测试",
      "author": {
        "loginname": "JerryC8080",
        "avatar_url": "https://avatars.githubusercontent.com/u/6801672?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 181,
      "country": "USA"
    },
    {
      "id": "5433d5e4e737cbe96dcef312",
      "content": "<div class=\"markdown-text\"><p>GitHub repo 地址：<a href=\"https://github.com/alsotang/node-lessons\">https://github.com/alsotang/node-lessons</a></p>\n<p>如果大家认为漏了哪些初学者应会的内容，可以在此留言，或者开个 issue 给我（!!推荐）。</p>\n<hr>\n<h1>《Node.js 包教不包会》 – by alsotang</h1>\n<h1>为何写作此课程</h1>\n<p>在 CNode(<a href=\"https://cnodejs.org/\">https://cnodejs.org/</a>) 混了那么久，解答了不少 Node.js 初学者们的问题。回头想想，那些问题所需要的思路都不难，但大部分人由于练手机会少，所以在遇到问题的时候很无措。国内唯一一本排的上号的 Node.js 书是 @朴灵(<a href=\"https://github.com/JacksonTian\">https://github.com/JacksonTian</a>) 的 《深入浅出Node.js》(<a href=\"http://book.douban.com/subject/25768396/\">http://book.douban.com/subject/25768396/</a> )，但这本书离实战还是比较远的。</p>\n<p>这个课程是希望提供更多的 Node.js 实战机会，通过每一节精心安排的课程目标，让 Node.js 的初学者们可以循序渐进地，有目的有挑战地开展 Node.js 的学习。</p>\n<p>更多 Node.js 入门资料请前往：<a href=\"https://cnodejs.org/getstart\">https://cnodejs.org/getstart</a></p>\n<h1>课程列表</h1>\n<ul>\n<li>Lesson 0: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson0\">《搭建 Node.js 开发环境》</a></li>\n<li>Lesson 1: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson1\">《一个最简单的 express 应用》</a></li>\n<li>Lesson 2: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson2\">《学习使用外部模块》</a></li>\n<li>Lesson 3: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson3\">《使用 superagent 与 cheerio 完成简单爬虫》</a></li>\n<li>Lesson 4: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson4\">《使用 eventproxy 控制并发》</a></li>\n<li>Lesson 5: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson5\">《使用 async 控制并发》</a></li>\n<li>Lesson 6: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson6\">《测试用例：mocha，should，istanbul》</a></li>\n<li>Lesson 7: 《测试用例：supertest》</li>\n<li>Lesson 8: 《Mongodb 与 Mongoose 的使用》</li>\n<li>Lesson 9: 《一个简单的 blog》</li>\n</ul>\n<h1>License</h1>\n<p>MIT</p>\n</div>",
      "title": "一个面向 Node.js 初学者的系列课程：node-lessons",
      "author": {
        "loginname": "alsotang",
        "avatar_url": "https://avatars.githubusercontent.com/u/1147375?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 182,
      "country": "China"
    },
    {
      "id": "610b5b7fa5d29d526b2d489a",
      "content": "<div class=\"markdown-text\"><p>可以只是mp4格式</p>\n</div>",
      "title": "node解析视频文件宽度、高度、时长等信息的库？有推荐么",
      "author": {
        "loginname": "chenkai0520",
        "avatar_url": "https://avatars.githubusercontent.com/u/30174970?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "num": 183,
      "country": "Japan"
    },
    {
      "id": "61117fb6a5d29d53b52d589d",
      "content": "<div class=\"markdown-text\"><p>如题,国内有类似heroku的pass产品么？</p>\n</div>",
      "title": "国内有类似heroku的pass产品吗？",
      "author": {
        "loginname": "a1292717155",
        "avatar_url": "https://avatars.githubusercontent.com/u/19824463?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 184,
      "country": "USA"
    },
    {
      "id": "61179205baed4e15e5b832b9",
      "content": "<div class=\"markdown-text\"><p>手动阀大大是大非</p>\n</div>",
      "title": "师德师风多所翁热污染",
      "author": {
        "loginname": "wangyifan086411",
        "avatar_url": "https://avatars.githubusercontent.com/u/88570411?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 185,
      "country": "China"
    },
    {
      "id": "610fdaf5a5d29d303d2d5415",
      "content": "<div class=\"markdown-text\"><p><strong>问题大体描述</strong>：大佬们。想请教一下在es6的规范下，咋连接数据库呢？\n<strong>结合自身实际的说明</strong>：\n\t\t我在网上查到commonjs和es6的最大的不同就是导入包的方式不同。而且网上绝大多数教程都是在commonjs的规范下使用require导入数据库包进行连接。所以我根据网上的一些经验介绍，在es6的规范代码里使用除了导包的方法不同之外其他方式与commonjs相同的方式进行连接，但是会报错。希望大佬能够帮忙解答疑惑\n<strong>具体代码和报错如下：</strong>\n\timport mongodb from ‘mongodb’;            //引进数据库模块\nlet mongoClient = mongodb.MongoClient;\nconst url = ‘mongodb://127.0.0.1:27017’;\nclass Db{\n/*\n@database 数据库名字\n@colName  集合名字\n<em>/\nconstructor(database,colName){\nthis.database = database;\nthis.colName = colName;\n}\n/</em>\n查询数据\n@obj  查询的对象\n@cb   回调函数\n*/\nfind(obj,cb){\nlet that = this;\nmongoClient.connect(url,function(err,dbs){\nif(err){ //判断是否出错，err为null则成功\nconsole.log(err);\n}else{\nlet db = dbs.db(that.database);\ndb.createCollection(that.colName).then(function(collection){\ncollection.find(obj).toArray(function(err,data){\ndbs.close(); //关闭数据库\nif(err){\nconsole.log(err);\ncb();\n}else{\ntypeof cb ==‘function’ &amp;&amp; cb(data);\n}\n});\n})\n}</p>\n<pre class=\"prettyprint\"><code>    })\n}\n&#x2F;*\n    插入一条数据\n    @obj  查询的对象\n    @cb   回调函数\n *&#x2F;\ninsertOne(obj,cb){\n    let that = this;\n    mongoClient.connect(url,function(err,dbs){\n        if(err){\n            console.log(err);\n        }else{\n            let db = dbs.db(that.database);\n            db.createCollection(that.colName).then(function(collection){\n                collection.insertOne(obj,function(err){\n                    dbs.close();\n                    if(err){\n                        console.log(err);\n                    }else{\n                        typeof cb ==&#x27;function&#x27; &amp;&amp; cb();\n                    }\n                });\n            })\n        }\n    })\n}\n&#x2F;*\n    插入多条数据\n    @obj  查询的对象\n    @cb   回调函数\n *&#x2F;\ninsertMany(obj,cb){\n    let that = this;\n    mongoClient.connect(url,function(err,dbs){\n        if(err){\n            console.log(err);\n        }else{\n            let db = dbs.db(that.database);\n            db.createCollection(that.colName).then(function(collection){\n                collection.insertMany(obj,function(err){\n                    dbs.close();\n                    if(err){\n                        console.log(err);\n                    }else{\n                        typeof cb ==&#x27;function&#x27; &amp;&amp; cb();\n                    }\n                });\n            })\n        }\n    })\n}\n&#x2F;*\n    删除一条数据\n    @obj  查询的对象\n    @cb   回调函数\n *&#x2F;\ndeleteOne(obj,cb){\n    let that = this;\n    mongoClient.connect(url,function(err,dbs){\n        if(err){\n            console.log(err);\n        }else{\n            let db = dbs.db(that.database);\n            db.createCollection(that.colName).then(function(collection){\n                collection.deleteOne(obj,function(err){\n                    dbs.close();\n                    if(err){\n                        console.log(err);\n                    }else{\n                        typeof cb ==&#x27;function&#x27; &amp;&amp; cb();\n                    }\n                });\n            })\n        }\n    })\n}\n&#x2F;*\n    删除多条数据\n    @obj  查询的对象\n    @cb   回调函数\n *&#x2F;\ndeleteMany(obj,cb){\n    let that = this;\n    mongoClient.connect(url,function(err,dbs){\n        if(err){\n            console.log(err);\n        }else{\n            let db = dbs.db(that.database);\n            db.createCollection(that.colName).then(function(collection){\n                collection.deleteMany(obj,function(err){\n                    dbs.close();\n                    if(err){\n                        console.log(err);\n                    }else{\n                        typeof cb ==&#x27;function&#x27; &amp;&amp; cb();\n                    }\n                });\n            })\n        }\n    })\n}\n&#x2F;*\n    更新一条数据\n    @obj  查询的对象\n    @obj1  更改内容\n    @cb   回调函数\n *&#x2F;\nupdate(obj,newobj,cb){\n    let that = this;\n    mongoClient.connect(url,function(err,dbs){\n        if(err){\n            console.log(err);\n        }else{\n            let db = dbs.db(that.database);\n            db.createCollection(that.colName).then(function(collection){\n                collection.update(obj,newobj,function(err){\n                    dbs.close();\n                    if(err){\n                        console.log(err);\n                    }else{\n                        typeof cb ==&#x27;function&#x27; &amp;&amp; cb();\n                    }\n                });\n            })\n        }\n    })\n\n}\n&#x2F;*\n    更新多条数据\n    @obj  查询的对象\n    @obj1  更改内容\n    @cb   回调函数\n *&#x2F;\nupdateMany(obj,obj1,cb){\n    let that = this;\n    mongoClient.connect(url,function(err,dbs){\n        if(err){\n            console.log(err);\n        }else{\n            let db = dbs.db(that.database);\n            db.createCollection(that.colName).then(function(collection){\n                collection.updateMany(obj,obj1,function(err){\n                    dbs.close();\n                    if(err){\n                        console.log(err);\n                    }else{\n                        typeof cb ==&#x27;function&#x27; &amp;&amp; cb();\n                    }\n                });\n            })\n        }\n    })\n\n}\n</code></pre><p>}\nexport default Db;</p>\n<p>报错：</p>\n<p>ERROR in ./node_modules/mongodb/lib/url_parser.js\nModule not found: Error: Can’t resolve ‘dns’ in ‘C:\\Users\\86136\\Desktop\\writetogether2\\collaborative-editor\\node_modules\\mongodb\\lib’\n@ ./node_modules/mongodb/lib/url_parser.js 7:12-26\n@ ./node_modules/mongodb/lib/operations/connect.js\n@ ./node_modules/mongodb/lib/mongo_client.js\n@ ./node_modules/mongodb/index.js\n@ ./modules/db.js\n@ ./demo/index.js</p>\n<p>ERROR in ./node_modules/mongodb/lib/core/uri_parser.js\nModule not found: Error: Can’t resolve ‘dns’ in ‘C:\\Users\\86136\\Desktop\\writetogether2\\collaborative-editor\\node_modules\\mongodb\\lib\\core’\n@ ./node_modules/mongodb/lib/core/uri_parser.js 4:12-26\n@ ./node_modules/mongodb/lib/core/index.js\n@ ./node_modules/mongodb/index.js\n@ ./modules/db.js\n@ ./demo/index.js</p>\n<p>ERROR in ./node_modules/mongodb/lib/core/auth/gssapi.js\nModule not found: Error: Can’t resolve ‘dns’ in ‘C:\\Users\\86136\\Desktop\\writetogether2\\collaborative-editor\\node_modules\\mongodb\\lib\\core\\auth’\n@ ./node_modules/mongodb/lib/core/auth/gssapi.js 2:12-26\n@ ./node_modules/mongodb/lib/core/index.js\n@ ./node_modules/mongodb/index.js\n@ ./modules/db.js\n@ ./demo/index.js</p>\n</div>",
      "title": "有关在ES6的规范下连接数据库的问题",
      "author": {
        "loginname": "littlebird-maker",
        "avatar_url": "https://avatars.githubusercontent.com/u/64970157?v=4&s=120"
      },
      "important": 3,
      "status": "published",
      "num": 186,
      "country": "Eurozone"
    },
    {
      "id": "6115dacba5d29d0e9d2d64e1",
      "content": "<div class=\"markdown-text\"><p>想把cookie操作用proxy封装，原代码如下：</p>\n<pre class=\"prettyprint\"><code>const cookie = (name, value, options = {}) =&gt; {\n\tif (value !== void 0) {\n\t\tlet s = name + &#x27;=&#x27; + encodeURIComponent(value);\n\t\tif (options.expires &amp;&amp; (typeof options.expires == &#x27;number&#x27; ||\n\t\t\toptions.expires.toUTCString))\n\t\t{\n\t\t\tlet date;\n\t\t\tif (typeof options.expires == &#x27;number&#x27;) {\n\t\t\t\tdate = new Date();\n\t\t\t\tdate.setTime(options.expires * 24 * 3600000 + date.getTime());\n\t\t\t} else {\n\t\t\t\tdate = options.expires;\n\t\t\t}\n\t\t\ts += &#x27;; expires=&#x27; + date.toUTCString();\n\t\t}\n\t\t&#x2F;&#x2F;options: expires,path,domain,secure\n\t\tdelete options.expires;\n\t\tfor (const k in options) s += &#x27;; &#x27; + k + &#x27;=&#x27; + options[k];\n\t\tdocument.cookie = s;\n\t} else {\n\t\tlet s = &#x27;&#x27;+ document.cookie;\n\t\tconst head = name + &#x27;=&#x27;;\n\t\ts = s.split(&#x2F;\\s*;\\s*&#x2F;).find(k =&gt; k.startsWith(head));\n\t\treturn s &amp;&amp; decodeURIComponent(s.slice(name.length + 1));\n\t}\n};\n</code></pre><p>封装后代码，重点看注释行：</p>\n<pre class=\"prettyprint\"><code>const cookie = new Proxy({}, {\n\tget(target, name) {\n\t\t&#x2F;&#x2F; 正常读取属性, name永远为字符串\n\t\t&#x2F;&#x2F; if (typeof name == &#x27;string&#x27;) { &#x2F;&#x2F;如何判断？\n\t\t\t&#x2F;&#x2F; let s = &#x27;&#x27;+ document.cookie;\n\t\t\t&#x2F;&#x2F; const head = name + &#x27;=&#x27;;\n\t\t\t&#x2F;&#x2F; s = s.split(&#x2F;\\s*;\\s*&#x2F;).find(k =&gt; k.startsWith(head));\n\t\t\t&#x2F;&#x2F; return s &amp;&amp; decodeURIComponent(s.slice(name.length + 1));\t\t\t\n\t\t&#x2F;&#x2F; }\n\t\treturn function (value, options = {}) {\n\t\t\tif (value == null) {\n\t\t\t\tvalue = &#x27;&#x27;;\n\t\t\t\toptions.expires = -1;\n\t\t\t}\n\t\t\tlet s = name + &#x27;=&#x27; + encodeURIComponent(value);\n\t\t    options.expires = options.expires || 6;\n\t\t\tif (options.expires &amp;&amp; (typeof options.expires == &#x27;number&#x27; ||\n\t\t\t\toptions.expires.toUTCString))\n\t\t\t{\n\t\t\t\tlet date;\n\t\t\t\tif (typeof options.expires == &#x27;number&#x27;) {\n\t\t\t\t\tdate = new Date();\n\t\t\t\t\tdate.setTime(options.expires * 24 * 3600000 + date.getTime());\n\t\t\t\t} else {\n\t\t\t\t\tdate = options.expires;\n\t\t\t\t}\n\t\t\t\ts += &#x27;; expires=&#x27; + date.toUTCString();\n\t\t\t}\n\t\t\tdelete options.expires;\n\t\t\tfor (const k in options) s += &#x27;; &#x27; + k + &#x27;=&#x27; + options[k];\n\t\t\tdocument.cookie = s;\n\t\t}\n\t}\n});\n&#x2F;&#x2F; cookie.cna; &#x2F;&#x2F;正常读属性\ncookie.cna(&#x27;dfafdda&#x27;); &#x2F;&#x2F;写cookie\n</code></pre></div>",
      "title": "proxy get方法怎么判断是正常读属性或函数调用？",
      "author": {
        "loginname": "xinggsf",
        "avatar_url": "https://avatars.githubusercontent.com/u/13033798?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 187,
      "country": "Japan"
    },
    {
      "id": "6114e40ca5d29d9daf2d631f",
      "content": "<div class=\"markdown-text\"><p>以前非常反感 ts，最近还是被真香定律了<br>\n写了个玩具项目，想了解大家发布到 npm 的流程</p>\n<p>需要编译成 js 后，再手动编写 <code>.d.ts</code> 吗，那文件多了会好麻烦啊</p>\n</div>",
      "title": "用 ts 写的代码发布到 npm，大家喜欢怎么个流程",
      "author": {
        "loginname": "daGaiGuanYu",
        "avatar_url": "https://avatars.githubusercontent.com/u/27003009?v=4&s=120"
      },
      "important": 3,
      "status": "draft",
      "num": 188,
      "country": "China"
    },
    {
      "id": "61139444a5d29d3bb22d5ef7",
      "content": "<div class=\"markdown-text\"><p>该如何解决呢</p>\n</div>",
      "title": "mac 使用 nvm 安装 node 的时候速度特别慢",
      "author": {
        "loginname": "huge689",
        "avatar_url": "https://avatars.githubusercontent.com/u/44516016?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 189,
      "country": "Japan"
    },
    {
      "id": "6114c9a6a5d29d63c42d629d",
      "content": "<div class=\"markdown-text\"><p>代码仓库\n<a href=\"https://github.com/tans/byte-hunter\">https://github.com/tans/byte-hunter</a></p>\n<p><img src=\"http://wimg.caidan2.com/cuimage/20210811184752_x3SBKR_Screenshot.png\" alt></p>\n<p>《字节猎人》 微信群内的打怪升级游戏， 技能和群战系统还未开发。大家给点意见。</p>\n</div>",
      "title": "开源微信群文字聊天RPG游戏",
      "author": {
        "loginname": "trhhh",
        "avatar_url": "https://avatars0.githubusercontent.com/u/543287?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 190,
      "country": "China"
    },
    {
      "id": "6099dc3b4d20cb309b6921d8",
      "content": "<div class=\"markdown-text\"><p>如果给 input 绑定 onChange 事件，感觉会产生非常多重复代码<br>\n或者使用 dom 去取 form 里的值，也挺麻烦的</p>\n</div>",
      "title": "各位使用 react 时，怎么处理表单提交？",
      "author": {
        "loginname": "daGaiGuanYu",
        "avatar_url": "https://avatars.githubusercontent.com/u/27003009?v=4&s=120"
      },
      "important": 1,
      "status": "draft",
      "num": 191,
      "country": "Japan"
    },
    {
      "id": "61133584a5d29d3cd22d5c3f",
      "content": "<div class=\"markdown-text\"><p>我想问一下为什么我使用了require(‘dotenv’).config()，但是.evn.sample里面的这些量不能被程序调用?\n<img src=\"//static.cnodejs.org/FuUs6HNROFeD5Oyx96OmSild2jVj\" alt=\"1628648572(1).png\">\n这上面是.env.sample文件的内容\n<img src=\"//static.cnodejs.org/Fr3X3bZTkoS88oLGCkoqF_fpaLyA\" alt=\"1628648734(1).png\">\n这是引用它的地方\n我用的是编译器是wetstorm\n程序运行后显示的值 是下面这样的\n<img src=\"//static.cnodejs.org/Fqo3JHDlQHqHDN8HYIOYxFFZ3kMb\" alt=\"Inked阿里旺旺图片20210811103325_LI.jpg\"></p>\n</div>",
      "title": "evn.sample中的内容不能被 引用的问题",
      "author": {
        "loginname": "sunboy25",
        "avatar_url": "https://avatars.githubusercontent.com/u/75554611?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 192,
      "country": "Eurozone"
    },
    {
      "id": "6114bc48a5d29dc32f2d624f",
      "content": "<div class=\"markdown-text\"><h2>介绍</h2>\n<p>《你的性格主导色》是今年网易云音乐前端团队开发的一款测试用户主导色的 H5 应用，上线后反响很好，刷爆了微博和朋友圈。</p>\n<p>项目的主要开发者 <code>imyzf</code> 发表了一篇文章《官方揭秘！你的颜色是这样算出来的》，解释了一些动效和最后主导色的计算方面的问题。但由于涉及到了具体的业务，所以作者没有开源出源码，但是热心的作者给了很多的提示。我就是根据这些提示，揭秘了我比较感兴趣的部分。</p>\n<p>在线 <a href=\"https://hezf-music.vercel.app/\">Demo</a></p>\n<p>由于一直没有在生产环境中使用<code>Vue3.0</code>和<code>vite</code>，所以源码部分我使用了 <code>Vue3.0</code>+<code>vite</code>实现。</p>\n<h2>页面预加载</h2>\n<blockquote>\n<p>答题类页面与一般的 H5 页面的不同之处在于，用户的操作路径是确定的，即每个页面的下一页路由是固定的，所以在 router 层面做了优化，提前预加载了下一个页面</p>\n</blockquote>\n<p>由于活动页面使用了大量的视频和动效等，所以想在用户阅读选择题目的过程中把下一页的页面渲染完毕，这样切换到下一页面的时候会很流畅，体验很好。</p>\n<p>最初就想着怎么利用 <code>vue-router</code> 完成页面的预加载。但是搞了一圈发现，都是基于<code>webpack</code>或者<code>vite</code>的懒加载，提前加载了一些资源，并不会提前渲染出页面。</p>\n<p>后来通过看<code>vue-router</code>文档，才找到了灵感，利用命名视图，同时展示 2 个视图，使用<code>css</code>隐藏下一页，这时候虽然不显示，但是页面已经渲染出来了。</p>\n<p>通过修改<code>router-view</code>的 <code>name</code> 属性，完成页面的切换。也就是说，其实我的路由是没有变化的。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; App.vue\n&lt;template&gt;\n  &lt;router-view :name=&quot;currentViewName&quot;&gt;&lt;&#x2F;router-view&gt;\n  &lt;router-view :name=&quot;nextViewName&quot;&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;template&gt;\n\n&#x2F;&#x2F; 注意 ，这里使用两个 viewName 完成了页面的跳转，next 的页面被预加载\nconst currentViewName = computed(() =&gt; store.getters.currentViewName);\nconst nextViewName = computed(() =&gt; store.getters.nextViewName);\n\n&#x2F;&#x2F; router的定义部分\nconst routes = [\n  {\n    path: &#x27;&#x2F;&#x27;,\n    components: {\n      default: Index1,\n      index2: Index2,\n      session1: Session1,\n      session2: Session2,\n      session5: Session5\n    }\n  }\n];\n</code></pre><p>看上面的代码，<code>Index1</code>、<code>Index2</code> 和<code>Session1</code>等其实就是每一页的组件了，通过修改<code>currentViewName</code>和<code>nextViewName</code>就可以达到页面切换的目的。</p>\n<p>最终的效果是下图这样的，下一页已经提前渲染出来：</p>\n<p><img src=\"https://i.loli.net/2021/08/11/Uv1sKMbInzlCwrF.png\" alt></p>\n<h2>翻页动效</h2>\n<p>作者提示说使用<code>canvas</code>实现了页面切换时候的幕布拉动效果，主要运用了最核心的 <code>canvas API</code> 是 <code>bezierCurveTo</code>。</p>\n<p>通过查询得知，<code>bezierCurveTo</code> 需要 3 个 点用来绘制三次贝赛尔曲线，<a href=\"https://www.w3school.com.cn/tags/canvas_beziercurveto.asp\">在线体验</a></p>\n<p>看下图，想要实现拉动动画，<code>P1 P2 P3</code>的<code>X</code>轴坐标需要持续变化，然后绘制曲线，就能够实现拉动的效果了。</p>\n<p><img src=\"https://i.loli.net/2021/08/05/23L7wEYhnfaNdt4.png\" alt></p>\n<p>我这里使用了比较轻量的<code>JavaScript</code> 动画库<code>animejs</code>，用来控制上面几个点的持续移动。3 个动画效果分别移动了<code>P1 P2 P3</code>的<code>X</code>轴坐标 ，再配合曲线的绘制，就达到了基本的拉动幕布效果。</p>\n<pre class=\"prettyprint language-javascript\"><code>  const heights = [0, 0.5 * pageHeight, pageHeight];\n  points = {\n    p1: {\n      x: pageWidth,\n      y: heights[0]\n    },\n    p2: {\n      x: pageWidth,\n      y: heights[1]\n    },\n    p3: {\n      x: pageWidth,\n      y: heights[2]\n    },\n    p4: {\n      x: pageWidth,\n      y: heights[2]\n    },\n    p5: {\n      x: pageWidth,\n      y: heights[0]\n    }\n  };\n\n  &#x2F;&#x2F; P1点的变化\n  anime({\n    targets: points.p1,\n    x: 0,\n    easing: &#x27;easeInQuart&#x27;,\n    delay: 50,\n    duration: 500\n  });\n\n  &#x2F;&#x2F; P2点的变化\n  anime({\n    targets: points.p2,\n    x: 0,\n    easing: &#x27;easeInSine&#x27;,\n    duration: 500\n  });\n\n  anime({\n    targets: points.p2,\n    y: 0.6 * pageHeight,\n    easing: &#x27;easeInSine&#x27;,\n    duration: 500\n  });\n\n  &#x2F;&#x2F; P3点的变化\n  anime({\n    targets: points.p3,\n    x: 0,\n    easing: &#x27;easeInQuart&#x27;,\n    delay: 50,\n    duration: 500\n  });\n\n  &#x2F;&#x2F; 画曲线\n  anime({\n    duration: 550,\n    update: function () {\n      &#x2F;&#x2F; 清除上一次的绘制\n      ctx.clearRect(0, 0, pageWidth, pageHeight);\n      ctx.beginPath();\n      ctx.moveTo(points.p1.x, points.p1.y);\n      &#x2F;&#x2F; 幕布的上半区域\n      ctx.bezierCurveTo(\n        points.p1.x,\n        points.p1.y,\n        points.p2.x,\n        points.p2.y - 0.2 * pageHeight,\n        points.p2.x,\n        points.p2.y\n      );\n      &#x2F;&#x2F; 幕布的下半区域\n      ctx.bezierCurveTo(\n        points.p2.x,\n        points.p2.y + 0.2 * pageHeight,\n        points.p3.x,\n        points.p3.y,\n        points.p3.x,\n        points.p3.y\n      );\n      &#x2F;&#x2F; 已拉动部分的矩形区域\n      ctx.lineTo(points.p4.x, points.p4.y);\n      ctx.lineTo(points.p5.x, points.p5.y);\n      ctx.closePath();\n      ctx.fill();\n      ctx.strokeStyle = &#x27;#f1f1f1&#x27;;\n      ctx.stroke();\n    }\n  });\n</code></pre><p>最终完成的效果是这样的：</p>\n<p><img src=\"https://i.loli.net/2021/08/11/lOimJnR6HZ9Lh7V.gif\" alt></p>\n<p>这个动效由于每一页都需要使用，所以考虑完成一个通用的全局组件。</p>\n<p>考虑到使用的时候一般组件需要写到<code>vue</code> 模板上面，很不方便，所以最好通过一个全局函数直接显示这段动效，类似于<code>showAnimation()</code>;</p>\n<p>首先需要完成一个独立的组件，由于想覆盖掉页面的所有信息，所以使用了 <code>Vue3.0</code> 最新提供的<code>teleport</code> 组件：</p>\n<pre class=\"prettyprint language-javascript\"><code>&lt;!-- 这个canvas会被渲染为 app 的子级 --&gt;\n  &lt;teleport to=&quot;#app&quot;&gt;\n    &lt;canvas class=&quot;mask-canvas&quot; ref=&quot;canvas&quot; :class=&quot;{ &#x27;mask-canvas-posi&#x27;: isShow }&quot;&gt;&lt;&#x2F;canvas&gt;\n  &lt;&#x2F;teleport&gt;\n</code></pre><p>然后需要把组件通过 Vue 插件的方式注册到全局属性，由于我想使用 <code>Composition API</code> ，所以最终决定使用 <code>provide</code>+ <code>inject</code> 的方式注册和使用全局 <code>property</code>。一般的情况下使用<code>app.config.globalProperties</code>就可以了，但是这种配合<code>Composition API</code>写起来会比较麻烦，不推荐。</p>\n<pre class=\"prettyprint language-javascript\"><code>(Mask as any).install = (app: App): void =&gt; {\n  &#x2F;&#x2F; Vue3 的 Composition API 建议使用 provide + inject 的方式注册和使用全局 property\n  app.provide(&#x27;mask&#x27;, Mask);\n};\n\n&#x2F;&#x2F; 使用的时候\nconst Mask = inject(&#x27;mask&#x27;);\n</code></pre><p>最后，由于翻页动效和路由都在一起使用，就继续封装了个<code>useNext</code>函数，这样在一般的<code>view</code>组件使用的话，就非常简单了，同时做了翻页动效和翻页的操作：</p>\n<pre class=\"prettyprint language-javascript\"><code>nextPage();\n</code></pre><p>到这里我可以夸夸<code>Composition API</code>了，非常的简单和方便，通过这个全局通用组件的封装，我彻底喜欢上了这种方式。</p>\n<h2>云层动效</h2>\n<p>这部分是我觉得最有趣的，以前用<code>three.js</code>实现过一个 3D 照片墙，但是这个云层动效真的牛，也是最难破解的，还好被我搞定了，下篇详细说明破解的过程。</p>\n<p><img src=\"https://i.loli.net/2021/08/11/iQlAp3ePza64fZJ.gif\" alt></p>\n<h2>源码</h2>\n<p>最后放上<a href=\"https://github.com/hezhongfeng/music163-demo\">源码</a>，感兴趣的同学可以看一下，欢迎 Star 和提出建议。</p>\n</div>",
      "title": "《你的性格主导色》揭秘",
      "author": {
        "loginname": "hezhongfeng",
        "avatar_url": "https://avatars.githubusercontent.com/u/12163050?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 193,
      "country": "USA"
    },
    {
      "content": "<div class=\"markdown-text\"><p><strong>效果图 1</strong> <img src=\"//static.cnodejs.org/FuNssI0yc_wHEhUR8AeGwyeOEMF3\" alt=\"数字大屏1.png\" /></p>\n<p><img src=\"//static.cnodejs.org/FmzFPqODuuFHmtd4EBIJoCoQV1Uy\" alt=\"数字大屏3.png\" /></p>\n<p><strong>效果图 2</strong> <img src=\"//static.cnodejs.org/Fie3Drfxj3zxGxQ84LeDVaenhS2r\" alt=\"数字大屏2.png\" /></p>\n<p><strong>完整实现步骤：</strong> <a href=\"https://segmentfault.com/a/1190000040482238\">https://segmentfault.com/a/1190000040482238</a></p></div>",
      "title": "低代码搞了款数字大屏，大家看炫不炫",
      "author": {
        "loginname": "dafanzhi",
        "avatar_url": "https://avatars.githubusercontent.com/u/53632540?v=4&s=120"
      },
      "important": 2,
      "status": "draft",
      "id": "611344cfa5d29d19ba2d5cd0",
      "num": 194,
      "country": "Eurozone"
    },
    {
      "id": "61155cd8a5d29d43582d6431",
      "content": "<div class=\"markdown-text\"><h1>下载地址：<a href=\"http://www.97yrbl.com/t-653.html?_dsign=4dacffff\">百度网盘</a></h1>\n<p>实现精美页面是前端工程师的核心能力之一，CSS布局技术是实现精美页面的核心技术，但CSS布局好入门，难精通。本课将围绕前端4大主流布局，通过大量的实际案例，带你边学习，边实操，让你系统掌握CSS布局进阶技术，轻松解决各种精美页面布局难题。</p>\n<p>适合人群\n懂一些HTML、CSS基础的前端小白\n刚毕业找工作的学生\n需要大量布局工作的前端或后端开发\n技术储备\nHTML基础\nCSS基础</p>\n</div>",
      "title": "前端主流布局系统进阶与实战",
      "author": {
        "loginname": "yuanrenbuluo",
        "avatar_url": "https://avatars.githubusercontent.com/u/88777264?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 195,
      "country": "Japan"
    },
    {
      "id": "61148c56a5d29dde912d6110",
      "content": "<div class=\"markdown-text\"><p>我把后台管理的增删改查三接口搞定，上级觉得暴露了数据库的字段名有风险。原因说不出来只觉得能用字段做某些事情。我一直都是用orm去查询数据库，基本避免的sql注入问题。上级以前一直都用的是字符串拼接方式。\n有人知道暴露数据库字段有什么危害么？我是感觉就算把表名字段名暴露出去黑客也不能利用这些东西做什么。</p>\n</div>",
      "title": "暴露表名字段名有什么危害",
      "author": {
        "loginname": "qian-ryan",
        "avatar_url": "https://avatars.githubusercontent.com/u/44833789?v=4&s=120"
      },
      "important": 4,
      "status": "published",
      "num": 196,
      "country": "USA"
    },
    {
      "id": "5f164d1af0739b0e62d11144",
      "content": "<div class=\"markdown-text\"><h2>滚动条</h2>\n<blockquote>\n<p>常见于移动端 App 在滚动点击进入的时候</p>\n</blockquote>\n<h3>问题描述</h3>\n<p>当我们在开发 web app 的时候，经常会遇到一个问题，就是当从一个可滚动的列表页进入到下一个详情页面，然后返回列表页面的时候，很难去还原滚动条的状态，无法记住进来时候的位置。</p>\n<p>以前我尝试过很多方法：</p>\n<ol>\n<li>有 vue-router 自带的 scrollBehavior，需要记住 scrollTop，然后还原，但是管理这个 scrollTop 显得很麻烦，有的时候还不容易取值</li>\n<li>还有使用纯 CSS 的方式，在列表页面放置一个 router-view,详情页面利用 position 和 z-index 覆盖列表页面，返回后直接显示的就是原来的列表页面，这个必须把各层页面路由预先配置好，不然就会显示混乱了，并且同一个页面出现在不同的子路由下，需要配置多次，比如商品详情需要配置在很多个地方，造成冗余</li>\n</ol>\n<p>以上解决方案都不理想</p>\n<h3>解决方案</h3>\n<p>后来我参考 keep-alive 开发了 vue-page-stack 来保存 Vue 页面的栈，即 Vue 中的虚拟 dom，但是滚动条的问题仍然没解决。因为虚拟 dom 没有记录各个组件的滚动状态，所以无法恢复。</p>\n<p>在我使用 cube-ui 的时候发现，使用这个组件库里面的滚动容器，是可以还原出滚动条的，进一步发现是黄轶老师的 better-scroll 的原因。</p>\n<p>通过查看 bs 的源码发现，原来是 bs 的内部实现不是原生滚动，而是记录一些滚动的信息，其中最重要的就是 x 和 y，也就是滚动的值，自己实现了一套滚动行为通过 transform 去实现，在还原虚拟 dom 的时候，滚动的信息也被还原了。</p>\n<p>最终就是 vue—page-stack + bs 可以完美实现页面栈的还原</p>\n<h2>下拉加载</h2>\n<blockquote>\n<p>这个问题多见于消息记录等查询，在小程序中也会这遇到这样的问题</p>\n</blockquote>\n<h3>问题描述</h3>\n<p>绝大多数滚动场景都是上拉加载，上拉加载的时候，加载的内容在滚动区域的下方出现，加载之后，我们将数据添加到列表，由 Vue 等负责渲染新加载的内容，我们继续上拉就可以继续滚动查看。</p>\n<p>但在我们的场景下，在某一会话中翻阅消息记录的时候，是下拉加载更多消息，加载后，继续下拉慢慢滚动查看。这就导致了一个很严重的问题：下拉加载后出现的内容在滚动区域的上方，不做任何处理的话加载后会直接跳到新加载内容的最上方，因为滚动距离没变，这就出问题了，和我们想实现的不一致。</p>\n<h3>解决方案</h3>\n<p>也想了很多的方法，包括计算新增加消息的总长度，然后滚回来，但是消息的类型和高度不一致，计算会有误差。</p>\n<p>最终想到的处理办法就是：</p>\n<ol>\n<li>通过接口获取到加载信息后首先标记（使用 shouldScroll 标记）后端返回的第一条信息，也就是加载后我们的视角要看到的新内容</li>\n<li>messageList 更新后，Vue 会更新数据和视图，这时候页面 dom 被更新了</li>\n<li>MessageItem 组件 mounted 后，这时候已经完成了视图的渲染，通过检查标记（shouldScroll）,通知父容器滚动到刚才标记的位置，也就是加载的第一条信息处，这样也就把渲染和滚动做到一起了</li>\n</ol>\n<p>以上两个问题在下图均有体现，效果还可以，如下：</p>\n<p><img src=\"https://i.loli.net/2020/07/21/tYHpv4EGsf2iMLr.gif\" alt></p>\n<p>以上内容在我的即时通讯应用<a href=\"https://github.com/hezhongfeng/im-fe-client\">客户端</a>中均有体现，欢迎查看源码</p>\n<p>现已部署上线，欢迎体验<a href=\"https://im-client.hezf.online/\">客户端</a>和<a href=\"https://im-admin.hezf.online/\">管理端</a></p>\n</div>",
      "title": "Vue完美记住滚动条和实现下拉加载",
      "author": {
        "loginname": "hezhongfeng",
        "avatar_url": "https://avatars.githubusercontent.com/u/12163050?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 197,
      "country": "USA"
    },
    {
      "id": "610eb6faa5d29d97022d5151",
      "content": "<div class=\"markdown-text\"><p>闲着也是闲着，突然发现我已经很久很久没有打开过支付宝APP了\n1.因为我的手机是千元安卓红米机，性能是比较差的，很早就发现日常线下支付微信要比支付宝快得多，原因自然是微信是常驻内存，而支付宝没人会允许它常驻内存吧？\n2.在余额宝收益比较高的时候我会把一部分钱放进余额宝，当然，因为我是写程序的，绝对不会把鸡蛋都放在一个篮子里，因此我很快就发现钱庄的APP收益要远高于余额宝\n3.在我还不了解信用卡的时候，是花呗带我入的超前消费的门，后来我办理了信用卡，虽然下卡只给了我5k的额度，但很快钱庄就发现我是个重要用户给我提上去了\n似乎支付宝并没有那么重要，唯一让我担忧的是如果卸载了支付宝是不是会影响我在淘宝APP上购物？\n带着疑问，一狠心我就把支付宝APP卸载了，然后上淘宝APP挑了一件商品，结果，正常使用！\n那么支付宝还有什么理由继续待在我的手机里？\n感觉卸载后手机都运行得快了一点，也许是心理作用，支付宝不回归钱包属性整那么多花哨的功能消耗手机资源，打又打不过人家，也许支付宝在我这里最多只能安装在备用手机上了</p>\n</div>",
      "title": "支付宝在你的生活中重要吗？",
      "author": {
        "loginname": "zengming00",
        "avatar_url": "https://avatars.githubusercontent.com/u/5255081?v=4&s=120"
      },
      "important": 1,
      "status": "published",
      "num": 198,
      "country": "USA"
    },
    {
      "id": "60ed05cae3e671154458d802",
      "content": "<div class=\"markdown-text\"><p>请问用nodejs 做saas架构的web系统怎么做数据隔离，typeorm是否有好的方案做租户数据隔离操作，或者有没有其他的好的实践方案。不想每个操作数据库的地方人工判断，想要一个可以自动拦截sql自动处理识别租户然后再和数据库交互的方法。</p>\n</div>",
      "title": "请问用nodejs 做saas架构的web系统怎么做数据隔离",
      "author": {
        "loginname": "tuohuang",
        "avatar_url": "https://avatars.githubusercontent.com/u/14804820?v=4&s=120"
      },
      "important": 4,
      "status": "draft",
      "num": 199,
      "country": "Japan"
    },
    {
      "id": "61132917a5d29d2c812d5bf8",
      "content": "<div class=\"markdown-text\"><p>关注<a href=\"https://github.com/simon9124/my_demos/blob/master/README.md\">前端小讴</a>，阅读更多原创技术文章</p>\n<p><a href=\"https://github.com/simon9124/my_demos/blob/master/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89/%E7%AC%AC10%E7%AB%A0%20%E5%87%BD%E6%95%B0/10.12-10.13.%E9%80%92%E5%BD%92.js\">相关代码→</a></p>\n<h1>10.12 递归</h1>\n<ul>\n<li><strong>递归函数</strong>是一个函数通过名称<strong>调用自己</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function factorial(num) {\n  if (num &lt;= 1) {\n    return 1\n  } else {\n    return num * factorial(num - 1)\n  }\n}\n</code></pre><ul>\n<li>函数逻辑与函数名是<strong>藕和</strong>的，因此将递归函数赋值给其他变量，并解除原函数名与函数之间的关系后，会报错</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let anotherFactorial = factorial &#x2F;&#x2F; 访问指针\nfactorial = null &#x2F;&#x2F; 切断factorial与函数之间的联系\nconsole.log(anotherFactorial(4)) &#x2F;&#x2F; TypeError: factorial is not a function\n</code></pre><ul>\n<li>使用<code>arguments.callee</code>解藕（<code>arguments.callee</code>指向<code>arguments</code>所在函数的指针）</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function factorial2(num) {\n  if (num &lt;= 1) {\n    return 1\n  } else {\n    return num * arguments.callee(num - 1)\n  }\n}\nlet anotherFactorial2 = factorial2 &#x2F;&#x2F; 访问指针\nfactorial2 = null &#x2F;&#x2F; 切断factorial与函数之间的联系\nconsole.log(anotherFactorial2(4)) &#x2F;&#x2F; 24，arguments.callee指向anotherFactorial2\n</code></pre><ul>\n<li><strong>严格模式</strong>下不能访问<code>argumengts.callee</code>（会报错），使用<strong>命名函数表达式</strong>达到目的</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let factorial3 = function f(num) {\n  if (num &lt;= 1) {\n    return 1\n  } else {\n    return num * f(num - 1) &#x2F;&#x2F; 无论赋值给哪个变量，表达式f都不会变\n  }\n}\nlet anotherFactorial3 = factorial3\nfactorial3 = null\nconsole.log(anotherFactorial3(4)) &#x2F;&#x2F; 24\n</code></pre><h1>10.13 尾调用优化</h1>\n<ul>\n<li>ES6 新增非常适合<strong>尾调用</strong>的<strong>内存管理优化</strong>机制，即<strong>外部函数的返回值</strong>是一个<strong>内部函数的返回值</strong></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function outerFunction() {\n  return innerFunction() &#x2F;&#x2F; 尾调用\n}\n</code></pre><ul>\n<li>ES6 优化之前，该例会在内存中如下操作（<strong>每多调用一次嵌套函数，就多增加 1 个栈帧</strong>）：\n<ul>\n<li>执行到<code>outerFunction</code>函数体，第 1 个栈帧被推到栈上</li>\n<li>执行<code>outerFunction</code>函数体到<code>return</code>语句，计算返回值要先计算<code>innerFunction</code></li>\n<li>执行到<code>innerFunction</code>函数体，第 2 个栈帧被推到栈上</li>\n<li>执行<code>innerFunction</code>函数体，计算返回值</li>\n<li>将返回值传回<code>outerFunction</code>，然后<code>outerFunction</code>再返回值</li>\n<li>将栈帧弹出栈外</li>\n</ul>\n</li>\n<li>ES6 优化之后，该例会在内存中如下操作（<strong>无论调用多少次嵌套函数，都只有 1 个栈帧</strong>）：\n<ul>\n<li>执行到<code>outerFunction</code>函数体，第 1 个栈帧被推到栈上</li>\n<li>执行<code>outerFunction</code>函数体到<code>return</code>语句，计算返回值要先计算<code>innerFunction</code></li>\n<li>因为<code>innerFunction</code>的返回值也是<code>outerFunction</code>的返回值，因此<strong>引擎发现可以把第一个栈帧弹出栈外</strong></li>\n<li>弹出<code>outerFunction</code>的栈帧</li>\n<li>执行到<code>innerFunction</code>函数体，第 2 个栈帧被推到栈上</li>\n<li>执行<code>innerFunction</code>函数体，计算返回值</li>\n<li>将<code>innerFunction</code>的栈帧弹出栈外</li>\n</ul>\n</li>\n<li>ES6 尾调用优化的<strong>关键</strong>：如果函数的逻辑允许基于尾调用将其销毁，引擎就会那么多</li>\n</ul>\n<h2>10.13.1 尾调用优化的条件</h2>\n<ul>\n<li>需确定外部栈帧真的没必要存在：\n<ul>\n<li>外码需在<strong>严格模式</strong>下执行\n<ul>\n<li>非严格模式允许使用的<code>f.arguments</code>和<code>f.caller</code>都会引用外部函数的栈帧</li>\n</ul>\n</li>\n<li>外部函数的返回值是对尾调用函数的调用</li>\n<li>尾调用函数返回后，不需要执行额外的逻辑</li>\n<li>尾调用函数不是引用外部函数作用域中自由变量的闭包</li>\n</ul>\n</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>;(&#x27;use strict&#x27;)\n\nfunction outerFunction() {\n  innerFunction() &#x2F;&#x2F; 无优化，尾调用没有返回\n}\n\nfunction outerFunction() {\n  let innerFunctionResult = innerFucntion()\n  return innerFunctionResult() &#x2F;&#x2F; 无优化，尾调用没有直接返回\n}\n\nfunction outerFunction() {\n  return innerFunction().toString() &#x2F;&#x2F; 无优化，尾调用返回后必须转型为字符串（有额外逻辑）\n}\n\nfunction outerFunction() {\n  let foo = &#x27;bar&#x27;\n  function innerFunction() {\n    return foo\n  }\n  return innerFunction() &#x2F;&#x2F; 无优化，尾调用是一个闭包\n}\n\nfunction outerFunction(a, b) {\n  innerFunction(a + b) &#x2F;&#x2F; 有优化，栈帧销毁前执行参数计算\n}\n\nfunction outerFunction(a, b) {\n  if (a &lt; b) return a\n  innerFunction(a + b) &#x2F;&#x2F; 有优化，初始返回值不涉及栈帧\n}\n\nfunction outerFunction(condition) {\n  return condition ? innerFunctionA() : innerFunctionB() &#x2F;&#x2F; 有优化，2个内部函数都在尾部\n}\n</code></pre><h2>10.13.1 尾调用优化的代码</h2>\n<ul>\n<li>尾调用优化在<strong>递归场景</strong>下的效果最明显，因为递归代码最容易在栈内存中迅速产生大量栈帧</li>\n<li>以<strong>斐波那契数列</strong>为例，使用尾调用优化减小浏览器的负担：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function fib(n) {\n  if (n &lt; 2) {\n    return n\n  }\n  return fib(n - 1) + fib(n - 2) &#x2F;&#x2F; 返回语句有相加操作，不符合优化条件\n}\n\n&#x2F;&#x2F; 使用2个嵌套的函数重构斐波那契数列\n;(&#x27;use strict&#x27;)\n\nfunction fib(n) {\n  return fibImp1(0, 1, n) &#x2F;&#x2F; 以0为初始值，1作为第1个数字，n为第几个数字\n}\nfunction fibImp1(a, b, n) {\n  if (n === 0) return a\n  return fibImp1(b, a + b, n - 1) &#x2F;&#x2F; 外部函数的返回值是内部函数的返回值，符合优化条件\n}\n</code></pre><h1>总结 &amp; 问点</h1>\n<ul>\n<li>什么是递归函数？写一段代码表示阶乘，要求解耦函数逻辑和函数名</li>\n<li>严格模式下，写一段代码表示阶乘，要求函数名可以赋给任意变量</li>\n<li>什么是尾调用优化？其是如何优化内存管理的？尾调用优化的条件是什么？</li>\n<li>写一段代码，使用尾递归优化计算斐波那契数列</li>\n</ul>\n</div>",
      "title": "《javascript高级程序设计》学习笔记 | 10.12-10.13.递归",
      "author": {
        "loginname": "simon9124",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "important": 2,
      "status": "published",
      "num": 200,
      "country": "USA"
    },
    {
      "title": "123",
      "important": 4,
      "country": "USA",
      "status": "published",
      "author": {
        "loginname": "sunny-zz",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "id": "pc0ulEC",
      "num": 201
    },
    {
      "title": "123",
      "important": 6,
      "country": "Japan",
      "status": "published",
      "author": {
        "loginname": "sunny-zz",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "id": "rO4w8lf",
      "num": 202
    },
    {
      "title": "1231231231232",
      "important": 3,
      "country": "China",
      "status": "published",
      "author": {
        "loginname": "sunny-zz",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "num": 204,
      "id": "tkrgyb3"
    },
    {
      "title": "123123",
      "important": 5,
      "country": "Japan",
      "status": "draft",
      "author": {
        "loginname": "sunny-zz",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "num": 205,
      "id": "SDpMdmK"
    },
    {
      "title": "12312",
      "important": 0,
      "country": "Japan",
      "status": "draft",
      "author": {
        "loginname": "sunny-zz",
        "avatar_url": "https://avatars.githubusercontent.com/u/32998077?v=4&s=120"
      },
      "num": 206,
      "id": "b0EAUNN"
    }
  ]
}